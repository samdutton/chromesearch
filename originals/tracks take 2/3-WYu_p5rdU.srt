1
00:00:00,000 --> 00:00:05,616

2
00:00:05,616 --> 00:00:06,870
MATT DELANEY: Hi, everyone.

3
00:00:06,870 --> 00:00:08,780
So to start off this performance
talk, welcome to

4
00:00:08,780 --> 00:00:10,810
potentially the juiciest
talk of the day.

5
00:00:10,810 --> 00:00:13,900
You have people who are nice and
hangry before lunch here.

6
00:00:13,900 --> 00:00:18,310
So just to be clear, there were
some kind of questions in

7
00:00:18,310 --> 00:00:21,910
our moderation tool for this
panel that were kind of

8
00:00:21,910 --> 00:00:23,430
overlapping with some
previous talks.

9
00:00:23,430 --> 00:00:25,440
Because performance is
everywhere, right?

10
00:00:25,440 --> 00:00:29,870
So if you look at some of the
questions relating to strictly

11
00:00:29,870 --> 00:00:32,330
kind of network performance
things, those are mostly

12
00:00:32,330 --> 00:00:33,280
covered in previous talks.

13
00:00:33,280 --> 00:00:34,800
We'll mostly skip over those.

14
00:00:34,800 --> 00:00:37,610
So now is your moment to put in
any juicier questions for

15
00:00:37,610 --> 00:00:40,890
front end things, especially
graphics, and all the kind of

16
00:00:40,890 --> 00:00:42,790
client side related performance

17
00:00:42,790 --> 00:00:44,480
concerns you guys have.

18
00:00:44,480 --> 00:00:45,990
So very quickly, I'm going
to run through.

19
00:00:45,990 --> 00:00:49,105
We've got our opening speaker
here, Shane O'Sullivan.

20
00:00:49,105 --> 00:00:51,595
So he's from Facebook,
a UI engineer.

21
00:00:51,595 --> 00:00:53,540
He'll introduce himself
a little bit more.

22
00:00:53,540 --> 00:00:56,720
We have Pavel Feldman
from Google.

23
00:00:56,720 --> 00:00:59,150
He has worked on Chrome
dev tools.

24
00:00:59,150 --> 00:01:02,426
And we have Rowan Beesje?

25
00:01:02,426 --> 00:01:03,530
ROWAN BEENJE: Beenje.

26
00:01:03,530 --> 00:01:04,720
MATT DELANEY: OK.

27
00:01:04,720 --> 00:01:05,900
Knew I was going to
mess that one up.

28
00:01:05,900 --> 00:01:08,945
So he works at FT Labs
with Andrew, and is

29
00:01:08,945 --> 00:01:11,370
known for FT Scroller.

30
00:01:11,370 --> 00:01:14,010
And then we have Chris Lord
from Mozilla, who is a

31
00:01:14,010 --> 00:01:19,340
platform engineer for
Firefox mobile, so

32
00:01:19,340 --> 00:01:21,430
primarily on Android.

33
00:01:21,430 --> 00:01:23,840
So to start, Shane has a little
opening talk for us to

34
00:01:23,840 --> 00:01:25,870
give us a bit of the
lay of the land of

35
00:01:25,870 --> 00:01:27,120
performance at the moment.

36
00:01:27,120 --> 00:01:35,370

37
00:01:35,370 --> 00:01:38,620
SHANE O'SULLIVAN:
So hi, everyone.

38
00:01:38,620 --> 00:01:39,670
I'm Shane O'Sullivan.

39
00:01:39,670 --> 00:01:42,840
I work as a UI engineer
at Facebook.

40
00:01:42,840 --> 00:01:44,220
I spent a couple of years
on the mobile site.

41
00:01:44,220 --> 00:01:47,810
And now I work on our
business interfaces.

42
00:01:47,810 --> 00:01:51,890
As he said, I'm here with
Ron, Chris, and Pavel.

43
00:01:51,890 --> 00:01:55,520
And we're going to talk a bit
about some of the potholes

44
00:01:55,520 --> 00:01:59,670
that are in the road to actually
having a performant

45
00:01:59,670 --> 00:02:04,410
and fast and non-stuttery
website.

46
00:02:04,410 --> 00:02:06,930
The two main things I'm really
going to talk about are

47
00:02:06,930 --> 00:02:13,480
scrolling performance of complex
content, which is more

48
00:02:13,480 --> 00:02:14,780
or less a stress test
for all rendering

49
00:02:14,780 --> 00:02:16,260
platforms, not just web.

50
00:02:16,260 --> 00:02:18,160
People also have a problem
with this on iOS.

51
00:02:18,160 --> 00:02:21,140
God knows they have a problem
with it on Android.

52
00:02:21,140 --> 00:02:23,560
And it more or less
forces us to solve

53
00:02:23,560 --> 00:02:24,910
all the other problems.

54
00:02:24,910 --> 00:02:26,610
And second one is memory
management,

55
00:02:26,610 --> 00:02:29,560
which is quite related.

56
00:02:29,560 --> 00:02:30,950
So to start off, let's
say what the goal is.

57
00:02:30,950 --> 00:02:33,270
The goal is 60 frames per
second animation with no

58
00:02:33,270 --> 00:02:35,070
dropped frames.

59
00:02:35,070 --> 00:02:36,220
This is kind of the panacea.

60
00:02:36,220 --> 00:02:37,470
Everybody wants to get here.

61
00:02:37,470 --> 00:02:40,580

62
00:02:40,580 --> 00:02:42,880
But it's not always possible.

63
00:02:42,880 --> 00:02:45,310
So let's have a fallback goal.

64
00:02:45,310 --> 00:02:49,480
And say, if we can get to 30
frames per second animations.

65
00:02:49,480 --> 00:02:50,820
Make this reliable.

66
00:02:50,820 --> 00:02:53,390
Make it have no stuttering.

67
00:02:53,390 --> 00:02:55,390
This often is achievable.

68
00:02:55,390 --> 00:02:59,900
And in a lot of user tests that
we've done, this tends to

69
00:02:59,900 --> 00:03:01,890
perform a lot better than having
something that runs at

70
00:03:01,890 --> 00:03:05,305
60 frames per second some of the
time, and even 40 frames

71
00:03:05,305 --> 00:03:06,920
per second some of the time.

72
00:03:06,920 --> 00:03:11,000
So if it goes from some 60 down
to 40, back up to 60,

73
00:03:11,000 --> 00:03:12,990
people often see that as being
worse than just having a

74
00:03:12,990 --> 00:03:14,498
steady 30 frames per
second animation.

75
00:03:14,498 --> 00:03:17,730

76
00:03:17,730 --> 00:03:19,920
So nice to have 60.

77
00:03:19,920 --> 00:03:21,960
If we can get a steady 30,
you're generally in a fairly

78
00:03:21,960 --> 00:03:24,300
good place.

79
00:03:24,300 --> 00:03:25,740
So what's stopping
us getting there?

80
00:03:25,740 --> 00:03:27,880
There's a whole bunch
of things.

81
00:03:27,880 --> 00:03:30,130
To start of with is the
large DOM size.

82
00:03:30,130 --> 00:03:32,670
If you want to take something
like Facebook newsfeed, you

83
00:03:32,670 --> 00:03:36,950
have variable height rows made
up of large images, small

84
00:03:36,950 --> 00:03:39,720
images, no images, variable
length text, everything

85
00:03:39,720 --> 00:03:42,490
changes size, and you don't
know what size it is until

86
00:03:42,490 --> 00:03:43,740
you're trying to show
it to somebody.

87
00:03:43,740 --> 00:03:46,120

88
00:03:46,120 --> 00:03:48,630
And also, if you have thousands
of these, which you

89
00:03:48,630 --> 00:03:52,470
technically could, the browser
just starts running into

90
00:03:52,470 --> 00:03:54,010
serious memory problems.

91
00:03:54,010 --> 00:03:55,290
So you have to decide things.

92
00:03:55,290 --> 00:03:55,910
When do you create it?

93
00:03:55,910 --> 00:03:59,150
Do you create it up front
and take an upfront hit?

94
00:03:59,150 --> 00:04:03,610
Do you create it lazily, and
take a hit as people are using

95
00:04:03,610 --> 00:04:05,040
your application?

96
00:04:05,040 --> 00:04:07,230
That often depends on what
you're trying to build.

97
00:04:07,230 --> 00:04:09,760
For example, Gmail takes
a hit up front.

98
00:04:09,760 --> 00:04:12,820
Because they expect you to leave
the tab open for weeks.

99
00:04:12,820 --> 00:04:15,520
Facebook goes the other way,
because it's more of a random

100
00:04:15,520 --> 00:04:16,529
browsing experience.

101
00:04:16,529 --> 00:04:20,600
And they try to make the upfront
hit very small, and

102
00:04:20,600 --> 00:04:21,850
render later.

103
00:04:21,850 --> 00:04:25,260

104
00:04:25,260 --> 00:04:25,660
OK.

105
00:04:25,660 --> 00:04:28,972
So one of the main problems we
have is, if you want to keep

106
00:04:28,972 --> 00:04:32,240
the DOM small, that basically
means you've got to change it

107
00:04:32,240 --> 00:04:32,830
on the fly.

108
00:04:32,830 --> 00:04:34,460
If you have a lot of data to
show, and you don't want to

109
00:04:34,460 --> 00:04:36,920
have a big tree, you've got
to change it on the fly.

110
00:04:36,920 --> 00:04:38,960
And that basically is great.

111
00:04:38,960 --> 00:04:40,550
You've got a nice, small DOM.

112
00:04:40,550 --> 00:04:42,680
But that introduces a whole
bunch of other problems, which

113
00:04:42,680 --> 00:04:44,670
we're going to get into.

114
00:04:44,670 --> 00:04:46,710
One solution people come up
with is have a pool of

115
00:04:46,710 --> 00:04:48,830
reusable DOM elements.

116
00:04:48,830 --> 00:04:50,380
Say you have 20 different
types of

117
00:04:50,380 --> 00:04:51,770
rows you want to show.

118
00:04:51,770 --> 00:04:53,670
Have a pool of each of
them, and reuse them.

119
00:04:53,670 --> 00:04:57,690
So that way you don't go from a
small image to a big image,

120
00:04:57,690 --> 00:04:58,940
back to a small image.

121
00:04:58,940 --> 00:05:02,630
Something with no images,
something with text only.

122
00:05:02,630 --> 00:05:04,770
So this can help.

123
00:05:04,770 --> 00:05:07,740
But you still end up with
kicking off page reflows if

124
00:05:07,740 --> 00:05:08,990
you're not careful.

125
00:05:08,990 --> 00:05:11,670

126
00:05:11,670 --> 00:05:15,630
Also, when you do start changing
things, say you go

127
00:05:15,630 --> 00:05:18,255
from a small bit of text to a
long bit of text, even inside

128
00:05:18,255 --> 00:05:19,900
of something that you haven't
technically changed the

129
00:05:19,900 --> 00:05:21,830
structure of, you can change
the height of it, you can

130
00:05:21,830 --> 00:05:23,590
change the width of it.

131
00:05:23,590 --> 00:05:24,990
And often, you need
to know this.

132
00:05:24,990 --> 00:05:27,420
If you haven't measured
everything ahead of time, then

133
00:05:27,420 --> 00:05:29,390
you need to know how
big something is.

134
00:05:29,390 --> 00:05:31,620
For example, if you want to show
somebody a scroll bar,

135
00:05:31,620 --> 00:05:34,010
they have to know
what size it is.

136
00:05:34,010 --> 00:05:37,880
But the main problem with this
is that touching the

137
00:05:37,880 --> 00:05:39,550
DOM makes Ryan sad.

138
00:05:39,550 --> 00:05:41,020
It makes him very, very sad.

139
00:05:41,020 --> 00:05:43,200
And you don't want
to make Ryan sad.

140
00:05:43,200 --> 00:05:48,630
So measuring the size of a DOM
load, it basically stops

141
00:05:48,630 --> 00:05:49,030
everything.

142
00:05:49,030 --> 00:05:53,110
Makes the browser flush all its
pending operations, and

143
00:05:53,110 --> 00:05:54,790
slows everything down.

144
00:05:54,790 --> 00:05:56,670
So what do we do?

145
00:05:56,670 --> 00:05:58,090
We'd like to keep it
off the UI thread.

146
00:05:58,090 --> 00:06:00,310
This is possible in native.

147
00:06:00,310 --> 00:06:02,810
For example, the Facebook for
iOS app has a completely

148
00:06:02,810 --> 00:06:04,930
separate thread that more or
less does everything the UI

149
00:06:04,930 --> 00:06:07,050
thread does, but does it
off the UI thread.

150
00:06:07,050 --> 00:06:08,710
Measures everything, renders
everything, and then just

151
00:06:08,710 --> 00:06:09,450
passes it over.

152
00:06:09,450 --> 00:06:10,690
That would be lovely.

153
00:06:10,690 --> 00:06:12,690
We can't do that.

154
00:06:12,690 --> 00:06:15,640
One reason is we don't
always have workers

155
00:06:15,640 --> 00:06:16,530
on the latest iOS.

156
00:06:16,530 --> 00:06:19,380
We do on Android.

157
00:06:19,380 --> 00:06:20,900
But we don't always.

158
00:06:20,900 --> 00:06:22,950
Also workers on a single
CPU are slow.

159
00:06:22,950 --> 00:06:25,190
If you're trying to run a worker
on iPhone 4, which only

160
00:06:25,190 --> 00:06:28,400
has a single core, you're not
really getting any gain.

161
00:06:28,400 --> 00:06:30,070
I mean yes, it's different
thread.

162
00:06:30,070 --> 00:06:32,660
But it runs on the same CPU.

163
00:06:32,660 --> 00:06:34,250
And anyway, workers
can't be DOM.

164
00:06:34,250 --> 00:06:35,500
So this doesn't really
help you.

165
00:06:35,500 --> 00:06:38,740

166
00:06:38,740 --> 00:06:40,510
So what can we do?

167
00:06:40,510 --> 00:06:41,190
Hide the scroll bar.

168
00:06:41,190 --> 00:06:42,910
Don't tell people how
much stuff's there.

169
00:06:42,910 --> 00:06:46,710
It's a dirty hack,
but it works.

170
00:06:46,710 --> 00:06:49,170
You don't have to measure a
thousand rows, because just

171
00:06:49,170 --> 00:06:49,570
don't tell them.

172
00:06:49,570 --> 00:06:51,670
Just tell them keep scrolling.

173
00:06:51,670 --> 00:06:53,170
But some people like
scroll bars.

174
00:06:53,170 --> 00:06:56,100
So another thing you can do
is measure when not busy.

175
00:06:56,100 --> 00:06:57,570
This can be fairly tricky.

176
00:06:57,570 --> 00:06:59,030
Because when are you not busy?

177
00:06:59,030 --> 00:07:00,160
You're not touching it now.

178
00:07:00,160 --> 00:07:03,010
What if you start measuring,
you say, I'm going to spend

179
00:07:03,010 --> 00:07:06,595
100 milliseconds measuring
the next X things.

180
00:07:06,595 --> 00:07:08,385
Then in the middle of that 100
milliseconds, someone touches

181
00:07:08,385 --> 00:07:12,350
a page and you miss it because
your JavaScript is running.

182
00:07:12,350 --> 00:07:15,410
You can try and measure in the
middle of a frame, which we've

183
00:07:15,410 --> 00:07:18,145
done before, where we figured,
I spent five milliseconds out

184
00:07:18,145 --> 00:07:21,230
of the 16 or 32 millisecond
frame.

185
00:07:21,230 --> 00:07:24,520
And I'm going to use the
rest to render ahead.

186
00:07:24,520 --> 00:07:25,540
That can work.

187
00:07:25,540 --> 00:07:27,370
But it's really tricky to do.

188
00:07:27,370 --> 00:07:29,350
Something that we're starting to
play with now a bit as well

189
00:07:29,350 --> 00:07:33,165
is measuring on the server,
which is just something we're

190
00:07:33,165 --> 00:07:34,230
only prototyping
at the moment.

191
00:07:34,230 --> 00:07:37,650
But we figure in our use case,
we have at max a few thousand

192
00:07:37,650 --> 00:07:42,660
different ways to arrange all
the individual types of things

193
00:07:42,660 --> 00:07:43,140
on the newsfeed.

194
00:07:43,140 --> 00:07:45,490
And if you have an app like
that, then you can technically

195
00:07:45,490 --> 00:07:46,520
the DOM ahead of time.

196
00:07:46,520 --> 00:07:47,970
Figure out what you fit into.

197
00:07:47,970 --> 00:07:51,340
And just never measure
the DOM at all.

198
00:07:51,340 --> 00:07:52,680
I'm hopeful this might help.

199
00:07:52,680 --> 00:07:55,530
But it doesn't fit
every use case.

200
00:07:55,530 --> 00:07:58,750
But if it does, then measure
things once, and then never

201
00:07:58,750 --> 00:08:00,000
measure them again.

202
00:08:00,000 --> 00:08:02,820

203
00:08:02,820 --> 00:08:05,770
Another annoying thing
is repaints.

204
00:08:05,770 --> 00:08:08,640
Most of this comes in because
images are unpredictable.

205
00:08:08,640 --> 00:08:10,950
They load when you don't want
them to load, like when you're

206
00:08:10,950 --> 00:08:12,620
in the middle of an animation.

207
00:08:12,620 --> 00:08:14,410
They load the wrong size, so
you end up clipping them,

208
00:08:14,410 --> 00:08:15,980
which has its own cost.

209
00:08:15,980 --> 00:08:18,190
Or you end up resizing them,
and it has a massive cost,

210
00:08:18,190 --> 00:08:19,860
which some of the people were
talking about earlier.

211
00:08:19,860 --> 00:08:22,390
Not just network costs, but
obviously performance cost.

212
00:08:22,390 --> 00:08:24,660
And finally, they have
to be decoded.

213
00:08:24,660 --> 00:08:27,340
As we just heard, WebP takes
longer to decode than JPEG,

214
00:08:27,340 --> 00:08:29,640
and JPEG is bad enough
as it is.

215
00:08:29,640 --> 00:08:31,640
So if you're decoding things in
the middle of an animation,

216
00:08:31,640 --> 00:08:35,280
then you're going to
have a bad time.

217
00:08:35,280 --> 00:08:36,299
So what do you do?

218
00:08:36,299 --> 00:08:38,210
Some people defer all
image loading until

219
00:08:38,210 --> 00:08:40,059
you finish an animation.

220
00:08:40,059 --> 00:08:41,370
This is for new images.

221
00:08:41,370 --> 00:08:42,020
That can work.

222
00:08:42,020 --> 00:08:44,680
But it looks bad.

223
00:08:44,680 --> 00:08:47,150
You have a big, empty thing
scrolling by with a little bit

224
00:08:47,150 --> 00:08:48,480
of black text and a
couple of links.

225
00:08:48,480 --> 00:08:50,820
And when you stop, everything
pops in.

226
00:08:50,820 --> 00:08:51,620
It works.

227
00:08:51,620 --> 00:08:52,870
You get nice animation.

228
00:08:52,870 --> 00:08:55,090
And as a start, it's good.

229
00:08:55,090 --> 00:08:57,440
Other people use low res images,
which have a lower

230
00:08:57,440 --> 00:08:58,210
decode cost.

231
00:08:58,210 --> 00:09:02,010
But it still costs paint.

232
00:09:02,010 --> 00:09:06,590
And what we're doing now, or
trying to do, is figure out

233
00:09:06,590 --> 00:09:08,990
how much time each particular
operation, including text

234
00:09:08,990 --> 00:09:12,310
changes and image changes,
take per animation frame.

235
00:09:12,310 --> 00:09:15,790
And we figure we have a 16
millisecond animation frame.

236
00:09:15,790 --> 00:09:17,500
We have used 10 milliseconds.

237
00:09:17,500 --> 00:09:19,710
It normally takes 6
milliseconds to

238
00:09:19,710 --> 00:09:20,740
draw a small image.

239
00:09:20,740 --> 00:09:22,110
So we still have time.

240
00:09:22,110 --> 00:09:23,330
And if we don't, then
we defer it.

241
00:09:23,330 --> 00:09:24,660
And you do get a blank image.

242
00:09:24,660 --> 00:09:27,300
And that gives you the nice
effect of, sometimes you'll

243
00:09:27,300 --> 00:09:30,000
see images scrolling past or
images popping in in the

244
00:09:30,000 --> 00:09:30,890
middle of a scroll.

245
00:09:30,890 --> 00:09:34,240
Sometimes, you don't get to
it, but it tends to look

246
00:09:34,240 --> 00:09:36,180
better than the first one.

247
00:09:36,180 --> 00:09:36,720
That's very hard.

248
00:09:36,720 --> 00:09:38,100
You've got to write
that yourself.

249
00:09:38,100 --> 00:09:40,590
You've got to write
it in JavaScript.

250
00:09:40,590 --> 00:09:42,680
Would be nice if browsers did
these things for you.

251
00:09:42,680 --> 00:09:45,450
But hopefully, we might get
there at some point.

252
00:09:45,450 --> 00:09:47,360
And another one is resizing.

253
00:09:47,360 --> 00:09:49,650
A lot of people think that
resizing images, like just

254
00:09:49,650 --> 00:09:50,300
don't resize.

255
00:09:50,300 --> 00:09:52,700
Don't do it, just clip them.

256
00:09:52,700 --> 00:09:55,100
Often, you can't, as people were
talking about earlier.

257
00:09:55,100 --> 00:09:57,360
Like Jackson was mentioning
at Facebook, we have four

258
00:09:57,360 --> 00:09:58,980
different sizes of images
that we use.

259
00:09:58,980 --> 00:10:00,860
And if you clip them too much,
then it just looks terrible.

260
00:10:00,860 --> 00:10:03,370
You cut off people's heads,
and that kind of thing.

261
00:10:03,370 --> 00:10:07,030
And saying OK, just ship
the right size.

262
00:10:07,030 --> 00:10:08,270
Shipping the right
size is hard.

263
00:10:08,270 --> 00:10:10,330
You've got massive
server costs.

264
00:10:10,330 --> 00:10:14,320
It helps you to be a large
corporation, where you can

265
00:10:14,320 --> 00:10:18,760
tell like Akamai, we really,
really need a solution here.

266
00:10:18,760 --> 00:10:19,820
And they will help you.

267
00:10:19,820 --> 00:10:20,980
If you're not a large
corporation,

268
00:10:20,980 --> 00:10:22,480
you can't do that.

269
00:10:22,480 --> 00:10:26,710
It's very hard to say that if
say I want a 57 by 57 pixel

270
00:10:26,710 --> 00:10:29,170
image, you must serve
it to me.

271
00:10:29,170 --> 00:10:31,930
So one thing you can do is get
designers to calm down a

272
00:10:31,930 --> 00:10:33,180
little bit.

273
00:10:33,180 --> 00:10:36,970
And just tell them, don't try
loading images in subtly

274
00:10:36,970 --> 00:10:38,525
different pixel sizes.

275
00:10:38,525 --> 00:10:41,800
Do you really need a 50
and a 52 pixel image?

276
00:10:41,800 --> 00:10:43,860
Maybe you don't.

277
00:10:43,860 --> 00:10:47,890
Then just have a single 50 pixel
image and you're done.

278
00:10:47,890 --> 00:10:49,800
Designers like to have a free
hand in everything.

279
00:10:49,800 --> 00:10:51,900
But reality has to come into
play at some point.

280
00:10:51,900 --> 00:10:54,460

281
00:10:54,460 --> 00:10:57,590
So one of the final things
is decoding JPEGs.

282
00:10:57,590 --> 00:10:59,370
A lot of people don't
think about this.

283
00:10:59,370 --> 00:11:03,910
A lot of people, they look at
the timeline on Chrome.

284
00:11:03,910 --> 00:11:05,880
And you see a lot of paints
and that kind of thing.

285
00:11:05,880 --> 00:11:08,940
But decoding JPEGs can be a very
large hit, almost as much

286
00:11:08,940 --> 00:11:10,960
as painting sometimes.

287
00:11:10,960 --> 00:11:12,520
One thing we're playing
with is doing

288
00:11:12,520 --> 00:11:13,810
it in a worker thread.

289
00:11:13,810 --> 00:11:16,120
Doing XHR to the server, get
down the data for a JPEG.

290
00:11:16,120 --> 00:11:19,000
Decode it in JavaScript on a
worker thread, ship the data

291
00:11:19,000 --> 00:11:21,280
UI off to the image
on the UI thread.

292
00:11:21,280 --> 00:11:23,000
And then you're only paying
for the paint.

293
00:11:23,000 --> 00:11:24,190
In some cases, that works.

294
00:11:24,190 --> 00:11:25,410
In some cases, it doesn't.

295
00:11:25,410 --> 00:11:26,630
We've only rolled out a test.

296
00:11:26,630 --> 00:11:29,410
But for large images,
it seems to work.

297
00:11:29,410 --> 00:11:30,770
For small images, it doesn't.

298
00:11:30,770 --> 00:11:31,380
It's horrible.

299
00:11:31,380 --> 00:11:33,920
And I wish we could have off
thread JPEG decoding.

300
00:11:33,920 --> 00:11:38,495
But such as it is, it still
slows down our scrolling.

301
00:11:38,495 --> 00:11:39,745
Alex looks thoughtful.

302
00:11:39,745 --> 00:11:43,100

303
00:11:43,100 --> 00:11:44,920
Obviously, there are other
good solutions to this.

304
00:11:44,920 --> 00:11:46,980
But hopefully, the guys will
know some of them.

305
00:11:46,980 --> 00:11:49,820
And the last one that we're
probably going to end up

306
00:11:49,820 --> 00:11:53,440
mentioning is GC, which
everybody knows stands for

307
00:11:53,440 --> 00:11:56,410
Gremlin Carnage.

308
00:11:56,410 --> 00:11:57,800
OK, it really stands for
garbage collection.

309
00:11:57,800 --> 00:11:59,570
But it might as well stand
for Gremlin Carnage.

310
00:11:59,570 --> 00:12:01,640
Because it's just this random
little monster that runs

311
00:12:01,640 --> 00:12:04,270
around, and makes
you very sad.

312
00:12:04,270 --> 00:12:06,040
Unless when he looks really
cute like that, and then

313
00:12:06,040 --> 00:12:07,870
everything's good.

314
00:12:07,870 --> 00:12:11,740
So with garbage collection, you
put all this effort into

315
00:12:11,740 --> 00:12:15,140
having a fantastically good,
smooth animation.

316
00:12:15,140 --> 00:12:17,500
And then something random comes
in and takes up 100

317
00:12:17,500 --> 00:12:19,180
milliseconds and kills
everything.

318
00:12:19,180 --> 00:12:21,660
V8 has, in the last
year or so--

319
00:12:21,660 --> 00:12:25,090
year, 18 months-- come up with
incremental GC, which spreads

320
00:12:25,090 --> 00:12:25,720
the load a bit.

321
00:12:25,720 --> 00:12:28,790
But you still get hit by these
large mark sweep things that

322
00:12:28,790 --> 00:12:31,330
can still take a large
amount of time.

323
00:12:31,330 --> 00:12:33,460
One thing you can do is just
go through your whole code,

324
00:12:33,460 --> 00:12:36,060
and micro-optimize absolutely
every tiny little piece to not

325
00:12:36,060 --> 00:12:40,220
use memory, to reuse events, to
reuse all sorts of things.

326
00:12:40,220 --> 00:12:40,970
It's painstaking.

327
00:12:40,970 --> 00:12:42,620
It takes forever.

328
00:12:42,620 --> 00:12:44,540
And I don't know of
a silver bullet.

329
00:12:44,540 --> 00:12:48,910
But we will be discussing this,
and hopefully somebody

330
00:12:48,910 --> 00:12:51,920
has a silver bullet,
because I want one.

331
00:12:51,920 --> 00:12:52,160
All right.

332
00:12:52,160 --> 00:12:54,628
And with that, let's get
on with the questions.

333
00:12:54,628 --> 00:12:55,880
MATT DELANEY: Thanks, Shane.

334
00:12:55,880 --> 00:13:02,910

335
00:13:02,910 --> 00:13:05,020
So I'm not sure exactly where,
but somewhere out there

336
00:13:05,020 --> 00:13:05,530
there's another mic.

337
00:13:05,530 --> 00:13:08,310
So just keep in mind for this
panel, we have a roving mic

338
00:13:08,310 --> 00:13:10,650
that will magically appear
as you need it.

339
00:13:10,650 --> 00:13:14,140
So we're hoping for even more
people talking in this talk

340
00:13:14,140 --> 00:13:15,650
from the audience, because
everyone deals with

341
00:13:15,650 --> 00:13:17,350
performance.

342
00:13:17,350 --> 00:13:17,600
OK.

343
00:13:17,600 --> 00:13:19,390
So the first question here.

344
00:13:19,390 --> 00:13:24,510

345
00:13:24,510 --> 00:13:27,360
So from our very own Andrew
Betts, we have the first

346
00:13:27,360 --> 00:13:30,605
question which is, with longer
and longer lived pages, will

347
00:13:30,605 --> 00:13:33,170
web developers start having
to spend time on memory

348
00:13:33,170 --> 00:13:33,900
management?

349
00:13:33,900 --> 00:13:35,500
And is that a good thing?

350
00:13:35,500 --> 00:13:38,774
And I'd like to start off Rowan
with this question.

351
00:13:38,774 --> 00:13:40,490
ROWAN BEENJE: Well, I
think Shane, you've

352
00:13:40,490 --> 00:13:43,250
covered some of it there.

353
00:13:43,250 --> 00:13:44,890
I think Shane did cover
some of it there.

354
00:13:44,890 --> 00:13:47,270
We are going to have to worry
a lot more about memory,

355
00:13:47,270 --> 00:13:48,620
especially on memory constraint

356
00:13:48,620 --> 00:13:50,890
stuff like mobile devices.

357
00:13:50,890 --> 00:13:54,715
And the tooling has
got better.

358
00:13:54,715 --> 00:13:57,090
Garbage collection
has got better.

359
00:13:57,090 --> 00:13:58,040
I don't know how much--

360
00:13:58,040 --> 00:14:00,550
AUDIENCE: You had the
mic [INAUDIBLE].

361
00:14:00,550 --> 00:14:03,155
ROWAN BEENJE: I don't know how
much everyone knows about--

362
00:14:03,155 --> 00:14:05,830

363
00:14:05,830 --> 00:14:08,540
I don't know how much everyone
knows about the current memory

364
00:14:08,540 --> 00:14:08,910
implementations.

365
00:14:08,910 --> 00:14:10,950
But it's no longer retain
release stuff.

366
00:14:10,950 --> 00:14:13,140
It's all very nice.

367
00:14:13,140 --> 00:14:15,570
Is anything still attached
to the documents?

368
00:14:15,570 --> 00:14:18,350
So no longer cycles
to worry about.

369
00:14:18,350 --> 00:14:22,090
But you do still have to keep
very careful track of objects,

370
00:14:22,090 --> 00:14:24,440
and make sure you don't have
to attach DOM trees.

371
00:14:24,440 --> 00:14:26,810
Massive memory loss there.

372
00:14:26,810 --> 00:14:29,610
And Chrome tools have got
a lot better in this.

373
00:14:29,610 --> 00:14:30,870
You can do heap snapshots.

374
00:14:30,870 --> 00:14:31,900
You can dip your
heap snapshots.

375
00:14:31,900 --> 00:14:37,070
You can work out where you're
leaking objects in your

376
00:14:37,070 --> 00:14:38,530
application life cycle.

377
00:14:38,530 --> 00:14:40,835
But we are going to have to
worry about a lot more.

378
00:14:40,835 --> 00:14:43,410
As Shane said, reuse isn't
silver bullet.

379
00:14:43,410 --> 00:14:45,520
But it's what we have to work
with for the time being.

380
00:14:45,520 --> 00:14:48,304

381
00:14:48,304 --> 00:14:50,140
MATT DELANEY: Anyone else?

382
00:14:50,140 --> 00:14:52,450
PAVEL FELDMAN: It's a bad thing
that we need to care

383
00:14:52,450 --> 00:14:52,940
about memory.

384
00:14:52,940 --> 00:14:54,110
But it's inevitable.

385
00:14:54,110 --> 00:14:56,530
We'll need to take
care of memory.

386
00:14:56,530 --> 00:14:59,990
And we need to make it a
standard part of our

387
00:14:59,990 --> 00:15:01,440
development practice.

388
00:15:01,440 --> 00:15:03,670
And not only we should care
about the present state, but

389
00:15:03,670 --> 00:15:06,060
about the regressions as well.

390
00:15:06,060 --> 00:15:08,100
Because you don't want to fix
everything, and then lose it

391
00:15:08,100 --> 00:15:10,570
all with some regression bug.

392
00:15:10,570 --> 00:15:14,260
And on the tools front, we are
working on exposing better and

393
00:15:14,260 --> 00:15:14,990
better pictures.

394
00:15:14,990 --> 00:15:18,290
We're currently working on
native memory instrumentation,

395
00:15:18,290 --> 00:15:22,110
so that you saw how much DOM and
strings and resources and

396
00:15:22,110 --> 00:15:24,760
images and decoded images
are taking.

397
00:15:24,760 --> 00:15:27,560
But what we can see is
that apps [? model ?]

398
00:15:27,560 --> 00:15:32,110
is most likely a source of the
memory leak and involved with

399
00:15:32,110 --> 00:15:32,830
memory growth.

400
00:15:32,830 --> 00:15:36,260
So you should be using heap
profiler for that.

401
00:15:36,260 --> 00:15:37,510
And yes, it's complex.

402
00:15:37,510 --> 00:15:42,550
And yes, heap profiling and
memory leak hunting is kind of

403
00:15:42,550 --> 00:15:43,120
a last resort.

404
00:15:43,120 --> 00:15:44,300
You don't want to do that.

405
00:15:44,300 --> 00:15:46,900
But you end up doing it.

406
00:15:46,900 --> 00:15:50,070
And you end up doing it not
only for web, but in any

407
00:15:50,070 --> 00:15:51,000
development platform.

408
00:15:51,000 --> 00:15:53,420
So just make it a standard
practice.

409
00:15:53,420 --> 00:15:58,219

410
00:15:58,219 --> 00:16:00,980
SHANE O'SULLIVAN: One thing that
we've run into is that

411
00:16:00,980 --> 00:16:03,740
often, you know when your app
is not doing anything.

412
00:16:03,740 --> 00:16:06,110
And you know that, for example,
right after someone

413
00:16:06,110 --> 00:16:07,860
finishes scrolling, they're
going to stop and read

414
00:16:07,860 --> 00:16:10,410
something for at least 100
milliseconds before they start

415
00:16:10,410 --> 00:16:12,040
doing interactions again.

416
00:16:12,040 --> 00:16:14,740
And one of the things that would
be fantastic is if you

417
00:16:14,740 --> 00:16:18,730
could just say, I know my app
state Now clean it up.

418
00:16:18,730 --> 00:16:20,660
But don't do it in two
seconds time when

419
00:16:20,660 --> 00:16:22,040
they're scrolling again.

420
00:16:22,040 --> 00:16:22,970
Clean up now.

421
00:16:22,970 --> 00:16:24,930
And I know this has been
brought up before, too.

422
00:16:24,930 --> 00:16:28,770
Everybody who ever built a
garbage collector, and they

423
00:16:28,770 --> 00:16:32,655
always say, it's always best
guess, or maybe that isn't the

424
00:16:32,655 --> 00:16:35,630
best time to do it, and all
that kind of stuff.

425
00:16:35,630 --> 00:16:37,350
But being someone who doesn't
actually know how the

426
00:16:37,350 --> 00:16:41,696
internals work, why is that?

427
00:16:41,696 --> 00:16:43,850
PAVEL FELDMAN: I'm not
commenting on the GC,

428
00:16:43,850 --> 00:16:45,460
controlling GC questions.

429
00:16:45,460 --> 00:16:46,790
It's a tough area.

430
00:16:46,790 --> 00:16:49,570
And you should be really
talking to the

431
00:16:49,570 --> 00:16:51,530
virtual machine engineers.

432
00:16:51,530 --> 00:16:53,940
And they have the
official story.

433
00:16:53,940 --> 00:16:56,474
Paul, what is our
official story?

434
00:16:56,474 --> 00:16:58,442
PAUL: I have no idea.

435
00:16:58,442 --> 00:17:01,130
PAVEL FELDMAN: So the answer
that you get from the

436
00:17:01,130 --> 00:17:05,480
[? vendors ?] is always, we are
going to do best for you.

437
00:17:05,480 --> 00:17:07,140
You don't want to control it.

438
00:17:07,140 --> 00:17:09,420
Or otherwise, you will
lead us into trouble.

439
00:17:09,420 --> 00:17:12,480
But you really need to go into
the details, and talk to the

440
00:17:12,480 --> 00:17:14,670
actual engineers.

441
00:17:14,670 --> 00:17:16,514
SHANE O'SULLIVAN: Do we have
any of them in the room?

442
00:17:16,514 --> 00:17:22,425

443
00:17:22,425 --> 00:17:23,609
MATT DELANEY: This relates
directly to the

444
00:17:23,609 --> 00:17:24,609
next question, it's--

445
00:17:24,609 --> 00:17:26,780
SHANE O'SULLIVAN: Or a dozen of
next questions like that.

446
00:17:26,780 --> 00:17:26,960
MATT DELANEY: What's that?

447
00:17:26,960 --> 00:17:29,830
SHANE O'SULLIVAN: Or a dozen
of next questions on this.

448
00:17:29,830 --> 00:17:30,600
MATT DELANEY: Right.

449
00:17:30,600 --> 00:17:32,980
So this is kind of an
interesting thing from a

450
00:17:32,980 --> 00:17:36,180
standpoint of perhaps getting
the answer from them.

451
00:17:36,180 --> 00:17:40,300
But the next person asks, which
is Shapir from Israel,

452
00:17:40,300 --> 00:17:43,000
is, should JavaScript be allowed
to explicitly trigger

453
00:17:43,000 --> 00:17:45,640
garbage collection when you
the app is idling, say?

454
00:17:45,640 --> 00:17:48,650
Or if the app knows when
it's OK to do so?

455
00:17:48,650 --> 00:17:51,740
Or should it be allowed to
prevent GC when actually

456
00:17:51,740 --> 00:17:53,890
performing time critical
operations?

457
00:17:53,890 --> 00:17:55,370
So this is currently something
that people don't really have

458
00:17:55,370 --> 00:17:55,970
control over.

459
00:17:55,970 --> 00:17:57,530
But, hear your take on it.

460
00:17:57,530 --> 00:18:00,476

461
00:18:00,476 --> 00:18:02,840
ROWAN BEENJE: I think the only
other thing to bear in mind is

462
00:18:02,840 --> 00:18:05,720
that there are occasions when
the browser is going to have

463
00:18:05,720 --> 00:18:07,570
to garbage collect if it's
running out of memory.

464
00:18:07,570 --> 00:18:08,780
So there's always going
to be points where you

465
00:18:08,780 --> 00:18:09,520
can't control it.

466
00:18:09,520 --> 00:18:12,150
But perhaps we could hint,
I'd like the next 16

467
00:18:12,150 --> 00:18:13,150
milliseconds, perhaps.

468
00:18:13,150 --> 00:18:15,812
Please don't garbage collect
during that time.

469
00:18:15,812 --> 00:18:19,450
AUDIENCE: So do you see
observability as a

470
00:18:19,450 --> 00:18:20,860
major issue at TC39?

471
00:18:20,860 --> 00:18:23,450
So one of the things that I
wind up doing is one of

472
00:18:23,450 --> 00:18:25,480
Google's representatives to
the standards body for

473
00:18:25,480 --> 00:18:26,430
JavaScript.

474
00:18:26,430 --> 00:18:30,740
And so being able to know
exactly when garbage

475
00:18:30,740 --> 00:18:34,100
collection happens has
potentially very serious side

476
00:18:34,100 --> 00:18:38,620
effects for cross-document and
cross-origin communication,

477
00:18:38,620 --> 00:18:39,910
which are not friendly.

478
00:18:39,910 --> 00:18:45,110
There's also the concern that
exposing GC will bake into the

479
00:18:45,110 --> 00:18:49,200
web heuristics which are likely
to be proven wrong

480
00:18:49,200 --> 00:18:49,910
anytime now.

481
00:18:49,910 --> 00:18:54,750
So in the history of V8, we've
gone from having a

482
00:18:54,750 --> 00:18:58,960
generational GC to having
many, many, many other

483
00:18:58,960 --> 00:19:00,840
variance of generational GC.

484
00:19:00,840 --> 00:19:04,760
And if you bake in invariants
in your code based on V8,

485
00:19:04,760 --> 00:19:07,390
they'll be wrong under Nitro.

486
00:19:07,390 --> 00:19:10,810
And they'll be wrong under
IonMonkey, or whatever the

487
00:19:10,810 --> 00:19:13,052
next thing is out of
the next vendor.

488
00:19:13,052 --> 00:19:15,530
And so the optimizations you'll
employ are likely to

489
00:19:15,530 --> 00:19:17,310
get you into a place where not
only will you be wrong in the

490
00:19:17,310 --> 00:19:20,710
future version of the VM that
you're currently attempting to

491
00:19:20,710 --> 00:19:23,080
tickle in the right way, you'll
certainly be wrong on

492
00:19:23,080 --> 00:19:24,050
the other VMs, too.

493
00:19:24,050 --> 00:19:26,890
So it's a nasty place to
end your code base up.

494
00:19:26,890 --> 00:19:34,000

495
00:19:34,000 --> 00:19:36,080
CHRIS LORD: I don't have
anything to add to that.

496
00:19:36,080 --> 00:19:38,060
MATT DELANEY: Have you guys run
into any situations where

497
00:19:38,060 --> 00:19:39,900
you felt like it would be a much
better thing to be able

498
00:19:39,900 --> 00:19:41,325
have control over these?

499
00:19:41,325 --> 00:19:43,520
Because in a lot of native
platforms, you have, of

500
00:19:43,520 --> 00:19:46,430
course, different controls over
the VMs, like say in JVM

501
00:19:46,430 --> 00:19:47,020
and whatnot.

502
00:19:47,020 --> 00:19:49,690
Are there any other times in
your experience where you've

503
00:19:49,690 --> 00:19:51,560
dealt with wanting something
like this?

504
00:19:51,560 --> 00:19:55,422

505
00:19:55,422 --> 00:19:56,380
SHANE O'SULLIVAN: Yeah.

506
00:19:56,380 --> 00:19:59,500
It's more from an extremely
high level, rather than be

507
00:19:59,500 --> 00:20:02,110
able to observe specific things,
or even know when it's

508
00:20:02,110 --> 00:20:03,330
going to run.

509
00:20:03,330 --> 00:20:07,430
More from a point of view of
telling it, like you said, I'm

510
00:20:07,430 --> 00:20:09,580
starting to do something
really complicated now.

511
00:20:09,580 --> 00:20:10,800
Just calm down.

512
00:20:10,800 --> 00:20:14,350
And if my memory grows by
another 20 megabytes while

513
00:20:14,350 --> 00:20:17,080
you're waiting to GC, please
wait until I'm finished.

514
00:20:17,080 --> 00:20:19,770
And then feel free to hit
me with a big thing.

515
00:20:19,770 --> 00:20:21,080
I know, it may not
be possible.

516
00:20:21,080 --> 00:20:21,865
But--

517
00:20:21,865 --> 00:20:23,140
AUDIENCE: It can't
be that simple.

518
00:20:23,140 --> 00:20:27,610
Because we're trying to balance
the interests of the

519
00:20:27,610 --> 00:20:31,020
user, who may have triggered
your page to allocate those 20

520
00:20:31,020 --> 00:20:33,430
megabytes, versus, should
they go to swap now?

521
00:20:33,430 --> 00:20:35,670
What else should they be doing
here in order to--

522
00:20:35,670 --> 00:20:38,250
what's the most valuable thing
to do with those 20 megabytes?

523
00:20:38,250 --> 00:20:40,110
And the answer may
not be your app.

524
00:20:40,110 --> 00:20:41,110
You may think it is.

525
00:20:41,110 --> 00:20:43,780
But you may not have a global
view on what the user agent is

526
00:20:43,780 --> 00:20:45,575
doing for the user.

527
00:20:45,575 --> 00:20:48,350
CHRIS LORD: And I think to some
extent here, we're kind

528
00:20:48,350 --> 00:20:50,840
of trying to have our
cake and eat it.

529
00:20:50,840 --> 00:20:53,680
You kind of do have some
control over GC to some

530
00:20:53,680 --> 00:20:57,130
extent, in that you can just not
write things in a way that

531
00:20:57,130 --> 00:21:00,820
will end up with objects
to collect.

532
00:21:00,820 --> 00:21:03,060
It sounds kind of silly.

533
00:21:03,060 --> 00:21:08,220
But that's how like in Java on
Firefox mobile for Android, we

534
00:21:08,220 --> 00:21:11,470
have these problems in a lot
of our codes, like while

535
00:21:11,470 --> 00:21:14,060
you're panning and so
on is Java code.

536
00:21:14,060 --> 00:21:17,970
And if we create a load of
objects during those frames,

537
00:21:17,970 --> 00:21:20,940
then at some point, GC will
comes along at a completely

538
00:21:20,940 --> 00:21:24,890
random time and take more
than a frame's worth of

539
00:21:24,890 --> 00:21:26,850
time to do its work.

540
00:21:26,850 --> 00:21:28,380
And the way we work around
that is just

541
00:21:28,380 --> 00:21:29,890
by not doing that.

542
00:21:29,890 --> 00:21:31,870
We can't change the
garbage collector.

543
00:21:31,870 --> 00:21:34,200
And we probably wouldn't
want to anyway, really.

544
00:21:34,200 --> 00:21:36,740
Because then other things are
going to break, and other

545
00:21:36,740 --> 00:21:39,270
assumptions we've made
are going to break.

546
00:21:39,270 --> 00:21:42,950
You can just write your code
in such a way that it won't

547
00:21:42,950 --> 00:21:44,200
cause a lot of GC.

548
00:21:44,200 --> 00:21:47,445

549
00:21:47,445 --> 00:21:49,630
SHANE O'SULLIVAN:
No, that's true.

550
00:21:49,630 --> 00:21:50,190
Yeah, that's true.

551
00:21:50,190 --> 00:21:51,580
And you should be doing
that anyway.

552
00:21:51,580 --> 00:21:53,980
But it does just get to the
point at some point.

553
00:21:53,980 --> 00:21:55,510
I mean, if you're trying to do
things like I was saying

554
00:21:55,510 --> 00:21:58,160
there, or keep your DOM small,
and have some sort of complex

555
00:21:58,160 --> 00:22:00,600
controller that does all these
things and recycles views and

556
00:22:00,600 --> 00:22:01,850
all that kind of stuff.

557
00:22:01,850 --> 00:22:04,976

558
00:22:04,976 --> 00:22:07,070
You're doing all this to get
around the problem of large

559
00:22:07,070 --> 00:22:10,614
DOM and to avoid repaint, and
get as much reuse as you can.

560
00:22:10,614 --> 00:22:13,850
That inevitably leads to
large memory usage.

561
00:22:13,850 --> 00:22:17,375
If you have static content, like
buttons and icons, and

562
00:22:17,375 --> 00:22:18,190
you're swiping through those.

563
00:22:18,190 --> 00:22:18,890
Absolutely.

564
00:22:18,890 --> 00:22:22,010
But if you simply have megabytes
of data that, as a

565
00:22:22,010 --> 00:22:23,850
person scrolls through, you've
got to show them a piece at a

566
00:22:23,850 --> 00:22:27,900
time, it gets fairly difficult
to start avoiding things.

567
00:22:27,900 --> 00:22:32,280
Even when you cut it down
as much as possible.

568
00:22:32,280 --> 00:22:34,700
CHRIS LORD: I guess you kind
of want to balance the two.

569
00:22:34,700 --> 00:22:38,468

570
00:22:38,468 --> 00:22:39,600
MATT DELANEY: I'm moving on.

571
00:22:39,600 --> 00:22:42,450
So we've got a third question
here, from Jonno

572
00:22:42,450 --> 00:22:43,740
from London, or Yonno?

573
00:22:43,740 --> 00:22:45,860
Is that a person in here?

574
00:22:45,860 --> 00:22:46,840
Yonno?

575
00:22:46,840 --> 00:22:47,760
Anyway.

576
00:22:47,760 --> 00:22:51,230
So we've got a very talked about
topic here, but with

577
00:22:51,230 --> 00:22:52,690
respect to tooling this time.

578
00:22:52,690 --> 00:22:54,880
So when you're using CSS to
manually trigger hardware

579
00:22:54,880 --> 00:22:58,050
acceleration of DOM elements for
animations, for example,

580
00:22:58,050 --> 00:23:01,280
the hack of using translateZ(0),
is there a tool

581
00:23:01,280 --> 00:23:05,770
or any way to measure how this
impacts the users and GPU?

582
00:23:05,770 --> 00:23:06,770
They ask.

583
00:23:06,770 --> 00:23:09,550
Let's start with Feldman.

584
00:23:09,550 --> 00:23:10,110
PAVEL FELDMAN: Yeah.

585
00:23:10,110 --> 00:23:13,620
So you measure it
using timeline.

586
00:23:13,620 --> 00:23:17,640
And I won't comment on whether
it's a good practice or not to

587
00:23:17,640 --> 00:23:18,440
force the hardware

588
00:23:18,440 --> 00:23:19,850
acceleration using that technique.

589
00:23:19,850 --> 00:23:22,460
And Paul can cover that one.

590
00:23:22,460 --> 00:23:28,660
But once you've done that, you
can, in Chrome, and it covers

591
00:23:28,660 --> 00:23:34,460
good part of WebKit, you can use
timeline to measure both

592
00:23:34,460 --> 00:23:38,270
paints times, and just
compare those.

593
00:23:38,270 --> 00:23:42,020
That will obviously depend
on whether you are using

594
00:23:42,020 --> 00:23:42,370
[? retna ?]

595
00:23:42,370 --> 00:23:45,960
or not, size of the screen,
[? whatever, ?]

596
00:23:45,960 --> 00:23:46,550
accelerator.

597
00:23:46,550 --> 00:23:48,770
But you can do that.

598
00:23:48,770 --> 00:23:50,420
You'll need to have an
inventory for that.

599
00:23:50,420 --> 00:23:52,160
Because equipment differs.

600
00:23:52,160 --> 00:23:54,250
And do you want to comment
on the translating?

601
00:23:54,250 --> 00:23:58,731

602
00:23:58,731 --> 00:23:59,190
[? PAUL: ?]

603
00:23:59,190 --> 00:24:06,460
Just one thing about the
translate zed for me is that

604
00:24:06,460 --> 00:24:09,155
the way, certainly in Chrome,
it's handled is that it

605
00:24:09,155 --> 00:24:10,770
creates you a new layer,
but also a layer

606
00:24:10,770 --> 00:24:13,700
with a backing surface.

607
00:24:13,700 --> 00:24:17,340
So that effectively really maps
down to a texture that

608
00:24:17,340 --> 00:24:20,110
needs to be uploaded
to the GPU.

609
00:24:20,110 --> 00:24:22,380
So the net result of this is
that if you've got a translate

610
00:24:22,380 --> 00:24:24,810
zed or across a lot of
elements, on desktop

611
00:24:24,810 --> 00:24:25,630
you might be fine.

612
00:24:25,630 --> 00:24:28,350
Because you've got a lot
more VRAM to play with.

613
00:24:28,350 --> 00:24:30,220
But on mobile, you're going
to get punished.

614
00:24:30,220 --> 00:24:31,930
Because now you've got a lot of
textures that needs to be

615
00:24:31,930 --> 00:24:33,660
uploaded to your GPU.

616
00:24:33,660 --> 00:24:36,330
And the upload time might be
quite slow to get those

617
00:24:36,330 --> 00:24:39,460
textures from the CPU up to
the GPU, depending on the

618
00:24:39,460 --> 00:24:40,400
actual hardware you're
running on.

619
00:24:40,400 --> 00:24:43,240
So it's one of these things
that it's sort

620
00:24:43,240 --> 00:24:45,600
of used with caution.

621
00:24:45,600 --> 00:24:48,500
And it may be that in your
specific implementation it

622
00:24:48,500 --> 00:24:51,130
speeds things up, because you've
got enough VRAM to kind

623
00:24:51,130 --> 00:24:54,460
of cover that debt that you're
kind of creating for yourself.

624
00:24:54,460 --> 00:24:58,140
And it also is good because,
again, in Chrome, if it's

625
00:24:58,140 --> 00:25:00,670
possible, switch the rendering
mode over to thread

626
00:25:00,670 --> 00:25:03,080
compositing, which is often a
good thing, especially if

627
00:25:03,080 --> 00:25:04,700
you've got a lot
of animations.

628
00:25:04,700 --> 00:25:08,360
But you might just see, as
again, a mobile, you might see

629
00:25:08,360 --> 00:25:11,210
it crush your performance
if you do it too much.

630
00:25:11,210 --> 00:25:13,870
CHRIS LORD: Yeah, this is the
same case in Firefox, as well,

631
00:25:13,870 --> 00:25:17,740
where if you add any kind of
transformation, then it will

632
00:25:17,740 --> 00:25:21,620
end up not optimizing it, but
sort of making it appear on

633
00:25:21,620 --> 00:25:23,340
its own layer.

634
00:25:23,340 --> 00:25:25,040
There are other things to
consider, as well, when you're

635
00:25:25,040 --> 00:25:28,260
forcing layers and elements
and that.

636
00:25:28,260 --> 00:25:30,810
If you force something to become
a new layer, you're

637
00:25:30,810 --> 00:25:33,830
also forcing layers to be
underneath it and over it,

638
00:25:33,830 --> 00:25:36,000
depending on the structure
of the document.

639
00:25:36,000 --> 00:25:38,750
And again, depending on the
structure of the document,

640
00:25:38,750 --> 00:25:41,810
you'd also be forcing things
like alpha blending to happen.

641
00:25:41,810 --> 00:25:44,700
You're forcing things like
increased overdraw to happen,

642
00:25:44,700 --> 00:25:46,250
all of these.

643
00:25:46,250 --> 00:25:47,480
And you'd have memory
hit, you'd have

644
00:25:47,480 --> 00:25:50,660
GPU time hit as well.

645
00:25:50,660 --> 00:25:54,240
And at some point, like
translateZ(0) might end up

646
00:25:54,240 --> 00:25:56,596
just being a null op anyway.

647
00:25:56,596 --> 00:25:58,400
ROWAN BEENJE: It is
already on WebKit.

648
00:25:58,400 --> 00:26:00,520
It's been kind of deprecated
[INAUDIBLE].

649
00:26:00,520 --> 00:26:02,930
PAUL: Yeah, they may be like--

650
00:26:02,930 --> 00:26:05,710
there are other ways to trigger
the same behavior so

651
00:26:05,710 --> 00:26:06,890
that the warning [? shot ?]

652
00:26:06,890 --> 00:26:08,810
is, this one might
become null.

653
00:26:08,810 --> 00:26:13,930
But developers might gravitate
towards an alternative way of

654
00:26:13,930 --> 00:26:15,200
triggering the same effect.

655
00:26:15,200 --> 00:26:16,240
It is exactly what
you're saying.

656
00:26:16,240 --> 00:26:18,850
It depends on the context of
when you're using it as to

657
00:26:18,850 --> 00:26:21,880
whether it's actually a suitable
thing to do, really.

658
00:26:21,880 --> 00:26:23,250
MATT DELANEY: So there's really
a lot of knowledge

659
00:26:23,250 --> 00:26:25,030
here, and a lot of gotchas,
depending upon the platform

660
00:26:25,030 --> 00:26:27,300
and what they fall down into
doing, what actual rendering

661
00:26:27,300 --> 00:26:28,450
paths, right?

662
00:26:28,450 --> 00:26:30,090
But I guess for this question,
it'd be really interesting to

663
00:26:30,090 --> 00:26:32,490
point out maybe, especially
with people in the more

664
00:26:32,490 --> 00:26:35,490
constrained environments on
mobile, what do you guys see

665
00:26:35,490 --> 00:26:38,930
out there for tooling to measure
the impact of their

666
00:26:38,930 --> 00:26:42,280
apps usage of this hack upon
what they're doing?

667
00:26:42,280 --> 00:26:44,010
CHRIS LORD: This is quite
a difficult thing.

668
00:26:44,010 --> 00:26:50,320
Because GPU behavior is wildly
different, depending on what

669
00:26:50,320 --> 00:26:51,310
vendor you have.

670
00:26:51,310 --> 00:26:55,070
So Firefox does have a profiling
tool built in, which

671
00:26:55,070 --> 00:27:00,710
will profile at the native level
where time is spent.

672
00:27:00,710 --> 00:27:02,470
And it goes into JavaScript,
as well.

673
00:27:02,470 --> 00:27:06,100
So if you run your page or
your web GL app, and you

674
00:27:06,100 --> 00:27:09,720
scroll around with the profiler
enabled and you stop,

675
00:27:09,720 --> 00:27:12,330
you can see where time
is being spent.

676
00:27:12,330 --> 00:27:15,390
But in terms of getting really
granular results,

677
00:27:15,390 --> 00:27:16,250
that's quite hard.

678
00:27:16,250 --> 00:27:21,430
Like GL drivers quite often,
they'll defer work to the

679
00:27:21,430 --> 00:27:22,660
latest point possible.

680
00:27:22,660 --> 00:27:26,210
So you might find that although
you're doing a load

681
00:27:26,210 --> 00:27:30,100
of vertex upload or something,
you're uploading a load of

682
00:27:30,100 --> 00:27:34,830
data to the GPU, or you're
uploading a load of things,

683
00:27:34,830 --> 00:27:37,360
you might find that actually all
of that takes zero time.

684
00:27:37,360 --> 00:27:40,040
And swap takes all
of your time.

685
00:27:40,040 --> 00:27:43,040
Or clear takes all of your time,
or flush, or some other

686
00:27:43,040 --> 00:27:46,260
command where the GPU's like,
right, OK, we can't defer

687
00:27:46,260 --> 00:27:47,010
things any longer.

688
00:27:47,010 --> 00:27:49,500
We have to flush out
all the work.

689
00:27:49,500 --> 00:27:54,200
And we can't really counteract
that without doing, I guess,

690
00:27:54,200 --> 00:27:57,870
other clever things like having
a shim for the GL

691
00:27:57,870 --> 00:28:00,460
functions and the JavaScript,
so that we can log what

692
00:28:00,460 --> 00:28:04,030
commands you are using, and use
some kind of context to

693
00:28:04,030 --> 00:28:06,930
say, well, maybe you shouldn't
be doing all of this.

694
00:28:06,930 --> 00:28:08,670
Maybe you shouldn't be uploading
all of this data

695
00:28:08,670 --> 00:28:16,310
here, or maybe you should think
of using more VPOs and

696
00:28:16,310 --> 00:28:19,210
batching your drawing, rather
than doing lots of separate

697
00:28:19,210 --> 00:28:21,146
drawing and things like this.

698
00:28:21,146 --> 00:28:24,060
But I think it's going to be
quite difficult, nigh on

699
00:28:24,060 --> 00:28:29,530
impossible, to have a really
granular general profiler when

700
00:28:29,530 --> 00:28:33,725
it comes to GPU use.

701
00:28:33,725 --> 00:28:37,040
But yeah, Firefox has
a built in profiler.

702
00:28:37,040 --> 00:28:40,183
If it's not in the current
release, it's probably in 19

703
00:28:40,183 --> 00:28:41,960
or 20, I forget.

704
00:28:41,960 --> 00:28:44,580
And also for the record,
we have incremental GC

705
00:28:44,580 --> 00:28:47,970
also in 19 or 20.

706
00:28:47,970 --> 00:28:50,460
PAVEL FELDMAN: So before
it gets to Firefox,

707
00:28:50,460 --> 00:28:53,510
we have it in Chrome.

708
00:28:53,510 --> 00:28:58,230
And the way you look at it-- so
there is no GPU profiling.

709
00:28:58,230 --> 00:29:01,240
But there are interesting cases
on the timeline where

710
00:29:01,240 --> 00:29:05,430
you see your CPU time spent
for just JavaScript

711
00:29:05,430 --> 00:29:06,560
[? layer ?] painting.

712
00:29:06,560 --> 00:29:09,440
And it all adds up to some
reasonable amount.

713
00:29:09,440 --> 00:29:11,115
And then there is this
transparent bar.

714
00:29:11,115 --> 00:29:14,550
And you don't know why your
frame has been skipped.

715
00:29:14,550 --> 00:29:19,560
And the reason for that is the
browser was waiting for GPU.

716
00:29:19,560 --> 00:29:23,070
We don't really see that
happening a lot in practice,

717
00:29:23,070 --> 00:29:26,870
on non-heavy 3D apps
whatsoever.

718
00:29:26,870 --> 00:29:30,530
So in most cases, first thing
you check is timeline.

719
00:29:30,530 --> 00:29:32,370
And you're most likely OK.

720
00:29:32,370 --> 00:29:35,950
And the detailed GPU profiling
is still ahead

721
00:29:35,950 --> 00:29:37,133
for Chrome, as well.

722
00:29:37,133 --> 00:29:37,820
CHRIS LORD: Yeah.

723
00:29:37,820 --> 00:29:40,260
It's much better on desktop
than it is on mobile.

724
00:29:40,260 --> 00:29:42,480
And most of my experience is
mobile, so I'm probably going

725
00:29:42,480 --> 00:29:45,680
to be speaking from
that perspective.

726
00:29:45,680 --> 00:29:46,330
You worry less.

727
00:29:46,330 --> 00:29:49,530
I guess everything is
better on desktop.

728
00:29:49,530 --> 00:29:54,620
The state of mobile GPUs, at
least certainly on Android,

729
00:29:54,620 --> 00:29:58,120
although it's getting better,
is like Android-based system

730
00:29:58,120 --> 00:29:59,900
tends to use GPUs more.

731
00:29:59,900 --> 00:30:04,860
Like, drivers have some pretty
awful and incorrect behavior,

732
00:30:04,860 --> 00:30:09,990
and just flat out bugs that will
cause things like this.

733
00:30:09,990 --> 00:30:12,570
You'll have hitches that will
be very hard to trace.

734
00:30:12,570 --> 00:30:16,140
And it will come down to
something like, you've

735
00:30:16,140 --> 00:30:18,270
triggered something
which might do--

736
00:30:18,270 --> 00:30:20,640
like it might update
part of a texture.

737
00:30:20,640 --> 00:30:24,150
And that GPU driver subimage
uploads are

738
00:30:24,150 --> 00:30:24,980
actually just terrible.

739
00:30:24,980 --> 00:30:26,300
And you should never do them.

740
00:30:26,300 --> 00:30:29,200
We try and work around these
things, but I don't know.

741
00:30:29,200 --> 00:30:30,280
It's on mobile it's hard.

742
00:30:30,280 --> 00:30:33,410
But on desktop, it's less
of a concern, I guess.

743
00:30:33,410 --> 00:30:34,700
MATT DELANEY: Also we
have a question from

744
00:30:34,700 --> 00:30:35,980
the audience here.

745
00:30:35,980 --> 00:30:37,030
What's your name?

746
00:30:37,030 --> 00:30:38,485
AUDIENCE: Hi, I'm
DJ Fazzyfist.

747
00:30:38,485 --> 00:30:39,490
No, I'm kidding.

748
00:30:39,490 --> 00:30:39,920
[INAUDIBLE]

749
00:30:39,920 --> 00:30:40,980
from Google.

750
00:30:40,980 --> 00:30:43,670
It's also worth noting that for
those of you daring souls

751
00:30:43,670 --> 00:30:46,490
in here who compile Chromium,
that there is access to the

752
00:30:46,490 --> 00:30:50,450
Skia debugger, which is actually
sort of the hardware

753
00:30:50,450 --> 00:30:51,650
GPU compositor.

754
00:30:51,650 --> 00:30:53,070
It's actually amazing
the insight you can

755
00:30:53,070 --> 00:30:54,040
get from Skia debugger.

756
00:30:54,040 --> 00:30:56,780
You can actually see the GPU
performance for each CSS

757
00:30:56,780 --> 00:30:57,580
element on your page.

758
00:30:57,580 --> 00:31:00,730
You can actually see what your
DOM is doing, and what each

759
00:31:00,730 --> 00:31:03,200
button and how long that's
taking on the GPU.

760
00:31:03,200 --> 00:31:05,940
It's amazing insight if you're
seeing problems in this area,

761
00:31:05,940 --> 00:31:07,870
and definitely worth checking
out if you're willing to

762
00:31:07,870 --> 00:31:08,880
compile Chromium.

763
00:31:08,880 --> 00:31:09,540
AUDIENCE: How do you spell it?

764
00:31:09,540 --> 00:31:10,080
AUDIENCE: Skia?

765
00:31:10,080 --> 00:31:15,800
S-K-I-A. Skia debugger,
check it out.

766
00:31:15,800 --> 00:31:16,511
Hi.

767
00:31:16,511 --> 00:31:19,220
MATT DELANEY: Sounds
pretty good.

768
00:31:19,220 --> 00:31:22,405
PAVEL FELDMAN: Does it already
provide traceability from DOM

769
00:31:22,405 --> 00:31:23,650
and CSS literally?

770
00:31:23,650 --> 00:31:26,040
Because it was bound
to instructions.

771
00:31:26,040 --> 00:31:28,130
And you couldn't really trace
it into particular

772
00:31:28,130 --> 00:31:28,615
[? selector ?]

773
00:31:28,615 --> 00:31:32,035
and/or CSS property.

774
00:31:32,035 --> 00:31:34,380
I don't believe you can now.

775
00:31:34,380 --> 00:31:36,204
AUDIENCE: [INAUDIBLE].

776
00:31:36,204 --> 00:31:38,940
PETE: Mic?

777
00:31:38,940 --> 00:31:40,390
AUDIENCE: Thanks, Pete.

778
00:31:40,390 --> 00:31:42,490
The latest one that I was
playing with had some

779
00:31:42,490 --> 00:31:43,100
abilities there.

780
00:31:43,100 --> 00:31:45,190
Obviously, the tooling needs to
get better across the board

781
00:31:45,190 --> 00:31:48,240
for getting GPU insight for
these sorts of things.

782
00:31:48,240 --> 00:31:51,040
Since kind of the future of web
compositing performance is

783
00:31:51,040 --> 00:31:52,230
on the GPU anyway.

784
00:31:52,230 --> 00:31:54,480
So for those of you who want
to kind of try out and give

785
00:31:54,480 --> 00:31:56,620
feedback for this early stuff,
definitely check out Skia

786
00:31:56,620 --> 00:31:59,100
debugger and kind of get a
chance to chart where these

787
00:31:59,100 --> 00:32:01,290
tools are going in the future.

788
00:32:01,290 --> 00:32:04,060
PAVEL FELDMAN: So the way it
works pretty much, if I

789
00:32:04,060 --> 00:32:06,140
remember it correctly,
is it logs

790
00:32:06,140 --> 00:32:07,210
everything that is happening.

791
00:32:07,210 --> 00:32:08,480
And then it replays it.

792
00:32:08,480 --> 00:32:12,800
And while replaying, you can
assess the performance of the

793
00:32:12,800 --> 00:32:15,430
instructions that were made.

794
00:32:15,430 --> 00:32:16,990
So basic idea.

795
00:32:16,990 --> 00:32:19,500
CHRIS LORD: I think we do
actually, I remember now, on

796
00:32:19,500 --> 00:32:20,490
the [INAUDIBLE]

797
00:32:20,490 --> 00:32:24,760
last year, we have a similar
tool for recording GPU

798
00:32:24,760 --> 00:32:26,080
behavior and then
playing it back.

799
00:32:26,080 --> 00:32:29,550
But I can't tell you
anything about it.

800
00:32:29,550 --> 00:32:31,620
I've just forgotten, and
it's not finished.

801
00:32:31,620 --> 00:32:34,230
So I think that sounds
really cool.

802
00:32:34,230 --> 00:32:37,090
You're definitely well
ahead there.

803
00:32:37,090 --> 00:32:39,070
ROWAN BEENJE: And I think the
Chrome dev tools are just

804
00:32:39,070 --> 00:32:41,170
starting to expose the
amounts of GP memory

805
00:32:41,170 --> 00:32:42,530
used, is that correct?

806
00:32:42,530 --> 00:32:43,450
That's coming up?

807
00:32:43,450 --> 00:32:44,480
PAVEL FELDMAN: Not yet.

808
00:32:44,480 --> 00:32:45,240
ROWAN BEENJE: But it's coming?

809
00:32:45,240 --> 00:32:46,130
PAVEL FELDMAN: It's
coming, yes.

810
00:32:46,130 --> 00:32:47,050
ROWAN BEENJE: Very soon.

811
00:32:47,050 --> 00:32:50,030
PAVEL FELDMAN: So native memory
instrumentation started

812
00:32:50,030 --> 00:32:51,680
with the renderer.

813
00:32:51,680 --> 00:32:56,310
And the GPU for us is outside
of the renderer.

814
00:32:56,310 --> 00:32:57,430
CHRIS LORD: I'm not sure if--

815
00:32:57,430 --> 00:33:00,970
like, we have, if you go to
About Memory in Firefox,

816
00:33:00,970 --> 00:33:02,960
you'll see lots of details
about where your memory's

817
00:33:02,960 --> 00:33:03,980
being used.

818
00:33:03,980 --> 00:33:07,260
I'm not sure if that goes
to GPU memory, though.

819
00:33:07,260 --> 00:33:08,210
That also works--

820
00:33:08,210 --> 00:33:10,110
I think it works, it should
work-- on mobile.

821
00:33:10,110 --> 00:33:13,140

822
00:33:13,140 --> 00:33:13,310
MATT DELANEY: Great.

823
00:33:13,310 --> 00:33:14,510
So that's quite a bit
about the tooling.

824
00:33:14,510 --> 00:33:17,240
So how about we move over to
the next question, which is

825
00:33:17,240 --> 00:33:19,140
related and kind of touched on a
bit in the beginning of this

826
00:33:19,140 --> 00:33:22,860
one, was, how do you guys feel
about frame developers and

827
00:33:22,860 --> 00:33:25,470
their understanding of which
performance metrics they

828
00:33:25,470 --> 00:33:27,895
should actually be looking
at these days?

829
00:33:27,895 --> 00:33:31,360
Say both, of course on a
desktop, but more importantly

830
00:33:31,360 --> 00:33:33,055
mobile, the more constrained
environment.

831
00:33:33,055 --> 00:33:35,260
Should they be looking,
rendering,

832
00:33:35,260 --> 00:33:37,470
compositing, layout?

833
00:33:37,470 --> 00:33:38,720
How should they be used
in the tools?

834
00:33:38,720 --> 00:33:42,230

835
00:33:42,230 --> 00:33:44,570
CHRIS LORD: I guess there
aren't too many.

836
00:33:44,570 --> 00:33:48,600
We've not done as good a job
as we should have, in that

837
00:33:48,600 --> 00:33:51,410
there aren't tools to measure
certain things that you'd

838
00:33:51,410 --> 00:33:52,350
really want to know.

839
00:33:52,350 --> 00:33:56,340
Or at least, the tools are
things like, oh, just use an

840
00:33:56,340 --> 00:34:00,010
HDMI video capture unit and do
frame analysis, which is

841
00:34:00,010 --> 00:34:03,530
obviously not feasible for
most people, I would say.

842
00:34:03,530 --> 00:34:07,400

843
00:34:07,400 --> 00:34:09,620
PAVEL FELDMAN: Can we turn that
to the audience, and may

844
00:34:09,620 --> 00:34:12,940
I ask, how many of you have
experienced issues,

845
00:34:12,940 --> 00:34:16,659
challenges, profiling, fighting
for rendering

846
00:34:16,659 --> 00:34:17,370
performance?

847
00:34:17,370 --> 00:34:18,850
If you could raise your hand.

848
00:34:18,850 --> 00:34:21,719
Rendering performance?

849
00:34:21,719 --> 00:34:22,310
OK.

850
00:34:22,310 --> 00:34:27,040
And how many of you were
using timeline to

851
00:34:27,040 --> 00:34:29,670
capture what's happening?

852
00:34:29,670 --> 00:34:32,409
OK, so it's pretty much
half of [? us. ?]

853
00:34:32,409 --> 00:34:33,969
So that's your answer.

854
00:34:33,969 --> 00:34:39,580
So half of us realize what needs
to be done tooling wise.

855
00:34:39,580 --> 00:34:42,905

856
00:34:42,905 --> 00:34:44,155
AUDIENCE: [INAUDIBLE].

857
00:34:44,155 --> 00:34:48,130

858
00:34:48,130 --> 00:34:51,219
So how would it help me
in a web view iOS?

859
00:34:51,219 --> 00:34:53,770
It's great that we have all
these tools in our browsers,

860
00:34:53,770 --> 00:34:55,830
but a lot of performance
of HTML5 is

861
00:34:55,830 --> 00:34:57,200
in the closed platforms.

862
00:34:57,200 --> 00:35:00,060
So what can we do to get those
closed platforms to get the

863
00:35:00,060 --> 00:35:02,370
cool tools that we're
building?

864
00:35:02,370 --> 00:35:05,810
PAVEL FELDMAN: So those
platforms diverge, especially

865
00:35:05,810 --> 00:35:06,815
on the rendering front.

866
00:35:06,815 --> 00:35:08,820
It is truth.

867
00:35:08,820 --> 00:35:12,090
On the CPU front, though, they
are very much alike.

868
00:35:12,090 --> 00:35:14,940
So you have a good clue on
what's happening in iOS web

869
00:35:14,940 --> 00:35:19,800
view when looking at Chrome,
unless you enable threaded

870
00:35:19,800 --> 00:35:22,160
compositing or something
like that.

871
00:35:22,160 --> 00:35:25,570
And it often gives
you a good clue.

872
00:35:25,570 --> 00:35:28,860
And image decode time will
be proportional.

873
00:35:28,860 --> 00:35:32,730
Because what you're assessing
is basically the CPU and the

874
00:35:32,730 --> 00:35:35,260
architecture of what
you're running on.

875
00:35:35,260 --> 00:35:36,380
So you have some clue.

876
00:35:36,380 --> 00:35:38,450
You have some good
clue on that.

877
00:35:38,450 --> 00:35:41,530
But it is not precise.

878
00:35:41,530 --> 00:35:44,570
SHANE O'SULLIVAN: But also what
you should care about, I

879
00:35:44,570 --> 00:35:48,450
don't think should be what any
one tool gives you, or any one

880
00:35:48,450 --> 00:35:49,240
performance metric--

881
00:35:49,240 --> 00:35:52,220
I mean, performance is
not a goal in itself.

882
00:35:52,220 --> 00:35:55,670
Performance should be there to
get you to increase whatever

883
00:35:55,670 --> 00:35:57,510
metric matters to you.

884
00:35:57,510 --> 00:35:59,780
So for example, in Facebook,
the reason we care so much

885
00:35:59,780 --> 00:36:03,120
about scrolling is that we did
a test where we artificially

886
00:36:03,120 --> 00:36:06,500
introduced for some small
number of people, 20, 30

887
00:36:06,500 --> 00:36:10,110
million or something, where
we said, we'll have your

888
00:36:10,110 --> 00:36:13,650
scrolling framework on Android
and iOS, just artificially.

889
00:36:13,650 --> 00:36:16,100
We know you can do 60
FPS on an iPhone 5.

890
00:36:16,100 --> 00:36:17,290
We will give you 30 FPS.

891
00:36:17,290 --> 00:36:19,080
And engagement collapsed.

892
00:36:19,080 --> 00:36:20,970
You would still get--

893
00:36:20,970 --> 00:36:22,380
we didn't introduce jerking,
we just slowed

894
00:36:22,380 --> 00:36:23,850
down the frame rate.

895
00:36:23,850 --> 00:36:25,130
And engagement dropped.

896
00:36:25,130 --> 00:36:28,280
So we said, OK, therefore,
scrolling matters to

897
00:36:28,280 --> 00:36:28,950
engagement.

898
00:36:28,950 --> 00:36:30,390
And engagement is
what matters.

899
00:36:30,390 --> 00:36:33,360
So if what you care about--

900
00:36:33,360 --> 00:36:34,980
test all the different
things for your app

901
00:36:34,980 --> 00:36:35,960
that actually matter.

902
00:36:35,960 --> 00:36:40,230
If speed, time to interaction
is what's important to you,

903
00:36:40,230 --> 00:36:41,330
emphasize for that.

904
00:36:41,330 --> 00:36:44,500
If scrolling is important to
you, and you do stuff like

905
00:36:44,500 --> 00:36:49,160
newsfeed, or any kind of image
heavy thing, then optimize for

906
00:36:49,160 --> 00:36:50,400
not resizing images.

907
00:36:50,400 --> 00:36:58,900
Optimize for not doing paint
reflows on complex content.

908
00:36:58,900 --> 00:37:01,192
If you really care about
TTI, do server render.

909
00:37:01,192 --> 00:37:02,490
It's faster.

910
00:37:02,490 --> 00:37:05,560
So try out 10 different
things.

911
00:37:05,560 --> 00:37:06,520
I know it's time consuming.

912
00:37:06,520 --> 00:37:09,440
But the metric you should
be looking at is

913
00:37:09,440 --> 00:37:10,640
what matters to you.

914
00:37:10,640 --> 00:37:13,440
Do you care that people look
at 50 photos in an hour?

915
00:37:13,440 --> 00:37:16,960
You're a photo app, fine,
optimize for that.

916
00:37:16,960 --> 00:37:19,360
So yeah, I don't think there's
any one sole [? rebuttal ?]

917
00:37:19,360 --> 00:37:20,226
for this stuff.

918
00:37:20,226 --> 00:37:21,880
PAVEL FELDMAN: So the same
happened to Chrome.

919
00:37:21,880 --> 00:37:23,800
We consider scrolling
very important.

920
00:37:23,800 --> 00:37:29,060
And there is actually a tooling
to detect regressions

921
00:37:29,060 --> 00:37:30,290
on that front.

922
00:37:30,290 --> 00:37:33,770
So there is a telemetry, the
remote control for Chrome.

923
00:37:33,770 --> 00:37:36,250
And the rendering team
is using it in

924
00:37:36,250 --> 00:37:36,930
the following matter.

925
00:37:36,930 --> 00:37:41,470
This tool can connect to remote
devices such as Android

926
00:37:41,470 --> 00:37:44,610
phones and Chrome OS and
desktops, different builds,

927
00:37:44,610 --> 00:37:45,630
different versions of builds.

928
00:37:45,630 --> 00:37:49,290
So it connects to those, runs
regression testing, uses

929
00:37:49,290 --> 00:37:53,250
timeline to get raw data back,
and builds the graphs.

930
00:37:53,250 --> 00:37:57,450
And any degrade in that graph
is a show stopper, and we

931
00:37:57,450 --> 00:37:58,640
change that.

932
00:37:58,640 --> 00:37:59,430
[? Regressions ?]

933
00:37:59,430 --> 00:38:00,600
gets rolled out [? of them. ?]

934
00:38:00,600 --> 00:38:04,070
So the same thing that happens
on the vendor front should be

935
00:38:04,070 --> 00:38:05,060
happening on that app front.

936
00:38:05,060 --> 00:38:06,790
And I'm sure it does.

937
00:38:06,790 --> 00:38:11,220
So the metric is scrolling
matches here.

938
00:38:11,220 --> 00:38:15,070
CHRIS LORD: I think, on a slight
tangent, there are some

939
00:38:15,070 --> 00:38:16,840
practical things that are worth

940
00:38:16,840 --> 00:38:20,520
knowing before you even--

941
00:38:20,520 --> 00:38:21,760
MATT DELANEY: 30 seconds.

942
00:38:21,760 --> 00:38:24,290
CHRIS LORD: While you're
making a site.

943
00:38:24,290 --> 00:38:26,000
You should take these things
into consideration.

944
00:38:26,000 --> 00:38:31,150
So it's worth knowing to some
extent what things cause new

945
00:38:31,150 --> 00:38:33,940
stacking context to be
created, for example.

946
00:38:33,940 --> 00:38:36,860
Because if you create a new
stacking context, likelihood

947
00:38:36,860 --> 00:38:38,880
is you're going to create
a new layer, as well.

948
00:38:38,880 --> 00:38:43,230
Not necessarily, but it's a
reasonable kind of rule of

949
00:38:43,230 --> 00:38:44,900
thumb to go by.

950
00:38:44,900 --> 00:38:47,720
Try and reduce the amount
of stacking context.

951
00:38:47,720 --> 00:38:55,650
Try to reduce the amount of, for
example, if you have text,

952
00:38:55,650 --> 00:38:57,920
not having it on a solid
background means that you're

953
00:38:57,920 --> 00:38:59,970
going to force alpha blending,
and you're going to force that

954
00:38:59,970 --> 00:39:01,650
text to be rendered twice.

955
00:39:01,650 --> 00:39:03,970
First optics or anti-aliasing,
maybe not on mobile.

956
00:39:03,970 --> 00:39:05,450
We'd probably just
use grayscale.

957
00:39:05,450 --> 00:39:08,870
But there are lots of little
things like this.

958
00:39:08,870 --> 00:39:12,970
Like if you're going to have
gradients in your backgrounds,

959
00:39:12,970 --> 00:39:15,770
CSS gradients, don't change
them all the time.

960
00:39:15,770 --> 00:39:19,330
Don't resize them if
you can help it.

961
00:39:19,330 --> 00:39:22,120
Try and avoid fixed
backgrounds.

962
00:39:22,120 --> 00:39:24,900
Because again, you're going to
force the foreground layers to

963
00:39:24,900 --> 00:39:28,460
have an alpha channel and force
blending and so on.

964
00:39:28,460 --> 00:39:30,805
Just sort of small tips that--

965
00:39:30,805 --> 00:39:34,090
MATT DELANEY: Lots of good
strategic advice there.

966
00:39:34,090 --> 00:39:35,400
Move on to the next
one here, sorry.

967
00:39:35,400 --> 00:39:38,030
So we've got a pretty
interesting question, I think,

968
00:39:38,030 --> 00:39:39,840
from James Ford.

969
00:39:39,840 --> 00:39:42,070
Kind of an age old question,
perhaps, but does using SVGs

970
00:39:42,070 --> 00:39:45,150
and font icons for graphics over
GIFs and PINGs have an

971
00:39:45,150 --> 00:39:47,975
impact on the performance
of a web page?

972
00:39:47,975 --> 00:39:50,560
How about more from your actual

973
00:39:50,560 --> 00:39:53,760
experience of using such?

974
00:39:53,760 --> 00:39:58,040
CHRIS LORD: I was going to say
recently, we switched SVG to

975
00:39:58,040 --> 00:40:01,980
rather than going from like a
single node in our display

976
00:40:01,980 --> 00:40:05,520
list to using all of our
display list nodes.

977
00:40:05,520 --> 00:40:12,190
So if you have an SVG that's
got like 1,000 different

978
00:40:12,190 --> 00:40:15,960
render nodes in it, then that
will be represented in our

979
00:40:15,960 --> 00:40:17,130
display list.

980
00:40:17,130 --> 00:40:19,150
And we have open bugs.

981
00:40:19,150 --> 00:40:20,910
This did cause performance
issues.

982
00:40:20,910 --> 00:40:23,060
Because as you scroll through
the page and you expose new

983
00:40:23,060 --> 00:40:27,790
areas of SVG, we have to iterate
that whole list, and

984
00:40:27,790 --> 00:40:30,200
render it and sort it into
layers, decide which bits have

985
00:40:30,200 --> 00:40:33,190
changed and which haven't
and so on.

986
00:40:33,190 --> 00:40:36,820
So yeah, SVGs are
going to be--

987
00:40:36,820 --> 00:40:38,040
you can cache them.

988
00:40:38,040 --> 00:40:40,970
But assuming that you're
using them for a reason

989
00:40:40,970 --> 00:40:41,910
and you're not just--

990
00:40:41,910 --> 00:40:45,980
I mean, if you weren't going
to plan on showing them at

991
00:40:45,980 --> 00:40:48,105
different sizes or a site.

992
00:40:48,105 --> 00:40:51,860

993
00:40:51,860 --> 00:40:53,910
Assuming that you are using
SVG for a reason and you

994
00:40:53,910 --> 00:40:56,930
couldn't have just used a static
image kind of thing,

995
00:40:56,930 --> 00:41:00,010
they are more expensive to use
than just static images.

996
00:41:00,010 --> 00:41:01,380
And the same with
fonts, as well.

997
00:41:01,380 --> 00:41:05,290
Fonts are quite expensive
to render.

998
00:41:05,290 --> 00:41:08,190
So the answer is
yeah, I guess.

999
00:41:08,190 --> 00:41:09,550
They're more expensive.

1000
00:41:09,550 --> 00:41:11,840
AUDIENCE: So maybe one example
that I found recently,

1001
00:41:11,840 --> 00:41:16,680
actually the Apple site uses
SVGs quite well and badly.

1002
00:41:16,680 --> 00:41:19,230
Well in the sense that they
use them everywhere, for

1003
00:41:19,230 --> 00:41:20,890
example for the logo
and all the rest.

1004
00:41:20,890 --> 00:41:23,930
But I think what a lot of people
miss is a complex SVG

1005
00:41:23,930 --> 00:41:29,260
with a lot of paths is actually
very expensive, even

1006
00:41:29,260 --> 00:41:30,570
in network bytes.

1007
00:41:30,570 --> 00:41:34,130
If you look at the complexity of
the SVGs that they use, you

1008
00:41:34,130 --> 00:41:37,610
can get like a 5x improvement if
you just save it as a PNG.

1009
00:41:37,610 --> 00:41:41,180
So it's retina friendly, which
is what Apple wants.

1010
00:41:41,180 --> 00:41:44,450
But it's actually worse off for
like render time of your

1011
00:41:44,450 --> 00:41:46,980
page and network performance.

1012
00:41:46,980 --> 00:41:48,735
CHRIS LORD: Yeah.

1013
00:41:48,735 --> 00:41:51,520
ROWAN BEENJE: Does anyone have
any comparative information

1014
00:41:51,520 --> 00:41:56,160
about icon fonts versus SVG?

1015
00:41:56,160 --> 00:41:57,190
PAVEL FELDMAN: We
need to measure.

1016
00:41:57,190 --> 00:41:59,050
And if we can't measure
it, we need to

1017
00:41:59,050 --> 00:42:00,740
make sure we can measure.

1018
00:42:00,740 --> 00:42:02,700
MATT DELANEY: [INAUDIBLE]

1019
00:42:02,700 --> 00:42:03,950
in the back?

1020
00:42:03,950 --> 00:42:11,030

1021
00:42:11,030 --> 00:42:12,280
Never mind.

1022
00:42:12,280 --> 00:42:17,410

1023
00:42:17,410 --> 00:42:18,660
No experience from
Facebook on this?

1024
00:42:18,660 --> 00:42:21,260

1025
00:42:21,260 --> 00:42:22,530
SHANE O'SULLIVAN: No experience
by me at Facebook

1026
00:42:22,530 --> 00:42:25,780
at the very least, no.

1027
00:42:25,780 --> 00:42:27,050
MATT DELANEY: All right, so
let's move on to the next

1028
00:42:27,050 --> 00:42:27,965
question then.

1029
00:42:27,965 --> 00:42:29,640
A little bit of time
here left.

1030
00:42:29,640 --> 00:42:32,458
How much on the clock?

1031
00:42:32,458 --> 00:42:33,950
15?

1032
00:42:33,950 --> 00:42:40,450
So kind of a bit of a loaded
question, but how can I find

1033
00:42:40,450 --> 00:42:43,970
which CSS rules and properties
are expensive to render on a

1034
00:42:43,970 --> 00:42:45,370
particular page?

1035
00:42:45,370 --> 00:42:49,920
Is a next question, a little
bit of clarification.

1036
00:42:49,920 --> 00:42:51,110
PAVEL FELDMAN: We are
working on that.

1037
00:42:51,110 --> 00:42:52,960
But it's a hard one.

1038
00:42:52,960 --> 00:42:56,910
You need to trace it all the way
from the CSS property to

1039
00:42:56,910 --> 00:43:00,290
the GL instruction or paint
instruction, Skia instruction.

1040
00:43:00,290 --> 00:43:02,810
And it's a long way to go.

1041
00:43:02,810 --> 00:43:05,250
There is a permanent solution,
though, that we've introduced

1042
00:43:05,250 --> 00:43:07,670
recently as an experiment.

1043
00:43:07,670 --> 00:43:11,550
We can now put browser into the
continuous repaint mode,

1044
00:43:11,550 --> 00:43:14,670
where it continuously repaints,
even if it doesn't

1045
00:43:14,670 --> 00:43:18,530
need to, and it shows you the
frame rate it can do it at.

1046
00:43:18,530 --> 00:43:23,380
And if you're not touching a
page, you can see that OK,

1047
00:43:23,380 --> 00:43:25,590
where it says number
of milliseconds,

1048
00:43:25,590 --> 00:43:26,990
it's paints per frame.

1049
00:43:26,990 --> 00:43:29,020
So it says, 3 milliseconds
per frame.

1050
00:43:29,020 --> 00:43:29,920
That's a good frame.

1051
00:43:29,920 --> 00:43:32,380
You'll achieve 60
FPS with that.

1052
00:43:32,380 --> 00:43:37,530
If it shows you 60, or 100
milliseconds, then you can go

1053
00:43:37,530 --> 00:43:38,630
and bisect your DOM.

1054
00:43:38,630 --> 00:43:40,930
So that's the best we can
offer at the moment.

1055
00:43:40,930 --> 00:43:43,710
You go through DOM,
you hide things.

1056
00:43:43,710 --> 00:43:45,530
It toggles visibility
to [INAUDIBLE].

1057
00:43:45,530 --> 00:43:47,620
And the number of milliseconds
reduce.

1058
00:43:47,620 --> 00:43:51,090
And then you figure out what
is the part that was

1059
00:43:51,090 --> 00:43:54,420
statically positioned, or had
a complex background, or had

1060
00:43:54,420 --> 00:43:57,340
some gradient whatsoever.

1061
00:43:57,340 --> 00:43:59,210
It's a manual process.

1062
00:43:59,210 --> 00:44:02,715
But it is already way
better than nothing.

1063
00:44:02,715 --> 00:44:06,170
SHANE O'SULLIVAN: Will this help
in the case where you're

1064
00:44:06,170 --> 00:44:08,520
showing and hiding things, but
let's say I modify something

1065
00:44:08,520 --> 00:44:11,140
that will trigger both a
repaint and a reflow.

1066
00:44:11,140 --> 00:44:14,400
Does this capture it
in that second?

1067
00:44:14,400 --> 00:44:16,970
PAVEL FELDMAN: So this one
is only about paint.

1068
00:44:16,970 --> 00:44:19,040
And paint meaning layout
does not change.

1069
00:44:19,040 --> 00:44:20,330
DOM does not change.

1070
00:44:20,330 --> 00:44:22,960
So it's only about CSS
and DOM that you have

1071
00:44:22,960 --> 00:44:25,190
presented on the screen.

1072
00:44:25,190 --> 00:44:26,720
For the rest of the
information,

1073
00:44:26,720 --> 00:44:29,030
you go to the timeline.

1074
00:44:29,030 --> 00:44:33,310
There are similar techniques
on figuring out the recalc

1075
00:44:33,310 --> 00:44:35,590
style or layout performance.

1076
00:44:35,590 --> 00:44:38,170
They often end up
with bisecting,

1077
00:44:38,170 --> 00:44:39,700
unfortunately, as well.

1078
00:44:39,700 --> 00:44:41,110
And we're working on
improving that.

1079
00:44:41,110 --> 00:44:43,792

1080
00:44:43,792 --> 00:44:46,830
SHANE O'SULLIVAN: Anything cool
coming up in Firefox?

1081
00:44:46,830 --> 00:44:49,460
CHRIS LORD: Not much
to add, really.

1082
00:44:49,460 --> 00:44:55,040
On mobile, I guess, it's worth
considering that certain pages

1083
00:44:55,040 --> 00:44:58,470
and complex pages, and on
certain mobile devices, it's

1084
00:44:58,470 --> 00:45:02,410
really not feasible to expect
the page to render very

1085
00:45:02,410 --> 00:45:07,310
quickly, as in within a
reasonable 60 hertz or 30

1086
00:45:07,310 --> 00:45:09,080
hertz time frame.

1087
00:45:09,080 --> 00:45:12,240
But we have asynchronous
compositing to counter that.

1088
00:45:12,240 --> 00:45:16,460
And what your goal then really
is to kind of do your work at

1089
00:45:16,460 --> 00:45:20,230
clever times, and partition it
in clever ways so that you

1090
00:45:20,230 --> 00:45:23,620
don't interrupt the asynchronous
compositing at

1091
00:45:23,620 --> 00:45:25,630
inopportune times,
or for too long.

1092
00:45:25,630 --> 00:45:31,318

1093
00:45:31,318 --> 00:45:32,690
MATT DELANEY: We're on to
the next question here.

1094
00:45:32,690 --> 00:45:36,930
So this is perhaps a little
bit redundant, but it's

1095
00:45:36,930 --> 00:45:38,640
interesting to get the
perspective real quick from

1096
00:45:38,640 --> 00:45:41,240
both the Chrome and
Firefox person.

1097
00:45:41,240 --> 00:45:45,430
So we use translateZ(0) to
trigger hardware rendering, as

1098
00:45:45,430 --> 00:45:46,560
people think.

1099
00:45:46,560 --> 00:45:48,350
Should we have an API to
explicitly do this?

1100
00:45:48,350 --> 00:45:51,670
So this is obviously
a bit tough.

1101
00:45:51,670 --> 00:45:53,800
And I think we can get some
audience input to this.

1102
00:45:53,800 --> 00:45:57,930
But should there be, perhaps in
general, any feedback from

1103
00:45:57,930 --> 00:46:03,680
the app side to get a little
bit of hopeful kick into

1104
00:46:03,680 --> 00:46:04,460
acceleration?

1105
00:46:04,460 --> 00:46:06,050
Because if people are using
this, and they're finding it

1106
00:46:06,050 --> 00:46:10,280
to good effect, is it something
that maybe we want

1107
00:46:10,280 --> 00:46:12,090
to make more real?

1108
00:46:12,090 --> 00:46:14,840
PAVEL FELDMAN: So I think Paul
and Alex have already covered

1109
00:46:14,840 --> 00:46:18,280
this one from the platform
perspective.

1110
00:46:18,280 --> 00:46:20,790
When you were talking to GC,
many things applied to this

1111
00:46:20,790 --> 00:46:22,040
thing as well.

1112
00:46:22,040 --> 00:46:24,150

1113
00:46:24,150 --> 00:46:24,510
CHRIS LORD: Yeah.

1114
00:46:24,510 --> 00:46:28,730
This has come up a few times,
really, like do we want apps

1115
00:46:28,730 --> 00:46:31,080
to be able to hint to
GC when to collect?

1116
00:46:31,080 --> 00:46:33,890
And do we want--

1117
00:46:33,890 --> 00:46:38,900
it's like every bit of control
that you add is kind of--

1118
00:46:38,900 --> 00:46:41,060
MATT DELANEY: From your work
on Android, have you found

1119
00:46:41,060 --> 00:46:42,580
times where it would've been
more useful for the app

1120
00:46:42,580 --> 00:46:46,440
developer to give you a hint
that they need that?

1121
00:46:46,440 --> 00:46:49,370
CHRIS LORD: Not really,
I guess.

1122
00:46:49,370 --> 00:46:51,770
I think really, we should
just be cleverer

1123
00:46:51,770 --> 00:46:53,680
about doing these things.

1124
00:46:53,680 --> 00:46:56,680
I think if you put that kind of
control into users' hands,

1125
00:46:56,680 --> 00:46:59,670
things are going to change too
much pretty quickly, to the

1126
00:46:59,670 --> 00:47:01,220
point where it would
just force bad

1127
00:47:01,220 --> 00:47:02,560
behavior in future versions.

1128
00:47:02,560 --> 00:47:06,390

1129
00:47:06,390 --> 00:47:07,820
SHANE O'SULLIVAN: From the point
of view of people who

1130
00:47:07,820 --> 00:47:11,430
write apps, yes, it
would be lovely.

1131
00:47:11,430 --> 00:47:13,620
I don't know if it's
feasible or not.

1132
00:47:13,620 --> 00:47:16,830
It's just that on the web, as
everybody knows, one of the

1133
00:47:16,830 --> 00:47:19,110
reasons we're sitting here right
now is that performance

1134
00:47:19,110 --> 00:47:21,060
is a problem.

1135
00:47:21,060 --> 00:47:24,340
And on some of the platforms,
you do have the option of

1136
00:47:24,340 --> 00:47:28,360
dropping down to a lower level
if you need to, and if you

1137
00:47:28,360 --> 00:47:29,600
have people who are
sufficiently good

1138
00:47:29,600 --> 00:47:31,680
enough to do so.

1139
00:47:31,680 --> 00:47:34,510
And I don't know if that's
feasible on the web.

1140
00:47:34,510 --> 00:47:36,020
It would be nice if it was.

1141
00:47:36,020 --> 00:47:37,590
I admit, things change
all the time.

1142
00:47:37,590 --> 00:47:39,680
We're constantly updating our
browsers, or even updating

1143
00:47:39,680 --> 00:47:40,790
them in the background now.

1144
00:47:40,790 --> 00:47:41,990
So things do change
all the time.

1145
00:47:41,990 --> 00:47:45,620
And even on iOS, things
change once a year.

1146
00:47:45,620 --> 00:47:48,460
So yes, it would probably
break everything.

1147
00:47:48,460 --> 00:47:56,630
But when you try to do smart
things in general, often

1148
00:47:56,630 --> 00:47:59,530
you're going to be missing
an edge case.

1149
00:47:59,530 --> 00:48:02,940
And an edge case could be 25%
of all implementations.

1150
00:48:02,940 --> 00:48:04,310
So I don't know.

1151
00:48:04,310 --> 00:48:06,510
If there was a way to drop down
lower and just say look,

1152
00:48:06,510 --> 00:48:09,610
I know what I'm doing, trust
me, it would be great.

1153
00:48:09,610 --> 00:48:12,930
Like I said, you can do it
on native platforms.

1154
00:48:12,930 --> 00:48:15,360
CHRIS LORD: I guess you've
got Canvas and WebGL.

1155
00:48:15,360 --> 00:48:17,854
You can do it like that.

1156
00:48:17,854 --> 00:48:19,104
SHANE O'SULLIVAN: True.

1157
00:48:19,104 --> 00:48:21,710

1158
00:48:21,710 --> 00:48:22,860
MATT DELANEY: Is there
maybe time for one

1159
00:48:22,860 --> 00:48:25,040
more question here?

1160
00:48:25,040 --> 00:48:29,220
So the question from Christina
Auckland, from Hampshire, is

1161
00:48:29,220 --> 00:48:31,840
there an overhead to using
media queries, especially

1162
00:48:31,840 --> 00:48:33,800
bubbling media queries in
your experience, guys?

1163
00:48:33,800 --> 00:48:37,090

1164
00:48:37,090 --> 00:48:39,130
PAVEL FELDMAN: I don't know.

1165
00:48:39,130 --> 00:48:40,700
CHRIS LORD: No idea.

1166
00:48:40,700 --> 00:48:42,500
SHANE O'SULLIVAN: Not a clue.

1167
00:48:42,500 --> 00:48:43,750
MATT DELANEY: Then one
more question.

1168
00:48:43,750 --> 00:48:48,560

1169
00:48:48,560 --> 00:48:49,610
Oh man.

1170
00:48:49,610 --> 00:48:50,860
Nope.

1171
00:48:50,860 --> 00:48:52,690

1172
00:48:52,690 --> 00:48:55,430
We talked about this question
for about five hours last

1173
00:48:55,430 --> 00:48:59,130
night, off and on, like
beating a dead horse.

1174
00:48:59,130 --> 00:49:02,800
Would it be possible to
accelerate reflows, hardware

1175
00:49:02,800 --> 00:49:03,720
accelerate?

1176
00:49:03,720 --> 00:49:06,470
So I think this question's a
bit confused into what it's

1177
00:49:06,470 --> 00:49:07,870
asking, perhaps.

1178
00:49:07,870 --> 00:49:09,760
But it did bring up some
interesting things last night.

1179
00:49:09,760 --> 00:49:12,820
So give you a moment to just
talk about what reflows are,

1180
00:49:12,820 --> 00:49:16,990
perhaps from you guys, and how
that may possibly be hardware

1181
00:49:16,990 --> 00:49:17,990
accelerated.

1182
00:49:17,990 --> 00:49:19,470
PAVEL FELDMAN: I think Google
is definitely hiring.

1183
00:49:19,470 --> 00:49:22,350
So if someone has some bright
ideas on that, they'd be

1184
00:49:22,350 --> 00:49:23,656
definitely interested.

1185
00:49:23,656 --> 00:49:26,230
CHRIS LORD: Ditto.

1186
00:49:26,230 --> 00:49:27,940
I guess, yeah, I think
the question

1187
00:49:27,940 --> 00:49:29,240
might be slightly confused.

1188
00:49:29,240 --> 00:49:33,630
So to kind of go to semi-fast
principles, I'm going to

1189
00:49:33,630 --> 00:49:37,885
assume that DOM tree is
something that we all know.

1190
00:49:37,885 --> 00:49:40,330
But browsers tend to, after you
get a DOM tree, it will

1191
00:49:40,330 --> 00:49:42,530
get passed into a frame tree,
which is a better

1192
00:49:42,530 --> 00:49:45,340
representation of how
it will get drawn.

1193
00:49:45,340 --> 00:49:48,310
And then the frame tree will get
processed, where it will

1194
00:49:48,310 --> 00:49:51,080
calculate where the position
and size of things are.

1195
00:49:51,080 --> 00:49:53,900
And that bit is the reflow.

1196
00:49:53,900 --> 00:49:56,930
So when you change something
that causes a size to change,

1197
00:49:56,930 --> 00:49:58,730
then reflow needs to happen.

1198
00:49:58,730 --> 00:50:00,960
Because the size of certain
elements will be dependent on

1199
00:50:00,960 --> 00:50:02,080
the other elements.

1200
00:50:02,080 --> 00:50:03,770
I say elements, that's
not quite true.

1201
00:50:03,770 --> 00:50:06,590
Because we're in the
frame tree now, but

1202
00:50:06,590 --> 00:50:08,540
for the most part.

1203
00:50:08,540 --> 00:50:12,070
So that's not something
you could put on--

1204
00:50:12,070 --> 00:50:13,900
I mean, you could put it
on the GPU, I guess.

1205
00:50:13,900 --> 00:50:16,220
But it'd be pretty pointless.

1206
00:50:16,220 --> 00:50:17,400
All of that is in
system memory.

1207
00:50:17,400 --> 00:50:20,740
So you'd be shoving that over
to GP memory, and writing a

1208
00:50:20,740 --> 00:50:25,430
really complex set of shaders,
I guess, to work on it.

1209
00:50:25,430 --> 00:50:27,820
And then shovel it back.

1210
00:50:27,820 --> 00:50:29,962
Basically, the answer is no.

1211
00:50:29,962 --> 00:50:34,040
But maybe there are some other
things that we're not

1212
00:50:34,040 --> 00:50:36,470
accelerating right now that we
could, which might be an

1213
00:50:36,470 --> 00:50:37,440
interesting question.

1214
00:50:37,440 --> 00:50:42,840
So from the frame tree, Firefox,
or Gecko rather, will

1215
00:50:42,840 --> 00:50:45,080
make a display list which
represents how it

1216
00:50:45,080 --> 00:50:46,160
would draw the page.

1217
00:50:46,160 --> 00:50:48,470
And then it processes the
display list to create the

1218
00:50:48,470 --> 00:50:49,200
layer tree.

1219
00:50:49,200 --> 00:50:52,580
And I think a similar process
happens in WebKit, possibly

1220
00:50:52,580 --> 00:50:55,030
minus display list or depending
on what fork you're

1221
00:50:55,030 --> 00:51:00,020
using, judging from the
conversation last night.

1222
00:51:00,020 --> 00:51:03,110
Are there other things that
we could accelerate, maybe

1223
00:51:03,110 --> 00:51:05,870
between those things or like
during that thing?

1224
00:51:05,870 --> 00:51:09,390
So for Firefox, most of
the rendering will

1225
00:51:09,390 --> 00:51:11,050
happen on your CPU.

1226
00:51:11,050 --> 00:51:14,700
Certain things will be hardware
accelerated, like

1227
00:51:14,700 --> 00:51:15,660
drawing a big image.

1228
00:51:15,660 --> 00:51:18,390
That might end up being uploaded
to the GPU and

1229
00:51:18,390 --> 00:51:20,740
scaled, for example,
in the GPU.

1230
00:51:20,740 --> 00:51:23,340
Or transforms happen on GPU.

1231
00:51:23,340 --> 00:51:24,790
Blending happens on the GPU.

1232
00:51:24,790 --> 00:51:26,350
But maybe there are other
things that could

1233
00:51:26,350 --> 00:51:27,360
happen on the GPU.

1234
00:51:27,360 --> 00:51:30,640
Like we don't draw gradients
on the GPU at the moment.

1235
00:51:30,640 --> 00:51:32,540
And gradients are a huge hit.

1236
00:51:32,540 --> 00:51:34,460
That's something we
could do, maybe.

1237
00:51:34,460 --> 00:51:36,020
And other elements as well.

1238
00:51:36,020 --> 00:51:39,750
There might be other element
types that would be able to

1239
00:51:39,750 --> 00:51:43,960
take advantage of hardware
accelerated rendering.

1240
00:51:43,960 --> 00:51:46,360
PAVEL FELDMAN: Another hint is
that if you're experiencing

1241
00:51:46,360 --> 00:51:50,060
really slowly, most likely you
are doing a total reflow.

1242
00:51:50,060 --> 00:51:53,110
And in WebKit, you are doing
total reflow if your layout

1243
00:51:53,110 --> 00:51:55,250
root is root of the document.

1244
00:51:55,250 --> 00:51:58,990
Which means in this very
message, you mutated two ports

1245
00:51:58,990 --> 00:52:01,720
of non-intersecting DOMs.

1246
00:52:01,720 --> 00:52:05,010
And they ended up being
the root layout.

1247
00:52:05,010 --> 00:52:09,530
So you figure out what
your layout root is.

1248
00:52:09,530 --> 00:52:12,580
There are simple rules to follow
to make your element

1249
00:52:12,580 --> 00:52:13,150
layout root.

1250
00:52:13,150 --> 00:52:15,140
And make sure you
don't screw it.

1251
00:52:15,140 --> 00:52:21,500

1252
00:52:21,500 --> 00:52:23,440
CHRIS LORD: I think we've kind
of mentioned this already.

1253
00:52:23,440 --> 00:52:28,580
But just in case, a lot of the
optimizations that happen on

1254
00:52:28,580 --> 00:52:33,110
the kind of rendering process
are to do with delaying tasks

1255
00:52:33,110 --> 00:52:34,170
and splitting them up.

1256
00:52:34,170 --> 00:52:39,860
So things like, if you can make
everything like a set

1257
00:52:39,860 --> 00:52:43,792
width and height, and never move
it, that would be great.

1258
00:52:43,792 --> 00:52:48,710
But if you do have need to
change something, like if you

1259
00:52:48,710 --> 00:52:52,800
change the width of something,
that is going to trigger a

1260
00:52:52,800 --> 00:52:55,310
reflow probably at some point.

1261
00:52:55,310 --> 00:52:58,900
But that point could be any time
between the time you do

1262
00:52:58,900 --> 00:53:00,410
it and the time that
the frame comes.

1263
00:53:00,410 --> 00:53:02,210
And stuff might happen
in between.

1264
00:53:02,210 --> 00:53:06,370
And if possible, we'll coalesce
these reflows.

1265
00:53:06,370 --> 00:53:08,540
On the other hand, if you change
a width, and then you

1266
00:53:08,540 --> 00:53:11,570
immediately read back the
width of an element that

1267
00:53:11,570 --> 00:53:14,570
depended on that width, you're
forcing that reflow to happen

1268
00:53:14,570 --> 00:53:15,740
immediately.

1269
00:53:15,740 --> 00:53:18,980
And then if you change something
after that, then

1270
00:53:18,980 --> 00:53:21,410
you've got a double
reflow situation.

1271
00:53:21,410 --> 00:53:26,240
So I guess an attempt to maybe
batch stuff is a sort of

1272
00:53:26,240 --> 00:53:27,922
general tip to avoid that.

1273
00:53:27,922 --> 00:53:32,090
PAVEL FELDMAN: Yeah, so to add
to that, we've often seen five

1274
00:53:32,090 --> 00:53:34,660
total reflows happen
within a frame.

1275
00:53:34,660 --> 00:53:36,500
So it's not that the
reflow is slow.

1276
00:53:36,500 --> 00:53:38,070
It's that it's continuously
happening

1277
00:53:38,070 --> 00:53:39,860
within the same message.

1278
00:53:39,860 --> 00:53:42,410
And we have good
tools for that.

1279
00:53:42,410 --> 00:53:45,320
We will show you all the
layouts, and we will show you

1280
00:53:45,320 --> 00:53:48,000
[INAUDIBLE] stacks that
invalidated re-layout, and

1281
00:53:48,000 --> 00:53:49,120
that forced it.

1282
00:53:49,120 --> 00:53:51,560
And you can see a continuous
invocation of

1283
00:53:51,560 --> 00:53:52,700
like five of them.

1284
00:53:52,700 --> 00:53:56,170
And you cut it into a single
one, and all of a sudden your

1285
00:53:56,170 --> 00:54:00,015
performance is OK again.

1286
00:54:00,015 --> 00:54:03,010
MATT DELANEY: So actually, real
final question here from

1287
00:54:03,010 --> 00:54:06,970
the audience is from Paul
Kinlan, he says, yes, does

1288
00:54:06,970 --> 00:54:09,560
scrolling performance in
client-side performance affect

1289
00:54:09,560 --> 00:54:11,620
the time on the site, balance
rate, et cetera?

1290
00:54:11,620 --> 00:54:12,940
And Shane was actually talking
about something pretty

1291
00:54:12,940 --> 00:54:16,120
interesting last night about
what he's seen from Facebook's

1292
00:54:16,120 --> 00:54:16,930
perspective.

1293
00:54:16,930 --> 00:54:19,000
SHANE O'SULLIVAN: Yeah, I kind
of mentioned it a bit earlier.

1294
00:54:19,000 --> 00:54:20,990
But yeah, it absolutely does.

1295
00:54:20,990 --> 00:54:24,910
What we find on Facebook is that
regardless of what you

1296
00:54:24,910 --> 00:54:27,260
do, people have kind of assigned
a certain amount of

1297
00:54:27,260 --> 00:54:29,830
time every day to spend
on the site.

1298
00:54:29,830 --> 00:54:35,740
And the more things that you can
get them to do within say,

1299
00:54:35,740 --> 00:54:37,330
they only spend 20
minutes a day.

1300
00:54:37,330 --> 00:54:41,580
And if you can show them twice
as many pages during that day,

1301
00:54:41,580 --> 00:54:43,510
then it will do twice
as many things.

1302
00:54:43,510 --> 00:54:48,560
The same goes for if people tend
to scroll down, we found

1303
00:54:48,560 --> 00:54:50,650
that when they scroll more,
they see more stories.

1304
00:54:50,650 --> 00:54:53,420
They click like more, they
comment on more things.

1305
00:54:53,420 --> 00:54:55,010
They see people's faces,
and the site

1306
00:54:55,010 --> 00:54:56,920
sends them more messages.

1307
00:54:56,920 --> 00:55:02,440
And when we did add friction
to scrolling, when we added

1308
00:55:02,440 --> 00:55:05,910
varying scroll rates, or when
we added consistently slow

1309
00:55:05,910 --> 00:55:09,505
scroll rates, as soon as we made
anything non-optimal when

1310
00:55:09,505 --> 00:55:13,200
it comes to scrolling, then
people often might stay on the

1311
00:55:13,200 --> 00:55:14,020
site as long.

1312
00:55:14,020 --> 00:55:15,330
So it didn't really affect
bounce rates.

1313
00:55:15,330 --> 00:55:19,910
But they would do far fewer
things, which is why we spend

1314
00:55:19,910 --> 00:55:23,100
so much time obsessing
about scroll rates.

1315
00:55:23,100 --> 00:55:27,590
So scroll rates directly affect
user engagement on

1316
00:55:27,590 --> 00:55:31,330
native, on wave,
on everything.

1317
00:55:31,330 --> 00:55:34,800
Which means our basic site,
which only serves HTML and

1318
00:55:34,800 --> 00:55:37,230
goes on to Nokia phones, gets
fantastic engagement if you

1319
00:55:37,230 --> 00:55:39,280
put it on an iPhone.

1320
00:55:39,280 --> 00:55:40,440
It's extremely fast.

1321
00:55:40,440 --> 00:55:41,050
It's tiny.

1322
00:55:41,050 --> 00:55:41,980
It looks ugly.

1323
00:55:41,980 --> 00:55:44,950
And people engage with it
really, really quickly.

1324
00:55:44,950 --> 00:55:45,640
And you know what?

1325
00:55:45,640 --> 00:55:47,760
It scrolls at 60 frames
per second.

1326
00:55:47,760 --> 00:55:49,010
Because there's no JavaScript.

1327
00:55:49,010 --> 00:55:51,860

1328
00:55:51,860 --> 00:55:54,895
Yeah, who knew?

1329
00:55:54,895 --> 00:55:56,145
MATT DELANEY: Any
last thoughts?

1330
00:55:56,145 --> 00:55:59,420

1331
00:55:59,420 --> 00:56:01,140
CHRIS LORD: Not really.

1332
00:56:01,140 --> 00:56:04,000
Maybe it'd be nice, like
we're talking a lot

1333
00:56:04,000 --> 00:56:04,830
about scrolling here.

1334
00:56:04,830 --> 00:56:06,710
It's obviously very important.

1335
00:56:06,710 --> 00:56:10,470
And scroll behavior differs
between basically every mobile

1336
00:56:10,470 --> 00:56:14,210
browser in quite big ways.

1337
00:56:14,210 --> 00:56:16,530
Maybe this is something we
should be, or should have been

1338
00:56:16,530 --> 00:56:20,350
collaborating on before.

1339
00:56:20,350 --> 00:56:22,920
Maybe there should be an API
for that, like some kind of

1340
00:56:22,920 --> 00:56:25,090
meta tag or something.

1341
00:56:25,090 --> 00:56:27,540
SHANE O'SULLIVAN: I heard Chrome
team were going to

1342
00:56:27,540 --> 00:56:31,240
start looking at scroll
performance as something to

1343
00:56:31,240 --> 00:56:33,550
instrument, or something
like that.

1344
00:56:33,550 --> 00:56:35,890
PAVEL FELDMAN: Yeah, so that
telemeter that I was talking

1345
00:56:35,890 --> 00:56:38,730
about is the regression testing
for the scrolling

1346
00:56:38,730 --> 00:56:39,220
performance.

1347
00:56:39,220 --> 00:56:42,720
And there is a huge scrolling
effort that, among other

1348
00:56:42,720 --> 00:56:47,850
things, moved the painting to
the impulse side, including

1349
00:56:47,850 --> 00:56:49,880
the image decode and resize.

1350
00:56:49,880 --> 00:56:53,480
And that's already available
on Chrome for Android now.

1351
00:56:53,480 --> 00:56:56,320
Yeah, it's already enabled
for Chrome for Android.

1352
00:56:56,320 --> 00:56:58,980
It's in the About Flags
on the desktop Chrome.

1353
00:56:58,980 --> 00:57:01,940
So you can take a
look at that.

1354
00:57:01,940 --> 00:57:04,040
CHRIS LORD: Sorry, and
one last thing I just

1355
00:57:04,040 --> 00:57:05,160
remembered as well.

1356
00:57:05,160 --> 00:57:09,850
In the Firefox built in profile,
we have a mode that

1357
00:57:09,850 --> 00:57:13,350
we call junk mode, the
like ticker box.

1358
00:57:13,350 --> 00:57:15,900
And then when you start the
profiler and you do some

1359
00:57:15,900 --> 00:57:19,180
stuff, and you stop it, it
will basically show you--

1360
00:57:19,180 --> 00:57:21,570
it will highlight on
the profile exactly

1361
00:57:21,570 --> 00:57:23,420
any hitches in panning.

1362
00:57:23,420 --> 00:57:27,090
So any frame that took longer
than 16 milliseconds or

1363
00:57:27,090 --> 00:57:28,300
whatever to draw.

1364
00:57:28,300 --> 00:57:31,440
You can drill down into just the
operations that were going

1365
00:57:31,440 --> 00:57:32,790
on during that frame.

1366
00:57:32,790 --> 00:57:36,930
And I think, no yeah,
I'm sure, that

1367
00:57:36,930 --> 00:57:41,550
profiler works over ADB.

1368
00:57:41,550 --> 00:57:44,660
So you can run it on your phone
and profile it on the

1369
00:57:44,660 --> 00:57:46,470
desktop, which is
pretty handy.

1370
00:57:46,470 --> 00:57:48,370
So just letting you know.

1371
00:57:48,370 --> 00:57:51,440

1372
00:57:51,440 --> 00:57:51,870
MATT DELANEY: So thanks.

1373
00:57:51,870 --> 00:57:53,300
That was Performance Channel.

1374
00:57:53,300 --> 00:57:58,278

