1
00:00:04,150 --> 00:00:06,970
>>Jorge Lucangeli Obes: Good morning, everyone,
and thanks for joining the session. My name

2
00:00:06,970 --> 00:00:11,799
is Jorge, and I work with the Chrome Security
team. Today I'll be talking about how to make

3
00:00:11,799 --> 00:00:17,039
Chrome apps and extensions be more secure.
And as the subtitle of the talk says, we want

4
00:00:17,039 --> 00:00:21,189
to focus on keeping the users of these apps
and extensions safe.

5
00:00:21,189 --> 00:00:27,250
Now, a lot of work has been done, not only
by Google, but by other browser vendors as

6
00:00:27,250 --> 00:00:33,050
well, to make browsers more secure.
What does this mean? It's harder now for a

7
00:00:33,050 --> 00:00:37,750
malicious Web site, any random Web site to
compromise a browser in a way in which it

8
00:00:37,750 --> 00:00:42,230
would allow the attacker to execute arbitrary
code in the user's device.

9
00:00:42,230 --> 00:00:48,350
However, in order to also protect the user's
data, the data that the user keeps in your

10
00:00:48,350 --> 00:00:54,540
Web app or Chrome app or Chrome extension,
we need the help of you, the developers. The

11
00:00:54,540 --> 00:00:58,980
browser by itself cannot completely protect
the user's data from attack.

12
00:00:58,980 --> 00:01:05,939
Now, the good news is that the Web platform
itself has been exposed to untrusted content

13
00:01:05,939 --> 00:01:11,210
or malicious content basically from the start.
That doesn't mean we're always scared about

14
00:01:11,210 --> 00:01:15,640
this malicious content, but we've made a lot
of progress integrating features that allow

15
00:01:15,640 --> 00:01:21,820
developers to make their Web apps more secure.
However, we haven't seen the level of adoption

16
00:01:21,820 --> 00:01:26,830
that we would have liked. And an objective
of the session is to tell you about these

17
00:01:26,830 --> 00:01:31,400
features so that you can use them and make
your applications more secure. The browser,

18
00:01:31,400 --> 00:01:36,830
together with the application developers,
will really make applications secure.

19
00:01:36,830 --> 00:01:43,830
Now, of course, a 45-minute long talk is not
enough to cover every single aspect of Web

20
00:01:45,090 --> 00:01:48,880
app security, so I'm going to focus on the
client side. I'm going to try to go over the

21
00:01:48,880 --> 00:01:54,210
features that can be leveraged both by regular
Web apps, by Chrome apps, Chrome extensions,

22
00:01:54,210 --> 00:02:00,640
even the ones that run offline.
Now, I talked about the Web platform and how

23
00:02:00,640 --> 00:02:05,330
we have incorporated features that help developers
make more secure Web apps. I'm going to focus

24
00:02:05,330 --> 00:02:10,640
on two of them which we believe, the security
community at large believe provide the best

25
00:02:10,640 --> 00:02:15,749
bang for the buck.
Number one, content security policy. If people

26
00:02:15,749 --> 00:02:22,150
here attended a talk on Wednesday about Manifest
Version 2 and Extensions Version 2, they probably

27
00:02:22,150 --> 00:02:27,349
have heard about CSP. And they probably also
have heard about HTML5 sandboxed iFrames.

28
00:02:27,349 --> 00:02:31,389
I'm going to talk about these two technologies
and show how you use them, common pitfalls

29
00:02:31,389 --> 00:02:38,079
that occur when you use them, so that you
can leave the talk and at least if you leave

30
00:02:38,079 --> 00:02:42,219
the talk and try to use some of these features
in your apps and extensions, I will be very,

31
00:02:42,219 --> 00:02:47,409
very happy indeed.
Now, before going in-depth into the features

32
00:02:47,409 --> 00:02:51,889
I want to take a couple of seconds to go over
the same origin policy real quick. The same

33
00:02:51,889 --> 00:02:58,889
origin policy is the basic security policy
that browsers and user agents try to get Web

34
00:03:00,499 --> 00:03:05,629
sites to comply to in the Web. And the same
origin policy basically says that two objects

35
00:03:05,629 --> 00:03:10,469
can interact directly if and only if they
belong to the same origin. An origin, which

36
00:03:10,469 --> 00:03:17,299
is taken from the URI of those subjects by
looking into the schema, the host and the

37
00:03:17,299 --> 00:03:21,989
port of that URI.
Now, the good thing about talking and reasoning

38
00:03:21,989 --> 00:03:27,510
about origins is that the most common security
vulnerabilities can be described in terms

39
00:03:27,510 --> 00:03:32,019
of origins. When untrusted content or script
gains the authority or runs in the context

40
00:03:32,019 --> 00:03:35,159
of a particular origin, we talk about cross-site
scripting.

41
00:03:35,159 --> 00:03:39,900
When a possibly malicious origin gets the
network access privileges, the Web request

42
00:03:39,900 --> 00:03:43,909
privileges of another origin, we talk about
cross-site request forgery. And for some reason

43
00:03:43,909 --> 00:03:47,969
which I don't understand, people really like
to say cross-site scripting with an X and

44
00:03:47,969 --> 00:03:51,199
cross-site request forgery with a C. I will
never get that.

45
00:03:51,199 --> 00:03:57,199
Now, a lot of the features that I'm going
to talk about today can be very easily implemented

46
00:03:57,199 --> 00:04:03,779
in an extensions manifest or a Chrome apps
manifest. But after helping many teams at

47
00:04:03,779 --> 00:04:08,989
Google write more secure apps and extensions,
either for Chrome or for Chrome OS, I notice

48
00:04:08,989 --> 00:04:14,319
that people made the same mistakes over and
over again not because they didn't know what

49
00:04:14,319 --> 00:04:20,049
they had to do, but because there's some tricky,
like, nuances that one has to know in order

50
00:04:20,049 --> 00:04:27,049
to make CSP or sandbox iFrames work correctly.
So I wrote a very simple app, which I call

51
00:04:27,949 --> 00:04:34,460
Manifest Lint. Not very creative, but that's
what I got. It will highlight sections of

52
00:04:34,460 --> 00:04:39,400
the manifest that are okay from a security
perspective and sections that might need help.

53
00:04:39,400 --> 00:04:43,900
In this case I am feeding the actual manifest
of the Manifest Lint application to itself

54
00:04:43,900 --> 00:04:47,879
and it's telling me that I'm not setting a
content security policy. Now, I will go deeper

55
00:04:47,879 --> 00:04:54,370
into content security policy in a couple of
slides.

56
00:04:54,370 --> 00:04:57,960
But first I want to show you what happens
when one develops an application and doesn't

57
00:04:57,960 --> 00:05:04,960
really take into account security.
Now, I wrote this application in time to demo

58
00:05:05,270 --> 00:05:12,270
it at I/O, and one could wonder what happens
if the application takes a manifest in that

59
00:05:13,400 --> 00:05:18,360
text area and displays the highlighted manifest
on the other side.

60
00:05:18,360 --> 00:05:24,199
Now, what happens if the application receives
a manifest that is not necessarily benign,

61
00:05:24,199 --> 00:05:30,960
that is malicious or malformed? Well, let's
try that. I'm going to switch video, and if

62
00:05:30,960 --> 00:05:35,330
I cannot make this demo work after what Sergey
did on Wednesday, I'm going to feel really,

63
00:05:35,330 --> 00:05:38,539
really bad.
[ Laughter ]

64
00:05:38,539 --> 00:05:45,539
>>Jorge Lucangeli Obes: Okay. Awesome.
Now, the extension &mdash; the app basically takes

65
00:05:48,970 --> 00:05:53,409
a manifest and displays it highlighted on
the other side. It also saves the manifests

66
00:05:53,409 --> 00:05:59,240
to local storage so that I can bring them
back and not have to input them all the time.

67
00:05:59,240 --> 00:06:06,240
Now, what happens if I input this manifest?
I hope &mdash; yeah, font size is okay.

68
00:06:07,210 --> 00:06:12,050
Which has a very weird description. It's got
HTML tags in its description and image tag

69
00:06:12,050 --> 00:06:19,050
and JavaScript. It's not looking good.
If I input this manifest into my extension,

70
00:06:23,409 --> 00:06:29,240
nothing will happen, but maybe eventually
the user might go over a part of the manifest

71
00:06:29,240 --> 00:06:35,250
and I hope it reads, but that's one of the
things that's stored in local storage.

72
00:06:35,250 --> 00:06:42,250
Now, we don't expect just random input to
be able to read local storage of the application.

73
00:06:43,669 --> 00:06:47,780
And in this case it's just manifest. It's
not really secret or private, but this could

74
00:06:47,780 --> 00:06:53,990
be user's data, private data, email, whatever,
anything that's stored in the app or the extensions

75
00:06:53,990 --> 00:07:00,990
origin is now available just one confusion,
one trick away from an attacker.

76
00:07:02,590 --> 00:07:09,590
I'm going to go back to the slides.
What's the problem? That's the problem. I'm

77
00:07:17,960 --> 00:07:24,960
using eval to parse JSON and I'm using inner
HTML to display the highlighted manifest.

78
00:07:26,300 --> 00:07:33,300
Now, I'm not going to go very deep into what
the exploit does, but it's basically using

79
00:07:34,499 --> 00:07:41,080
the fact that I'm using inner HTML to inject
script into the application that is triggered

80
00:07:41,080 --> 00:07:46,370
when the user mouses over the image.
Now, since I'm &mdash; since the use of inner HTML

81
00:07:46,370 --> 00:07:50,629
basically allows me to inject any sort of
tag or script that I want, that's basically

82
00:07:50,629 --> 00:07:56,779
giving a straight way for an attacker to get
malicious input into my application.

83
00:07:56,779 --> 00:08:00,819
And this is where content security policy
comes in.

84
00:08:00,819 --> 00:08:05,949
In a nutshell, content security policy is
a way for me, the application or extension

85
00:08:05,949 --> 00:08:12,949
developer, to tell the browser, only allow
me, the application, to load resources or

86
00:08:13,710 --> 00:08:20,680
script from this whitelist or trusted sources.
Now, it might be &mdash; might sound kind of weird

87
00:08:20,680 --> 00:08:26,449
since I'm telling the browser to restrict
what I'm &mdash; what me, the application, is allowed

88
00:08:26,449 --> 00:08:33,449
to do, but since we've seen in the demo that
it's very easy to hijack the behavior of an

89
00:08:33,880 --> 00:08:40,880
application, it's a very powerful tool, CSP,
and it allows me to &mdash; beforehand to say I

90
00:08:41,350 --> 00:08:48,150
don't want to be able to load anything outside
of these trusted sources.

91
00:08:48,150 --> 00:08:54,710
By doing this, by not allowing the application
to load script or resources from untrusted

92
00:08:54,710 --> 00:09:01,710
sources, we prevent most cross-site scripting
attacks; however, in order to be able to tell

93
00:09:04,200 --> 00:09:09,600
whether the script or the resource that we
are loading actually belongs in the whitelist

94
00:09:09,600 --> 00:09:15,470
or not, we need to be able to tell where that
script comes from. And the problem is that

95
00:09:15,470 --> 00:09:22,470
we are not always able to do that if the script
that we're loading is included in-line, in

96
00:09:23,320 --> 00:09:26,500
the application.
There's no way for the browser to tell whether

97
00:09:26,500 --> 00:09:33,500
inline script has been put there by the developer
or has been injected due to a bug in the application.

98
00:09:37,090 --> 00:09:42,320
The only way in which CSP can fulfill its
purpose and actually block things that are

99
00:09:42,320 --> 00:09:49,320
not in the whitelist is to ban all the uses
of inline script or features in JavaScript

100
00:09:49,700 --> 00:09:56,080
that turn strings into code because you can
never be sure whether the inline script was

101
00:09:56,080 --> 00:09:59,950
malicious or not or whether the string that's
been turned into code by eval is malicious

102
00:09:59,950 --> 00:10:04,210
or not.
Now, how do we use it? If you're writing Chrome

103
00:10:04,210 --> 00:10:10,760
app or in extension it's really, really simple.
You just add one line to the manifest called,

104
00:10:10,760 --> 00:10:16,100
very creatively, content security policy.
And a content security policy itself is just

105
00:10:16,100 --> 00:10:21,090
a list of allowed sources for different types
of resources.

106
00:10:21,090 --> 00:10:25,890
In this case what we're saying is that by
default the application is only allowed to

107
00:10:25,890 --> 00:10:32,890
load resources from its own origin. That's
what the, quote, self quote, token says.

108
00:10:33,490 --> 00:10:38,500
Now in case of scripts we want to allow the
application to load scripts from its own origin,

109
00:10:38,500 --> 00:10:45,500
the extension package, as well as the googleapis.com
site.

110
00:10:45,500 --> 00:10:52,500
And in case of styles, CSP does include a
token called unsafe inline, also with quotes.

111
00:10:53,840 --> 00:11:00,740
This can &mdash; this can be used to turn off the
requirement for a script not to be inline;

112
00:11:00,740 --> 00:11:05,880
however, if we use an unsafe inline token
in the script source line we're basically

113
00:11:05,880 --> 00:11:12,040
defeating the purpose of CSP. We are not gaining
any advantage.

114
00:11:12,040 --> 00:11:17,260
Styles are not the same thing in the sense
that they don't directly execute code.

115
00:11:17,260 --> 00:11:24,260
And in most cases it's the trade-off between
not being able to use inline style and the

116
00:11:24,310 --> 00:11:30,850
possible exposure to malicious CSS. And buggy
parsing CSS code in the browser is really

117
00:11:30,850 --> 00:11:35,200
not that problematic.
The most important thing in this case is we

118
00:11:35,200 --> 00:11:40,970
cannot load script from anywhere else but
those two sources.

119
00:11:40,970 --> 00:11:47,970
Now, if I try to load this, my application,
with this new manifest, I'm not going to do

120
00:11:48,100 --> 00:11:53,680
it in the computer because the text of a JavaScript
console is very hard to make bigger. So that's

121
00:11:53,680 --> 00:12:00,680
exactly what Chrome prints if I try to load
my existing application with this new manifest.

122
00:12:01,580 --> 00:12:06,430
And it's basically saying what we expected
it to say. If content security policy doesn't

123
00:12:06,430 --> 00:12:10,880
allow inline script, then, of course, Chrome
is refusing to run inline script. If content

124
00:12:10,880 --> 00:12:14,880
security policy doesn't allow in-line event
handling, which is basically the same as in-line

125
00:12:14,880 --> 00:12:19,710
script, it's JavaScript code that's included
in-line in HTML.

126
00:12:19,710 --> 00:12:24,080
And Chrome has complained about one more thing.
It complaining about the fact that I'm loading

127
00:12:24,080 --> 00:12:29,710
jQuery or HTTP.
Now, in a regular Web site this wouldn't necessarily

128
00:12:29,710 --> 00:12:34,010
be a problem since you're already loading
the Web site over HTTP. The fact that you're

129
00:12:34,010 --> 00:12:38,850
loading script over HTTP, it's really not
that problematic. However, if you're running

130
00:12:38,850 --> 00:12:44,060
on extensions, extensions get more privileged
access to the browser compared to regular

131
00:12:44,060 --> 00:12:48,000
sites. They have access to APIs. The normal
sites don't have access to.

132
00:12:48,000 --> 00:12:52,820
If you're leading script over HTTP, you're
exposed to what we call mine-in-the-middle

133
00:12:52,820 --> 00:12:59,660
attacks. If you're using your extension at
a Starbucks hot spot, then any person sitting

134
00:12:59,660 --> 00:13:06,220
at that Starbucks hot spot can intercept the
loading of that &mdash; that script loading over

135
00:13:06,220 --> 00:13:11,280
HTTP, change it and make you run malicious
script in the origin of your extension, which

136
00:13:11,280 --> 00:13:16,400
has privileged access to the browser's API.
And as we've seen, from there to stealing

137
00:13:16,400 --> 00:13:21,990
private data is just some code away.
Now, we need to change, of course, these few

138
00:13:21,990 --> 00:13:28,990
things in order to make my teeny-tiny application
work with CSP.

139
00:13:30,170 --> 00:13:36,450
That's basically what we're going to do.
I change the jQuery loading to load over HTTP,

140
00:13:36,450 --> 00:13:43,450
which is a source that I have enabled in CSP.
And I'm going to &mdash; I'm going to extract all

141
00:13:46,260 --> 00:13:51,470
my JavaScript code into a .js file, which
is something I should have done in the beginning.

142
00:13:51,470 --> 00:13:56,730
Best practices for Web development call for
separation of the structure of the document

143
00:13:56,730 --> 00:14:00,810
in HTTP, the behavior in JavaScript and the
style in CSS.

144
00:14:00,810 --> 00:14:06,450
This is the easy part. I also have to get
rid of inline event handling, which I can

145
00:14:06,450 --> 00:14:13,450
very easily translate to native JavaScript
using a bit of jQuery magic.

146
00:14:13,570 --> 00:14:20,570
I'm saying that the lint function is going
to be the handler of the link that I use to

147
00:14:20,890 --> 00:14:27,890
tell my application to process the manifest.
And finally, I have to change my eval function

148
00:14:28,100 --> 00:14:31,760
into JSON parse.
Now, I didn't use the fact that the application

149
00:14:31,760 --> 00:14:38,570
was using eval to run my exploit. I just used
the fact that it was running HTML; however,

150
00:14:38,570 --> 00:14:42,870
since the application was using eval to parse
JSON, instead of doing crazy things with tasks,

151
00:14:42,870 --> 00:14:47,990
I could just send a JavaScript statement as
a manifest.

152
00:14:47,990 --> 00:14:54,990
Now, that would have been slightly cheating
in my opinion because there needs to be at

153
00:14:57,470 --> 00:15:02,180
least an impression of, well, this could have
seemed like a regular manifest in order for

154
00:15:02,180 --> 00:15:07,570
the exploit chain to be somewhat credible.
If I'm just telling the user to paste something

155
00:15:07,570 --> 00:15:11,950
that starts with alert as a manifest, then
I'm kind of cheating.

156
00:15:11,950 --> 00:15:18,950
The good thing is that I'm not going to get
rid of inner HTML. And now we'll see why.

157
00:15:19,370 --> 00:15:26,370
I don't really need to get rid of inner HTML,
although it would be very good to do.

158
00:15:26,700 --> 00:15:33,700
What happens if I try to do the same thing?
Just so you see that I'm not faking it, I'm

159
00:15:34,680 --> 00:15:41,680
going to go back to the demo and I'm going
to try to load the same &mdash; it happens.

160
00:15:44,300 --> 00:15:51,300
We broke everything.
I'm going to use exactly the same manifest

161
00:15:56,500 --> 00:16:00,420
in the safe version of the application that
loads with the content security policy that

162
00:16:00,420 --> 00:16:07,420
you guys have seen. If I try to do that, it
will load, but if I mouse over the little

163
00:16:07,510 --> 00:16:14,510
square, which have the onload attribute, nothing
happens. And the console, which clearly you

164
00:16:14,600 --> 00:16:19,340
guys cannot read that, but it says "Refuse
to execute event handler because of content

165
00:16:19,340 --> 00:16:23,550
security policy." So I'm protected, which
is really cool.

166
00:16:23,550 --> 00:16:30,550
It's the same thing that is on the slide,
my demo failure slide.

167
00:16:32,970 --> 00:16:39,970
And the interesting thing is that the way
I see it, CSP allows the application or extension

168
00:16:41,610 --> 00:16:48,610
developer to rely on the browser as a safety
net. I'm pretty sure that I covered every

169
00:16:50,790 --> 00:16:57,790
single base, I'm pretty sure that I tied every
loose end, but just in case I haven't, please,

170
00:16:57,800 --> 00:17:01,290
you browser, make sure that I don't screw
up.

171
00:17:01,290 --> 00:17:05,949
This is what I'm talking about when I say
that application developers and browser developers

172
00:17:05,949 --> 00:17:09,030
have to work together in order to protect
users.

173
00:17:09,030 --> 00:17:15,189
The browser can make sure that your application
never uses unsafe script. You guys have to

174
00:17:15,189 --> 00:17:22,189
use the feature that the browser provides
in order to allow the browser to do this.

175
00:17:22,439 --> 00:17:28,490
Now, people might say, "Well, that's a really,
really simple app. It doesn't really do anything

176
00:17:28,490 --> 00:17:35,490
useful." And you might very well be right.
So I want to move over to something that's

177
00:17:35,640 --> 00:17:42,320
very dear to my heart, which is the Chrome
OS document viewer. We applied these two security

178
00:17:42,320 --> 00:17:46,710
features to the Chrome OS document viewer.
The Chrome OS document viewer allows Chrome

179
00:17:46,710 --> 00:17:53,710
OS users to open a lot of different document
types, including Office files, online on their

180
00:17:53,860 --> 00:17:57,840
Chrome OS devices directly from the Chrome
OS file manager.

181
00:17:57,840 --> 00:18:03,730
Everything runs on the Web/Chrome platform
and it runs offline.

182
00:18:03,730 --> 00:18:08,920
Now, when the developers of the development
viewer were working on the application, we

183
00:18:08,920 --> 00:18:15,110
wanted to make sure that it was a safe application.
Opening Office documents, it's dangerous,

184
00:18:15,110 --> 00:18:19,260
and we wanted to make sure that we could do
it in a safe way.

185
00:18:19,260 --> 00:18:25,150
So the first thing the developers did was
apply a content security policy to this app

186
00:18:25,150 --> 00:18:28,550
or extension.
In this case it's an app.

187
00:18:28,550 --> 00:18:34,440
It doesn't really change that much from what
I did with my demo app, but it's interesting

188
00:18:34,440 --> 00:18:39,270
that they are also using unsafe inline for
styles, and this makes a lot of sense because

189
00:18:39,270 --> 00:18:45,180
if you're writing a document viewer you cannot
really predict what kinds of crazy document

190
00:18:45,180 --> 00:18:49,390
formatting the author of those documents might
do.

191
00:18:49,390 --> 00:18:54,100
So you need to create script &mdash; sorry, styles
on the fly dynamically and load them inline.

192
00:18:54,100 --> 00:18:59,290
Now, in this case, again, this is a matter
of it's a trade-off between the functionality

193
00:18:59,290 --> 00:19:04,750
of the application, basic functionality of
the application, which is displaying the styles

194
00:19:04,750 --> 00:19:09,220
that are included in the document I want to
view, and security, which is I'm not really

195
00:19:09,220 --> 00:19:16,220
happy with loading inline CSS because it might
open me to be &mdash; to injection for malicious

196
00:19:16,830 --> 00:19:23,830
CSS, but we trust the CSS parser in Chrome.
If killing inline styles kills the purpose

197
00:19:24,750 --> 00:19:28,760
of a document viewer, then we need to allow
it. Security is always, most of the times,

198
00:19:28,760 --> 00:19:35,760
about tradeoffs.
Another interesting thing is that I'm using

199
00:19:36,990 --> 00:19:43,780
a couple more resource sources that I haven't
shown before, which are image source, which

200
00:19:43,780 --> 00:19:49,520
of course governs which images can be loaded
by the application. And I'm using blob URIs

201
00:19:49,520 --> 00:19:53,480
for images. I going to come back to blob URIs.
I wanted to show it today so it stays in your

202
00:19:53,480 --> 00:19:58,370
mind. I'm going to come back to blob URIs.
I'm also using frame source. Now content security

203
00:19:58,370 --> 00:20:03,460
policy includes more types of sources. There's
a bunch of them. I'm not going to go over

204
00:20:03,460 --> 00:20:08,430
them, but if you type content security policy
in Google it takes you directly to the list

205
00:20:08,430 --> 00:20:14,500
of it.
Now we come probably the crucial part of the

206
00:20:14,500 --> 00:20:21,500
talk. Which is &mdash; CSP is awesome, and it really
prevents cross-site scripting, but we haven't

207
00:20:21,670 --> 00:20:25,620
seen that much adoption by the development
community.

208
00:20:25,620 --> 00:20:32,620
So the only way we saw to make this really
happen was to force, to make a default CSP

209
00:20:34,750 --> 00:20:41,750
policy apply by default when absent extensions
start using Manifest V2. Now, if people here

210
00:20:43,309 --> 00:20:47,680
attended the talk on Wednesday about Manifest
V2, they probably have an idea of what the

211
00:20:47,680 --> 00:20:53,690
schedule will look like for Manifest V2. I'm
going to go over the schedule again, but let's

212
00:20:53,690 --> 00:20:59,100
see exactly what exactly is forced by Manifest
V2 in terms of CSP.

213
00:20:59,100 --> 00:21:04,280
The first line, script source self, object
source self, it's going to be the default,

214
00:21:04,280 --> 00:21:11,280
unchangeable, "unloosenable". CSP policy that's
going to be used in all (indiscernible) extensions

215
00:21:12,000 --> 00:21:18,030
that use Manifest V2. The reason for this
is the same that I've been talking about.

216
00:21:18,030 --> 00:21:24,530
If &mdash; if your upper extension loads inline
script, the browser cannot really tell whether

217
00:21:24,530 --> 00:21:29,770
the script that is executing comes from a
trusted source or not. The same thing happens

218
00:21:29,770 --> 00:21:36,770
with plug-ins. If we cannot &mdash; if you are
loading a plug-in over HTTP, and you run on

219
00:21:36,840 --> 00:21:41,590
public Wi-Fi, then the plug-in that you are
getting in your extension does not necessarily

220
00:21:41,590 --> 00:21:45,120
look like the plug-in that you thought you
were getting. It might have been changed in

221
00:21:45,120 --> 00:21:51,710
transit and you can have no way of telling.
Both scripts and plug-ins run code in the

222
00:21:51,710 --> 00:21:56,370
context of your extension. If we cannot be
sure that that code is trusted, we cannot

223
00:21:56,370 --> 00:21:58,950
give that code the privileges that the extension
has.

224
00:21:58,950 --> 00:22:05,950
So that's going to be the default. However,
in both cases, since we trust the resources

225
00:22:06,080 --> 00:22:13,080
that we load over HTTPS, it's allowed to include
HTTPS sources both as script source and as

226
00:22:13,260 --> 00:22:18,320
plug-in source. You can load plug-ins and
scripts over HTTPS because it's very much

227
00:22:18,320 --> 00:22:21,930
guaranteed that the scripts you're going to
get is the script that you actually want to

228
00:22:21,930 --> 00:22:26,690
get.
One more thing that you can do with CSP, which

229
00:22:26,690 --> 00:22:33,170
is interesting, is that when you write Chrome
apps and extensions, you use host permissions

230
00:22:33,170 --> 00:22:37,620
in order to govern which Web sites you can
inject content script into, but those same

231
00:22:37,620 --> 00:22:44,620
permissions govern which hosts you can do
XHR requests to. If you need to do XHR requests

232
00:22:45,670 --> 00:22:50,340
to a smaller number of hosts than what you
need to inject the script into, you can further

233
00:22:50,340 --> 00:22:57,059
restrict the hosts that you allow XHR requests
to happen against by using the connect source

234
00:22:57,059 --> 00:23:04,059
directly. It might seem like not a very big
deal, but security is always about restricting

235
00:23:04,260 --> 00:23:09,090
privilege, allowing things to have the least
amount of privilege possible so that if something

236
00:23:09,090 --> 00:23:16,059
goes wrong, a compromise happens, the thing
that gets compromised will never be able to

237
00:23:16,059 --> 00:23:20,250
do more than it was allowed to do in the beginning.
That's basically what we're trying to do with

238
00:23:20,250 --> 00:23:27,250
CSP. Now, this is basically how it's going
to happen with Manifest V2. Chrome 21, which

239
00:23:28,300 --> 00:23:34,550
goes to stable in mid August, it's going to
block uploading new items to the Chrome Web

240
00:23:34,550 --> 00:23:41,550
store that have Manifest V1. With Chrome 23
that goes stable in early November, even existing

241
00:23:43,480 --> 00:23:50,290
items that use Manifest Version 1 will not
be able to be updated to new version. And

242
00:23:50,290 --> 00:23:56,300
Chrome will stop packaging apps and extensions
that have Manifest V1.

243
00:23:56,300 --> 00:24:03,300
Now in the beginning of 2013, we will remove
Manifest Version 1 items from search results,

244
00:24:03,830 --> 00:24:10,830
so that they are very, very hard to find.
In the middle, beginning of Q2 of 2013, we

245
00:24:11,340 --> 00:24:17,690
will completely remove all Manifest V1 items
from the Chrome Web store and eventually Chrome

246
00:24:17,690 --> 00:24:24,690
will refuse to load them at all, whatsoever.
Now, it's almost a year from now, right, until

247
00:24:25,400 --> 00:24:32,400
it doesn't really work anymore and the changes
are not really that big. But the important

248
00:24:33,510 --> 00:24:37,530
thing is that this is the only way that we
can guarantee that your users and the users

249
00:24:37,530 --> 00:24:42,950
of Chrome browser and the Chrome extension
and the Chrome platform don't get compromised.

250
00:24:42,950 --> 00:24:49,059
It's not necessarily because the application
developer is writing a malicious app, but

251
00:24:49,059 --> 00:24:55,559
it's for the attacker to have a way in, you
just have to make one mistake. For &mdash; for

252
00:24:55,559 --> 00:25:01,670
the browser/app to win, you have to &mdash; you
have to tie every single loose end, so it's

253
00:25:01,670 --> 00:25:07,870
an uphill battle. But we have some tools that
help us win the battle and we really need

254
00:25:07,870 --> 00:25:14,010
you guys to start using these tools.
Now, the other good thing about CSP is that

255
00:25:14,010 --> 00:25:21,010
it's also available or in fact it came up
as a solution for the regular drive-by Web.

256
00:25:21,230 --> 00:25:25,960
It's currently supported in Firefox and Chrome
using the X content security policy in the

257
00:25:25,960 --> 00:25:32,960
case of Firefox and the X WebKit CSP in Chrome.
Eventually, we hope this will be supported

258
00:25:33,630 --> 00:25:40,630
in all browsers.
Now, there's some more issues that can come

259
00:25:47,179 --> 00:25:52,220
up with CSP. And I wanted to take a couple
of minutes to discuss them.

260
00:25:52,220 --> 00:25:59,220
An issue that we have seen a lot with CSP
is how we talked about how it completely balanced

261
00:25:59,890 --> 00:26:05,620
the use of eval because there's no way of
telling where that string that's being turned

262
00:26:05,620 --> 00:26:09,390
into code comes from. It's the same problem
as within inline script. The browser cannot

263
00:26:09,390 --> 00:26:14,920
be sure whether that script is actually something
the application developer wrote and not something

264
00:26:14,920 --> 00:26:21,050
that a malicious user wrote.
The problem is that many Web frameworks use

265
00:26:21,050 --> 00:26:26,860
eval to do templating, for example, and if
we ban eval, then these things are not going

266
00:26:26,860 --> 00:26:33,720
to work. And in effect, there's a very cool
starter kit for ember.js that basically brings

267
00:26:33,720 --> 00:26:40,720
up single-header (indiscernible) page using
the templating engine for ember.js which is

268
00:26:41,500 --> 00:26:45,500
handlebars.
Now if we use operate, very, very recently

269
00:26:45,500 --> 00:26:50,890
content security policy similar to the one
that we used before, we are allowing loading

270
00:26:50,890 --> 00:26:57,890
scripts over HTTPS, we are allowing inline
styles. This is basically what the ember.js

271
00:27:01,090 --> 00:27:08,090
&mdash; what the ember.js index &mdash; index HTML page
looks like. It's true we are allowing the

272
00:27:08,740 --> 00:27:13,720
loading of that script, everything else is
loading from the extensions on package. But

273
00:27:13,720 --> 00:27:18,600
if we try to load it, we get a very, very,
very nasty error which basically says something

274
00:27:18,600 --> 00:27:25,600
like code generation from scripts is disallowed
in this context. It also points us to a source

275
00:27:25,890 --> 00:27:32,890
file and a line, which basically says something
like function applies, something, something.

276
00:27:33,309 --> 00:27:39,360
This is never going to work with a CSP policy
that actually does work as intended. Now,

277
00:27:39,360 --> 00:27:46,360
there are two ways around this. Way number
one is for this frameworks to move away from

278
00:27:46,360 --> 00:27:53,360
eval and other code generation functions.
Now, if you are actually writing the new package

279
00:27:54,250 --> 00:28:00,820
apps and using Manifest Version 2 as we introduced
during I/O, there's another way of doing this,

280
00:28:00,820 --> 00:28:07,820
which is using new attribute for manifest,
which is called sandbox. Which I'm not going

281
00:28:08,950 --> 00:28:14,840
to go into specifically in the version that's
used in the manifest. I'm going to cover it

282
00:28:14,840 --> 00:28:21,840
more generally, so that it can be used also
in the drive-by Web.

283
00:28:22,500 --> 00:28:29,500
Before moving on to the next, to HTML5 sandbox
iFrames, a very big CSP don't, unsafe in-line

284
00:28:29,780 --> 00:28:34,860
and unsafe eval or script source, completely
defeat the purpose of CSP. Please don't do

285
00:28:34,860 --> 00:28:41,450
it. If you need to do this, you probably are
doing something not wrong, but you are doing

286
00:28:41,450 --> 00:28:47,100
something insecurely. So please think again.
If you need to include this in your CSP policy,

287
00:28:47,100 --> 00:28:51,230
then please, please, think about why you need
to do it.

288
00:28:51,230 --> 00:28:56,549
Now, the good thing about CSP is that it provides
a very effectively live place for resources,

289
00:28:56,549 --> 00:29:02,440
but it's not very granular. It's either you
are allowed to load this or you're not. What

290
00:29:02,440 --> 00:29:09,120
we would like to have is a way of maybe running
script in our application, but not giving

291
00:29:09,120 --> 00:29:14,250
that script access to the extensions or the
applications origin. It seems like there's

292
00:29:14,250 --> 00:29:18,380
nothing in between. It's either not running
at all or running and giving complete access

293
00:29:18,380 --> 00:29:25,000
to user's data and everything. That's where
HTML5 sandbox iFrames come from. What we would

294
00:29:25,000 --> 00:29:30,080
like to do is to load that script, execute
it, but execute it in a different origin than

295
00:29:30,080 --> 00:29:34,640
the actual application or extension origins.
In fact, let's go even further. We want to

296
00:29:34,640 --> 00:29:39,210
run it in an origin that's different from
any other origin out there. We call those

297
00:29:39,210 --> 00:29:45,360
unique origins. They are by definition different
from any other origin there is.

298
00:29:45,360 --> 00:29:52,360
This is where the HTML5 iFrame sandbox attribute
comes in. It allows loading resources, content

299
00:29:52,820 --> 00:29:59,820
or script safely inside an iFrame that will
get less privilege than a regular iFrame.

300
00:30:00,440 --> 00:30:04,750
And we can completely control which of these
privileges we give back and which ones we

301
00:30:04,750 --> 00:30:11,440
keep away from the iFrame.
Now, it's as simple as using the sandbox attribute

302
00:30:11,440 --> 00:30:18,440
on a regular iFrame. If we do that, the code
that we load inside the iFrame will be restricted

303
00:30:18,920 --> 00:30:24,340
in this way. It will live in a unique origin,
so we won't be able to access directly the

304
00:30:24,340 --> 00:30:31,280
application of the extensions, DOM structure
or script or anything. It actually &mdash; if we

305
00:30:31,280 --> 00:30:37,880
don't do anything else, it won't even be allowed
to run scripts at all. Or submit forms. Or

306
00:30:37,880 --> 00:30:44,440
navigate the top page. Or load plug-ins. Or
create pop-ups. Now, almost all of those things

307
00:30:44,440 --> 00:30:50,299
can be re-enabled individually by giving arguments
to the sandbox attribute. Except the loading

308
00:30:50,299 --> 00:30:57,299
of plug-ins, which so far cannot be re-enabled.
Now, I said that we might want to use sandbox

309
00:30:58,440 --> 00:31:05,440
iFrames to run script in a different origin.
So going back to the Chrome OS document viewer,

310
00:31:10,340 --> 00:31:17,340
what the document viewer developers did was
run most of the JavaScript that displayed

311
00:31:17,840 --> 00:31:24,840
the final document inside a sandbox iFrame.
And why did they do this? Well, even though

312
00:31:24,929 --> 00:31:30,500
we might be pretty confident about the JavaScript
that we wrote, if there's no need for that

313
00:31:30,500 --> 00:31:35,059
JavaScript to directly access all of the private
information that an application such as a

314
00:31:35,059 --> 00:31:40,840
document viewer might have, why give it that
privilege? If it doesn't need it? If anything

315
00:31:40,840 --> 00:31:45,530
goes wrong with the JavaScript that I wrote,
which if I'm parsing a document, as heavy

316
00:31:45,530 --> 00:31:50,010
as like a spreadsheet or something like that,
a lot of things can probably go wrong.

317
00:31:50,010 --> 00:31:56,280
So since that code doesn't need to access
every single file that I'm using in my document

318
00:31:56,280 --> 00:32:00,730
viewer, let's just not give it access to that.
Let's just give it the one file that it needs

319
00:32:00,730 --> 00:32:05,440
to display, so if anything goes wrong, it
cannot go and steal every single file that

320
00:32:05,440 --> 00:32:12,370
I own and ship it away to somewhere.
So that's what the document viewer developers

321
00:32:12,370 --> 00:32:17,870
did. They kept most of the document viewer
inside of a sandbox iFrame, which was only

322
00:32:17,870 --> 00:32:24,870
allowed to run script, and load pop-ups, but
nothing else, no forms, no plug-ins, nothing.

323
00:32:25,820 --> 00:32:31,580
In this way, if anything goes wrong with that
code, the JavaScript will not be able to access

324
00:32:31,580 --> 00:32:35,669
the extension or the apps origin where probably
the rest of the document, the user's documents

325
00:32:35,669 --> 00:32:42,669
live. And this is a very good thing.
Now, inside the sandboxed iFrame, there's

326
00:32:42,870 --> 00:32:48,850
really not that much that changes. This code
is basically loading a lot of JavaScript to

327
00:32:48,850 --> 00:32:52,940
do its job, to parse the document, and display
the document. But it looks like every other

328
00:32:52,940 --> 00:32:59,440
single web app that might be out there, except
for one teeny tiny detail, which comes from

329
00:32:59,440 --> 00:33:06,240
the fact that that JavaScript code lives inside
a unique origin. There's no way for the JavaScript

330
00:33:06,240 --> 00:33:10,160
code outside of the Sandbox and the JavaScript
code inside the sandbox to talk directly.

331
00:33:10,160 --> 00:33:17,160
They need to use some sort of inter-origin
API. And the most recent inter-origin API

332
00:33:17,780 --> 00:33:24,780
that they can use, of course, is postMessage.
It's explicitly designed to &mdash;
in a very JavaScript-y way, with asynchronous

333
00:33:35,340 --> 00:33:40,330
message handling.
Now, this is what &mdash; this is what &mdash; what

334
00:33:40,330 --> 00:33:47,330
message handling function might look for postMessage
in the drive-by Web. The thing is that it

335
00:33:47,500 --> 00:33:54,500
is for security reasons, it is good to check
if the message that I got over postMessage

336
00:33:54,650 --> 00:34:00,230
is being sent to me and that's what the event
origin tells me. When you post a message using

337
00:34:00,230 --> 00:34:07,230
postMessage, you say I'm intending this origin
to be the recipient. When you get the message

338
00:34:07,480 --> 00:34:14,480
you say, hey, was I the recipient? Is event.origin
the source that I expected? Since they live

339
00:34:17,239 --> 00:34:23,729
in unique origins, their origin is known,
so we cannot really use that to make sure

340
00:34:23,729 --> 00:34:30,729
that both sides of the postMessage interaction
are who they are. But still is the only way

341
00:34:30,799 --> 00:34:37,799
we have to talk to a sandboxed iFrame, so
we are going to have to use it anyways.

342
00:34:38,479 --> 00:34:43,970
Inside the iFrame, we just need to get our
parent window and postMessage to that. Outside

343
00:34:43,970 --> 00:34:48,819
the iFrame, we just need to actually find
the iFrame, get its content window and postMessage

344
00:34:48,819 --> 00:34:55,819
to that.
Now, again, the objective of sandboxed iFrames

345
00:34:57,180 --> 00:35:02,989
is to be able to use script that we might
not be comfortable with accessing our origin

346
00:35:02,989 --> 00:35:07,809
but we might need to use it to set up a particular
aspect of our application. In the case of

347
00:35:07,809 --> 00:35:12,619
the document viewer, the script was displaying
the final document to a user, but it had no

348
00:35:12,619 --> 00:35:19,619
need to access every single other document.
By running it in a unique origin, we guaranteed

349
00:35:20,539 --> 00:35:25,430
that even if anything that &mdash; anything that
went wrong, even if something that we didn't

350
00:35:25,430 --> 00:35:31,069
think could go wrong actually did go wrong,
there was no way for that code, even if it

351
00:35:31,069 --> 00:35:35,450
was compromised, to access any other document.
Which is a very good thing. You don't want

352
00:35:35,450 --> 00:35:42,009
one malformed document that you want it to
see to steal every other single document that

353
00:35:42,009 --> 00:35:48,890
you have.
A very &mdash; other very important thing, more

354
00:35:48,890 --> 00:35:55,890
don'ts. Security is filled with don'ts. If
we can both restrict the limitation of not

355
00:35:57,700 --> 00:36:03,009
running script and the limitation of running
in a unique origin, we can do it, we can do

356
00:36:03,009 --> 00:36:10,009
them both at the same time. However, if we
do them both at the same time, since the iFrame

357
00:36:10,440 --> 00:36:17,039
will be living in the same origin as the enclosing
page and JavaScript will be allowed to run

358
00:36:17,039 --> 00:36:22,269
inside the iFrame, there's nothing preventing
that JavaScript running inside the iFrame.

359
00:36:22,269 --> 00:36:26,650
To get a reference to the actual iFrame, since
it's living in the same origin, and just take

360
00:36:26,650 --> 00:36:33,650
the Sandbox out of it, out. So either never
use those two together, because again as with

361
00:36:34,989 --> 00:36:39,339
unsafe inline and unsafe eval, you are completing
defeating the purpose of the sandbox in the

362
00:36:39,339 --> 00:36:46,339
first place or make sure that the script that
you are including doesn't have code that can

363
00:36:48,099 --> 00:36:54,420
do this. You might not &mdash; it's &mdash; you might
not be sure that your script will not fail

364
00:36:54,420 --> 00:36:59,049
with a malformed office document, but you
can be sure that it's not actually searching

365
00:36:59,049 --> 00:37:04,470
for iFrames and removing sandbox attributes.
So sandbox iFrame don't. Please don't do this

366
00:37:04,470 --> 00:37:08,630
because it defeats the purpose and as many
people say, a false sense of security is even

367
00:37:08,630 --> 00:37:11,910
worse than being insecure. So please don't
do this.

368
00:37:11,910 --> 00:37:16,819
Now, I mentioned at the beginning of the talk
that I wanted to cover some common issues

369
00:37:16,819 --> 00:37:21,579
and pitfalls that came up when people tried
to do this in actual applications and I'm

370
00:37:21,579 --> 00:37:26,619
going to go over those real quick.
We talked about most the CSP restrictions,

371
00:37:26,619 --> 00:37:33,619
the really only really &mdash; the only actual
pain point that we found was the use of eval

372
00:37:36,190 --> 00:37:40,799
for templating (indiscernible) &mdash; everything
else, even if it takes some work, is just

373
00:37:40,799 --> 00:37:46,999
a matter of constructing script and constructing
event handling from HTML files. It shouldn't

374
00:37:46,999 --> 00:37:53,999
be impossible. We talked about how &mdash; about
how once we get stuff into a different origin

375
00:37:54,220 --> 00:37:59,210
so that it doesn't have access to the user's
data, we need to talk to it as if it were

376
00:37:59,210 --> 00:38:03,849
a different origin because it actually is,
so we need to use inter-origin communication

377
00:38:03,849 --> 00:38:10,569
mechanisms such as postMessage.
Now, I want to go over some weird interactions

378
00:38:10,569 --> 00:38:14,950
that can happen when you use both CSP and
sandboxed iFrames at the same time, which

379
00:38:14,950 --> 00:38:20,289
might not be evident when you start using
them, but it's good to know about them so

380
00:38:20,289 --> 00:38:23,619
that you can know what to do when they actually
show up, if you decide to use that, which

381
00:38:23,619 --> 00:38:30,279
you should.
This is what the final manifest for the Chrome

382
00:38:30,279 --> 00:38:35,089
OS document viewer roughly looks like. They
managed to implement both sandbox iFrames

383
00:38:35,089 --> 00:38:40,700
and CSP in document viewer app, which makes
it really secure. I'm very happy opening a

384
00:38:40,700 --> 00:38:46,559
file in &mdash; sorry &mdash; in the document viewer
because it means that the actual document

385
00:38:46,559 --> 00:38:51,849
that I'm viewing has almost no access to anything
else on my system and that's something that's

386
00:38:51,849 --> 00:38:56,779
very cool from a security standpoint, because
if anything goes wrong, there's nothing else

387
00:38:56,779 --> 00:39:03,609
that can be accessed. Nothing can be stolen.
Nothing can be affected, which is cool. What

388
00:39:03,609 --> 00:39:09,249
happens, the key thing to realize is that
once we get the sandbox iFrame inside a unique

389
00:39:09,249 --> 00:39:15,839
origin, when that iFrame tries to load resources
from the browser's perspective, it will look

390
00:39:15,839 --> 00:39:22,839
as if those requests came from outside the
extension. Because the iFrame is not going

391
00:39:23,259 --> 00:39:29,200
to be living in the extensions origin. Now,
with manifest V1, you were allowed to load

392
00:39:29,200 --> 00:39:36,200
everything you wanted from any origin. In
manifest V2, if an origin different from the

393
00:39:36,390 --> 00:39:40,150
extensions or the apps origin tries to load
a resource from the app, the browser will

394
00:39:40,150 --> 00:39:47,150
forbid that, and that's where Web access resources
come from. If we want to load from the session

395
00:39:48,460 --> 00:39:55,460
package, we need to list it in Web accessible
resources. And also, this also applies not

396
00:39:57,299 --> 00:40:04,299
only to the main Web accessible resources
line, it also applies to CSP. The things that

397
00:40:04,599 --> 00:40:11,599
we're loading inside the sandbox iFrame, those
requests will not look as if they came from

398
00:40:12,059 --> 00:40:18,450
the extension or the app. They will look as
if they came from a different origin. So CSP

399
00:40:18,450 --> 00:40:25,450
will not allow those requests to go forward
by matching the "self" token in the CSP line.

400
00:40:27,779 --> 00:40:34,779
It will actually need to match that to a different
line that will have Chrome extension URI as

401
00:40:34,819 --> 00:40:41,819
&mdash; the Chrome extension URI as its URI. Now,
if you are running the new package apps that

402
00:40:44,930 --> 00:40:50,759
come with the apps V2, that we introduced
for I/O, there's a slightly simpler way to

403
00:40:50,759 --> 00:40:55,769
do this, which I'm not going to have time
to explain that talk. But there was a talk

404
00:40:55,769 --> 00:41:01,349
on Wednesday that explained it in more depth,
and if anybody wants to learn about that,

405
00:41:01,349 --> 00:41:08,349
please feel free to find me after the talk.
But the core point to remember is that once

406
00:41:09,479 --> 00:41:14,479
we manage to get stuff into the sandbox iFrame,
it's running inside and encouraging, then

407
00:41:14,479 --> 00:41:19,920
it will have &mdash; it will live in origin for
everything, even for resource loading, and

408
00:41:19,920 --> 00:41:26,920
that might need to have us change some of
the CSP policies that we are using. And again,

409
00:41:28,670 --> 00:41:34,200
we're seeing that I'm using &mdash; or the document
viewer developers were URIs for images and

410
00:41:34,200 --> 00:41:39,809
the reason that that happens is that not only
we kept script in a different origin from

411
00:41:39,809 --> 00:41:45,219
our main application origin, we also put it
in a unique origin, which is slightly different

412
00:41:45,219 --> 00:41:51,400
than just a different origin. Unique origins
cannot access any persistent local storage.

413
00:41:51,400 --> 00:41:58,249
No HTML5 APIs, no persistent local storage.
Now, imagine if you're obligation developer

414
00:41:58,249 --> 00:42:05,079
and you had a great idea for a Chromized document
viewer, and you want to display documents

415
00:42:05,079 --> 00:42:10,279
that might have images inside them. These
images are probably encoded inside the documents

416
00:42:10,279 --> 00:42:17,279
in some way which we don't really care about,
but if you're not doing your processing, or

417
00:42:18,589 --> 00:42:24,950
some of your processing inside the sandbox
iFrame, you need a way to get that information

418
00:42:24,950 --> 00:42:30,849
inside the iFrame. You might be extracting
the images outside the iFrame, or even better,

419
00:42:30,849 --> 00:42:37,849
in a different iFrame. And you need a way
to provide that &mdash; to get that information

420
00:42:38,869 --> 00:42:44,650
inside the iFrame. Now, the only way you have
to actually communicate with the code inside

421
00:42:44,650 --> 00:42:49,759
the iFrame is by using post message. So you
might say, well, I'll have to take the binary

422
00:42:49,759 --> 00:42:55,539
data from the image, turn it into Base64,
ship it over using post message, decode it

423
00:42:55,539 --> 00:43:02,420
back to binary inside the iFrame. That works.
Not very performant. You have two Base64 to

424
00:43:02,420 --> 00:43:09,420
binary conversions that you don't really need,
and that's where typed arrays come in. JavaScript

425
00:43:11,210 --> 00:43:18,210
actually can deal perfectly well with binary
data. You just create an array buffer, the

426
00:43:18,289 --> 00:43:25,289
size you need in this case, 8 bytes, and then
you can cover that array buffer with different

427
00:43:25,380 --> 00:43:31,989
what we call views which allow you to manipulate
that array buffer using different data types.

428
00:43:31,989 --> 00:43:38,969
In this case we can manipulate it either as
an array of signed bytes or as an array of

429
00:43:38,969 --> 00:43:45,969
signed 32 bit, but the best way about &mdash; the
best thing array buffers is that they can

430
00:43:46,749 --> 00:43:53,749
very easily be turned into objects that can
be loaded in the browser. If the code outside

431
00:43:55,789 --> 00:44:01,450
the iFrame or inside a different iFrame sends
us an array buffer over post message, we can

432
00:44:01,450 --> 00:44:07,719
easily turn it into a blob, and then we can
create a URL &mdash; a URL from that blob that

433
00:44:07,719 --> 00:44:12,219
will look something like that. We don't really
care what it looks like. We really care about

434
00:44:12,219 --> 00:44:17,890
the fact that it can be used as a source for
all sorts of tasks. This is how the document

435
00:44:17,890 --> 00:44:24,890
viewer developers manage to do the parsing
of the documents in one sandbox, and displaying

436
00:44:26,400 --> 00:44:32,549
in the document in a different sandbox, passing
binary data back and forth using a very efficient

437
00:44:32,549 --> 00:44:39,549
mechanism that doesn't need any encoding whatsoever.
Not only that, once you get the blob URI inside

438
00:44:39,950 --> 00:44:46,329
the sandbox, you can use it all the times
you want. It's a way of getting a URI pointing

439
00:44:46,329 --> 00:44:53,329
directly to a chunk of bytes in the browser's
memory. This made possible to write a very

440
00:44:53,979 --> 00:44:59,390
secure document viewer app and still keep
all the functionality that one would expect

441
00:44:59,390 --> 00:45:06,390
from a document viewer.
Now, I mostly talked about JavaScript today.

442
00:45:08,920 --> 00:45:13,739
Good news is that the Chrome platform also
includes a way of getting all these same security

443
00:45:13,739 --> 00:45:20,739
guarantees for native code. There were a lot
of talks about (NaCl) Native Client, in I/O,

444
00:45:22,579 --> 00:45:29,579
your &mdash; you will probably find them, the videos
online after I/O ends. (NaCl) allows you to

445
00:45:30,559 --> 00:45:35,499
get all the same guaranties that we can give
for JavaScript code running inside a sandbox

446
00:45:35,499 --> 00:45:40,950
iFrame for native code, native C or C++ code.
And the best thing is that the communication

447
00:45:40,950 --> 00:45:46,650
with this sandbox code uses the same interface
that you can use to talk to JavaScript which

448
00:45:46,650 --> 00:45:52,190
is a post message based API. So you can get
the same guaranties that you can get with

449
00:45:52,190 --> 00:45:58,979
sandbox JavaScript, no access to the application's
origin, using the same API. Your JavaScript

450
00:45:58,979 --> 00:46:05,979
code can both talk to JavaScript or to native
code with the same security guaranties. Now,

451
00:46:06,960 --> 00:46:13,960
take aways, and we'll move into questions.
Please, please, please, use CSP. Please. Let

452
00:46:15,039 --> 00:46:22,039
Chrome, the browser, be the safety net. Just
make some very small changes, move scripts

453
00:46:23,559 --> 00:46:29,920
out of HTML, removing line handling &mdash; inline
handling and stop worrying. As long as you

454
00:46:29,920 --> 00:46:36,920
do stuff this way, the browser will take care
of not allowing malicious script to go through.

455
00:46:37,089 --> 00:46:43,509
This removes &mdash; this blocks most cases of
cross-site scripting. It does. Because a browser

456
00:46:43,509 --> 00:46:48,249
can make sure that this doesn't happen in
only one place. You have to make sure it doesn't

457
00:46:48,249 --> 00:46:52,849
happen in every single way &mdash; place you use
inner HTML or e-mail or server or everything.

458
00:46:52,849 --> 00:46:59,849
Let us let the browser help the app make sure
that this doesn't happen. And if you need

459
00:47:00,029 --> 00:47:05,539
to run script that you're not comfortable
with, you don't really want it to be able

460
00:47:05,539 --> 00:47:11,029
to access the application or the extension's
origin, put it in a sandbox iFrame. That's

461
00:47:11,029 --> 00:47:16,479
what they are for. It will run very happily,
talk over post message, but if anything goes

462
00:47:16,479 --> 00:47:22,559
wrong, it won't have any other privilege.
It won't be able to access anything in the

463
00:47:22,559 --> 00:47:26,039
extension of the app's origin. That's a good
thing.

464
00:47:26,039 --> 00:47:31,549
Thank you for joining the session.
[ Applause ]

465
00:47:31,549 --> 00:47:38,549
>>Jorge Lucangeli Obes: That's my e-mail.
My public Google+ account. The slides are

466
00:47:39,880 --> 00:47:45,890
going to be posted. I saw some people taking
pictures of the slides. Don't worry. And,

467
00:47:45,890 --> 00:47:51,739
yeah, we're open for questions. There's mics,
yeah. There's mics.

468
00:47:51,739 --> 00:47:57,450
>>> Hey, so good talk. My question is a bit
of a tangent, though. Have you guys seen very

469
00:47:57,450 --> 00:48:03,789
many actually malicious Chrome Apps or extensions?
>>Jorge Lucangeli Obes: We take out approximately

470
00:48:03,789 --> 00:48:10,630
a dozen malicious extensions either per day
or per week from the Chrome store, yes.

471
00:48:10,630 --> 00:48:15,640
>>> Okay. What kind of attack patterns do
they use in general, if can you tell us?

472
00:48:15,640 --> 00:48:20,349
>>Jorge Lucangeli Obes: No. It's probably
better to contact press, yes.

473
00:48:20,349 --> 00:48:25,769
>>> Okay. Okay. Fair enough. Thanks.
>>Jorge Lucangeli Obes: More questions?

474
00:48:25,769 --> 00:48:32,769
No more questions? Don't be shy.
>>> So what's wrong with attributes that have

475
00:48:38,289 --> 00:48:45,180
JavaScript code in them, if they're just in
the static source of the page, as opposed

476
00:48:45,180 --> 00:48:50,459
to being injected via inner HTML or the DOM
API?

477
00:48:50,459 --> 00:48:55,099
>>Jorge Lucangeli Obes: For the browser?
From the browser's perspective?

478
00:48:55,099 --> 00:49:02,099
There's no difference. So the browser &mdash; the
browser doesn't know that the &mdash; the on mouse-over

479
00:49:04,289 --> 00:49:10,099
script that I added in the first demo is actually
malicious. I want the browser to be able to

480
00:49:10,099 --> 00:49:16,259
&mdash; I would like the browser to be able to
block anything that got injected by inner

481
00:49:16,259 --> 00:49:23,259
HTML as opposed to stuff that got injected
&mdash; that got put there statically in the page.

482
00:49:24,829 --> 00:49:28,749
But there's &mdash; in reality, there's no way
of telling the difference. Once the DOM tree

483
00:49:28,749 --> 00:49:35,049
gets built, it's the same thing. Right?
The thing to include using inner HTML becomes

484
00:49:35,049 --> 00:49:40,900
part of the DOM tree just as everything else
you included statically in the page. So the

485
00:49:40,900 --> 00:49:47,869
browser cannot really tell the difference
between those two scripts. We can &mdash; if &mdash; we

486
00:49:47,869 --> 00:49:52,680
can discuss it after.
>>> Okay. Good idea.

487
00:49:52,680 --> 00:49:57,459
>>> This question is more related to your
talk. So you talk about using the X content

488
00:49:57,459 --> 00:50:04,459
security policy header in the talk. Recently
the IATF deprecated the X prefix for headers.

489
00:50:04,479 --> 00:50:09,469
Do you know if Google is like trying to move
toward standardizing what that header is?

490
00:50:09,469 --> 00:50:15,410
>>Jorge Lucangeli Obes: Eventually &mdash; no.
Eventually we want to standardize. I'm not

491
00:50:15,410 --> 00:50:22,410
exactly sure what the timeline is for that,
but there's definitely people you can ask

492
00:50:22,700 --> 00:50:25,759
that if you want to. I can tell who you can
ask.

493
00:50:25,759 --> 00:50:29,890
>>> Okay. Sure. Thanks.
>>Jorge Lucangeli Obes: Right there.

494
00:50:29,890 --> 00:50:35,079
>>> I'm curious if you know the status of
CSP support in browsers other than Chrome.

495
00:50:35,079 --> 00:50:41,229
>>Jorge Lucangeli Obes: I don't.
>>> Kind of a continuation from that: What's

496
00:50:41,229 --> 00:50:45,930
the status of this in the Android WebView?
>>Jorge Lucangeli Obes: That's a very good

497
00:50:45,930 --> 00:50:51,279
question that should be asked to Android developers.
Yeah.

498
00:50:51,279 --> 00:50:58,279
>>> Hey, sorry, look, I think a big raisin
for not allowing inline JavaScript is because

499
00:51:02,459 --> 00:51:09,119
you're basically assuming that it's all malicious
and you've got this policy to say if it's

500
00:51:09,119 --> 00:51:14,349
not &mdash; if any JavaScripts come from anywhere
else apart from where we said, malicious,

501
00:51:14,349 --> 00:51:20,400
right, even if it isn't. Is there much effort
going into actually determining whether JavaScript

502
00:51:20,400 --> 00:51:24,200
is malicious or not?
>>Jorge Lucangeli Obes: You probably run very,

503
00:51:24,200 --> 00:51:28,339
very quickly into, like, halting problem stuff,
right?

504
00:51:28,339 --> 00:51:33,700
That's basically the case. You cannot have
a way of telling what source code does that

505
00:51:33,700 --> 00:51:35,759
is 100% accurate so &mdash;
>>> Yeah.

506
00:51:35,759 --> 00:51:41,279
>>Jorge Lucangeli Obes: The only way to make
sure that &mdash; it goes back to the same thing:

507
00:51:41,279 --> 00:51:47,700
For an attacker to win, you just need one
bug, and in order for the rest of the people

508
00:51:47,700 --> 00:51:53,469
to win, you need to tie every single loose
end, and going down a path that basically

509
00:51:53,469 --> 00:51:58,819
has a lot of false positives and false negatives,
and very hard rules, it's just opening the

510
00:51:58,819 --> 00:52:04,759
door for not one bug, but a million bugs,
so we want to cut the problem from the root,

511
00:52:04,759 --> 00:52:11,759
and since it's perfectly okay, there's no
major differences except for evil, let's just

512
00:52:12,759 --> 00:52:17,549
do what's safe for the user. It's &mdash; it's
exactly the same. It's just &mdash; instead of

513
00:52:17,549 --> 00:52:23,479
having in HTML, do it in JavaScript, instead
of having it in code, do it in our .js files,

514
00:52:23,479 --> 00:52:27,589
and we can guaranty &mdash; we can guaranty, we
can say this is not going to is happen, ever,

515
00:52:27,589 --> 00:52:32,989
ever, ever. No exceptions.
>>> Well, unless your JavaScript on your server

516
00:52:32,989 --> 00:52:38,819
gets compromised. You can still be pulling
it in from trusted sources but it's been compromised

517
00:52:38,819 --> 00:52:40,069
anyway.
>>Jorge Lucangeli Obes: Well, exactly, but,

518
00:52:40,069 --> 00:52:45,049
I mean, since &mdash; it should &mdash; would have to
be compromised either in the Web site that

519
00:52:45,049 --> 00:52:51,269
is serving over HTTPS or in the actual expansion
package, which is a couple of orders of magnitude

520
00:52:51,269 --> 00:52:55,519
higher than just sitting at a Starbucks WiFi
and running something.

521
00:52:55,519 --> 00:52:59,900
>>> Which sort of gives rise to actually checking
whether the JavaScript itself is malicious.

522
00:52:59,900 --> 00:53:03,650
>>Jorge Lucangeli Obes: Yes.
>>> So you kind of need to do it eventually.

523
00:53:03,650 --> 00:53:05,130
>>Jorge Lucangeli Obes: But again, tradeoff,
right?

524
00:53:05,130 --> 00:53:08,660
>>> Yeah.
>>Jorge Lucangeli Obes: We can make sure that

525
00:53:08,660 --> 00:53:14,200
by &mdash; there were some stats &mdash; there was a
very interesting paper by a group &mdash; a research

526
00:53:14,200 --> 00:53:21,200
group at Berkeley that got published in the
beginning of 2012, by restricting inline JavaScript,

527
00:53:22,259 --> 00:53:29,259
and restricting HTTPS or HTTP script loading,
you could completely eliminate 95% of all

528
00:53:32,579 --> 00:53:39,579
the vulnerabilities in the top 100 extensions
in the Chrome Web store. Now, the tradeoff

529
00:53:39,839 --> 00:53:46,839
for that is incredibly good. It's just a couple
of simple changes that are still best practices

530
00:53:48,089 --> 00:53:51,420
for Web app development get rid of 95% of
the vulnerabilities.

531
00:53:51,420 --> 00:53:53,640
>>> Yeah.
>>Jorge Lucangeli Obes: It's like we need

532
00:53:53,640 --> 00:54:00,640
to do this. Guys, we need to do this. Guys
and girls, of course.

533
00:54:01,929 --> 00:54:04,019
>>> Can we get &mdash; sorry.
>>Jorge Lucangeli Obes: That's okay.

534
00:54:04,019 --> 00:54:07,509
>>> Can we get CSP to work in IE using Chrome
Frame, maybe?

535
00:54:07,509 --> 00:54:11,650
>>Jorge Lucangeli Obes: That's a very good
question to which I don't know the answer

536
00:54:11,650 --> 00:54:14,640
with, but I'm going find the answer because
it is a very good question.

537
00:54:14,640 --> 00:54:20,450
>>> I'm following you so post it.
>>Jorge Lucangeli Obes: Okay. I'll post it.

538
00:54:20,450 --> 00:54:21,999
Good.
>>> Great, thanks.

539
00:54:21,999 --> 00:54:28,059
>>> So you mentioned that because of blocks
eval, you know, blocks templating use cases,

540
00:54:28,059 --> 00:54:31,660
I think I did catch &mdash; so what's the alternative
do you do on something like client side templating?

541
00:54:31,660 --> 00:54:35,910
>>Jorge Lucangeli Obes: So the alternative
&mdash; two alternatives: Number one, try to make

542
00:54:35,910 --> 00:54:42,910
templating people more like from evil. Alternative
number two, if you are writing and one of

543
00:54:44,559 --> 00:54:49,319
the new package apps for the Chrome platform,
this doesn't work in the drive-by Web, just

544
00:54:49,319 --> 00:54:54,770
for the Chrome platform, you are able to say
in the manifest using the sandbox attribute

545
00:54:54,770 --> 00:55:01,770
&mdash; in the manifest, not in the iFrame, in
the manifest, you are able to say this document,

546
00:55:01,900 --> 00:55:07,680
when it's loaded inside an iFrame or in a
window, it should be put in something very

547
00:55:07,680 --> 00:55:14,680
similar to a sandbox iFrame; however, in this
new sandbox document, you cannot remove the

548
00:55:18,769 --> 00:55:23,559
same origin restriction. You cannot say, hey,
this has to live in the same origin. You cannot

549
00:55:23,559 --> 00:55:29,999
do that. Since we don't allow that in the
Chrome platform version of sandbox iFrames,

550
00:55:29,999 --> 00:55:35,589
we can't allow evil. What we don't want to
do is to say you can run evil and you can

551
00:55:35,589 --> 00:55:40,349
also remove the same origin restriction. So
if you do it through the manifest, you can

552
00:55:40,349 --> 00:55:46,710
apply a different kind of security policy
to that document you loaded inside the sandbox

553
00:55:46,710 --> 00:55:53,049
&mdash; sandbox which can never ever live in the
same origin as your application. If you want

554
00:55:53,049 --> 00:56:00,049
to go over the code, we can check it out outside.
But if you search for sandbox in the new version

555
00:56:00,410 --> 00:56:04,819
2 documentation, it's right there.
>>> Okay. Thank you.

556
00:56:04,819 --> 00:56:10,140
>>Jorge Lucangeli Obes: I think we are good
to go. Thank you.

557
00:56:10,140 --> 00:56:10,730
[ Applause ]

