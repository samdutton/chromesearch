1
00:00:00,000 --> 00:00:05,070

2
00:00:05,070 --> 00:00:05,820
LILLI THOMPSON: Hello.

3
00:00:05,820 --> 00:00:09,500
I'm Lilli Thompson, and this
is Console to Chrome, HTML5

4
00:00:09,500 --> 00:00:12,630
and JavaScript for
game developers.

5
00:00:12,630 --> 00:00:16,040
So first of all, just a little
bit of background on me.

6
00:00:16,040 --> 00:00:19,690
So I am an ex-console game
programmer that joined Google

7
00:00:19,690 --> 00:00:20,670
as a software engineer.

8
00:00:20,670 --> 00:00:22,790
And I did that for a couple of
years, nothing to do with

9
00:00:22,790 --> 00:00:26,070
graphics or game, just generic
software engineering.

10
00:00:26,070 --> 00:00:27,560
And then, I found that
I really missed game

11
00:00:27,560 --> 00:00:28,100
development.

12
00:00:28,100 --> 00:00:30,770
So I then joined the
Chrome team as a

13
00:00:30,770 --> 00:00:32,240
game developer advocate.

14
00:00:32,240 --> 00:00:35,210
And what that means is that what
I do now is that I work

15
00:00:35,210 --> 00:00:37,880
with game developers who are
working with technologies that

16
00:00:37,880 --> 00:00:39,840
are a priority for Chrome.

17
00:00:39,840 --> 00:00:42,610
And the big two for me
are HTML5 and WebGL.

18
00:00:42,610 --> 00:00:47,540
So that's what I do a lot of,
and that's why I'm here today.

19
00:00:47,540 --> 00:00:49,800
So first of all, an overview
of this talk.

20
00:00:49,800 --> 00:00:52,460
The thing you really need to
know is that this is a

21
00:00:52,460 --> 00:00:54,230
201-level talk.

22
00:00:54,230 --> 00:00:56,430
I'm not going to give
you the HTML5 pitch.

23
00:00:56,430 --> 00:00:58,530
And I'm not going to give you an
intro to game development.

24
00:00:58,530 --> 00:01:00,760
I'm going to assume that you're
a game developer type

25
00:01:00,760 --> 00:01:04,680
person that already knows that
they want to use HTML5.

26
00:01:04,680 --> 00:01:07,420
Maybe you've done a WebGL
tutorial and even rendered

27
00:01:07,420 --> 00:01:09,030
your first couple
of triangles.

28
00:01:09,030 --> 00:01:11,900
But now, there's a huge
knowledge gap between making a

29
00:01:11,900 --> 00:01:14,880
prototype and actually
making a scalable

30
00:01:14,880 --> 00:01:17,150
large-scale game engine.

31
00:01:17,150 --> 00:01:20,300
And so that's really what
I want to address today.

32
00:01:20,300 --> 00:01:22,800
And there are a couple of topics
that go into that.

33
00:01:22,800 --> 00:01:25,230
The first, I'll just have to
go really briefly over the

34
00:01:25,230 --> 00:01:26,030
HTML5 APIs.

35
00:01:26,030 --> 00:01:27,680
I'm not going to spend
a lot of time on it.

36
00:01:27,680 --> 00:01:30,550
But I want to make sure that
we're all on the same page.

37
00:01:30,550 --> 00:01:33,170
Then the real meat of the
issue for a lot of game

38
00:01:33,170 --> 00:01:34,890
developers is JavaScript.

39
00:01:34,890 --> 00:01:37,670
Just writing code at that
scale in JavaScript is

40
00:01:37,670 --> 00:01:39,400
something that a lot of console

41
00:01:39,400 --> 00:01:41,040
programmers struggle with.

42
00:01:41,040 --> 00:01:42,830
And so I'm going to spend a lot
of time there in talking

43
00:01:42,830 --> 00:01:44,640
about how to do that.

44
00:01:44,640 --> 00:01:48,240
And then finally, when you write
an HTML5 game, you're

45
00:01:48,240 --> 00:01:51,090
actually writing a game that
renders inside a much more

46
00:01:51,090 --> 00:01:54,430
complicated system of Chrome's
rendering system.

47
00:01:54,430 --> 00:01:57,220
And so there's all sorts of
things to know there.

48
00:01:57,220 --> 00:01:59,500
And if you really understand how
Chrome is set up, you can

49
00:01:59,500 --> 00:02:01,460
optimize your game and
make it run better.

50
00:02:01,460 --> 00:02:05,290
So those are the topics I'm
going to cover today.

51
00:02:05,290 --> 00:02:07,920
So there are two major
ways that people

52
00:02:07,920 --> 00:02:10,410
think about HTML5 games.

53
00:02:10,410 --> 00:02:12,940
The first is as a means
to get ubiquity.

54
00:02:12,940 --> 00:02:16,340
There's a whole class of people
who look at HTML5 as a

55
00:02:16,340 --> 00:02:19,430
way to write one code base and
run it in multiple places.

56
00:02:19,430 --> 00:02:23,060
So the dream is that every
phone, every tablet, every PC,

57
00:02:23,060 --> 00:02:24,700
every device has a browser.

58
00:02:24,700 --> 00:02:27,370
And if you can squish your
game into a browser, into

59
00:02:27,370 --> 00:02:30,190
HTML5, then that's great
for your maintenance.

60
00:02:30,190 --> 00:02:31,980
You have one code base, and
it's running everywhere.

61
00:02:31,980 --> 00:02:33,750
That's awesome.

62
00:02:33,750 --> 00:02:37,440
But that particular use of HTML5
comes with a certain set

63
00:02:37,440 --> 00:02:38,660
of constraints.

64
00:02:38,660 --> 00:02:41,550
So naturally, if you're really
targeting ubiquity, if that's

65
00:02:41,550 --> 00:02:44,250
your point, then you have to peg
the specification for your

66
00:02:44,250 --> 00:02:48,010
game to the lowest common
denominator, both in terms of

67
00:02:48,010 --> 00:02:50,780
what APIs you can use, because
you need APIs that are very

68
00:02:50,780 --> 00:02:54,000
broadly supported, and also in
terms of what you can demand

69
00:02:54,000 --> 00:02:55,870
out of the hardware because you
have to assume that you

70
00:02:55,870 --> 00:02:59,710
want to run just as well on a
phone as you do on a desktop.

71
00:02:59,710 --> 00:03:02,750
So anyway, very nice use of
HTML5, but then there's this

72
00:03:02,750 --> 00:03:05,380
other way people think about
it, which is as a way to do

73
00:03:05,380 --> 00:03:07,550
something awesome with
the browser.

74
00:03:07,550 --> 00:03:10,850
So there's a different set of
people who see the browser as

75
00:03:10,850 --> 00:03:14,200
a distribution platform for
their console-style games and

76
00:03:14,200 --> 00:03:17,560
are really excited by all the
great new potential that HTML5

77
00:03:17,560 --> 00:03:19,340
had added to the browser.

78
00:03:19,340 --> 00:03:21,240
And they really want to take
advantage of that.

79
00:03:21,240 --> 00:03:23,470
And there's a huge potential
there, making sharable,

80
00:03:23,470 --> 00:03:25,520
linkable, seamless
experiences.

81
00:03:25,520 --> 00:03:27,220
You can get so many
users that way.

82
00:03:27,220 --> 00:03:28,760
And it's so exciting.

83
00:03:28,760 --> 00:03:31,220
But as you can imagine, these
people who are really

84
00:03:31,220 --> 00:03:33,960
interested in being on the
leading edge, their goals are

85
00:03:33,960 --> 00:03:35,700
very different than the people
who are trying to

86
00:03:35,700 --> 00:03:37,970
do HTML5 for ubiquity.

87
00:03:37,970 --> 00:03:40,880
Because by virtue of being on
the bleeding edge, these

88
00:03:40,880 --> 00:03:43,140
things aren't going to be
supported everywhere.

89
00:03:43,140 --> 00:03:46,040
If you're making a game that's
a PC-style game that's really

90
00:03:46,040 --> 00:03:48,770
demanding, it's not going to run
on 10-year-old hardware.

91
00:03:48,770 --> 00:03:50,910
And that's OK for
this use case.

92
00:03:50,910 --> 00:03:54,310
So whenever you talk to people
about their opinions about

93
00:03:54,310 --> 00:03:56,490
HTML5 and what it's good for
and what it isn't good for,

94
00:03:56,490 --> 00:03:59,210
you should make sure you
understand which of these

95
00:03:59,210 --> 00:04:01,370
cases they're coming
at it from.

96
00:04:01,370 --> 00:04:03,700
And to be very clear here,
what I want to talk about

97
00:04:03,700 --> 00:04:06,480
today is the leading
edge of HTML5.

98
00:04:06,480 --> 00:04:09,660
I want to talk about credible
console-style experiences

99
00:04:09,660 --> 00:04:10,970
rendered in the browser.

100
00:04:10,970 --> 00:04:13,870

101
00:04:13,870 --> 00:04:17,079
So to begin talking about that,
we need to talk about

102
00:04:17,079 --> 00:04:18,959
HTML5 APIs, at least briefly.

103
00:04:18,959 --> 00:04:21,790
So the first one you're going
to need is WebGL.

104
00:04:21,790 --> 00:04:24,750
So WebGL is the way you do 3D
rendering in a browser.

105
00:04:24,750 --> 00:04:25,910
It's a lot like OpenGL.

106
00:04:25,910 --> 00:04:28,230
So if you're already an OpenGL
programmer, it's going to be

107
00:04:28,230 --> 00:04:31,120
pretty familiar to you,
except for it's

108
00:04:31,120 --> 00:04:33,330
actually OpenGL ES 2.0.

109
00:04:33,330 --> 00:04:36,430
It's the embedded systems
version of OpenGL.

110
00:04:36,430 --> 00:04:39,360
And what that means is that when
they made the embedded

111
00:04:39,360 --> 00:04:42,610
systems versions of the
specifications, they took out

112
00:04:42,610 --> 00:04:44,990
everything that was deemed to be
redundant in order to make

113
00:04:44,990 --> 00:04:47,670
it small and compact to
fit on mobile devices.

114
00:04:47,670 --> 00:04:51,050
But that means that a lot of
stuff is sort of removed.

115
00:04:51,050 --> 00:04:53,970
And the first thing you're going
to notice there is that

116
00:04:53,970 --> 00:04:55,310
fixed function lighting
is gone.

117
00:04:55,310 --> 00:04:57,790
So all your rendering in WebGL
is going to be done through

118
00:04:57,790 --> 00:04:59,200
programmable shaders.

119
00:04:59,200 --> 00:05:00,700
You're going to have to get
used to that if you're not

120
00:05:00,700 --> 00:05:02,470
used to that already.

121
00:05:02,470 --> 00:05:04,690
And besides that, there are a
bunch of other little things

122
00:05:04,690 --> 00:05:07,430
which, when I talk to game
developers about them, they're

123
00:05:07,430 --> 00:05:10,180
usually described as annoyances,
just random stuff

124
00:05:10,180 --> 00:05:12,130
that just is missing for
whatever reason in the

125
00:05:12,130 --> 00:05:13,010
specification.

126
00:05:13,010 --> 00:05:16,880
So for instance, depth buffer
access, texture compression is

127
00:05:16,880 --> 00:05:19,780
only available in a limited
form, instancing is missing,

128
00:05:19,780 --> 00:05:21,020
and so on, and so forth.

129
00:05:21,020 --> 00:05:22,560
So there are little
stumbling blocks.

130
00:05:22,560 --> 00:05:23,900
None of them are
deal breakers.

131
00:05:23,900 --> 00:05:26,770
You can still make a
high-quality, graphically

132
00:05:26,770 --> 00:05:27,960
impressive 3D game.

133
00:05:27,960 --> 00:05:29,020
But you're going to
have to know that

134
00:05:29,020 --> 00:05:31,740
these issues are there.

135
00:05:31,740 --> 00:05:34,360
And then, there's a different
class of things, which is a

136
00:05:34,360 --> 00:05:38,890
set of operations in OpenGL
ES that have a different

137
00:05:38,890 --> 00:05:41,360
performance profile than you
might expect in Chrome.

138
00:05:41,360 --> 00:05:43,700
So, for instance, anything that
starts with a "read,"

139
00:05:43,700 --> 00:05:46,140
anything that's starts with a
"get" and "glFinish," that

140
00:05:46,140 --> 00:05:48,140
kind of operation, they're
all going to be extra

141
00:05:48,140 --> 00:05:48,970
expensive in Chrome.

142
00:05:48,970 --> 00:05:50,290
They were always somewhat
expensive.

143
00:05:50,290 --> 00:05:52,050
Now they're going to be
really expensive.

144
00:05:52,050 --> 00:05:56,270
And when we get into talking
about how Chrome actually

145
00:05:56,270 --> 00:05:59,760
renders things, I'll be able
to explain why that is.

146
00:05:59,760 --> 00:06:04,240
But besides those performance
notes, the rest of the

147
00:06:04,240 --> 00:06:06,710
performance of WebGL is
actually pretty great.

148
00:06:06,710 --> 00:06:09,030
It's actually tremendously
impressive.

149
00:06:09,030 --> 00:06:11,080
It's really calling straight
through the hardware, so the

150
00:06:11,080 --> 00:06:13,550
performance of WebGL is very,
very similar to the

151
00:06:13,550 --> 00:06:15,260
performance of OpenGL.

152
00:06:15,260 --> 00:06:17,270
And you can get a
lot out of it.

153
00:06:17,270 --> 00:06:20,250
And the other thing to note is
that the specification is

154
00:06:20,250 --> 00:06:21,870
evolving very, very quickly.

155
00:06:21,870 --> 00:06:24,900
If you look at where WebGL was
a year ago versus where it is

156
00:06:24,900 --> 00:06:27,270
today, you're going to see
a lot of improvements.

157
00:06:27,270 --> 00:06:29,460
So especially, when you think
about all these little things

158
00:06:29,460 --> 00:06:31,890
that are either annoying, or
missing, or whatever, make

159
00:06:31,890 --> 00:06:34,390
sure you check back in with your
assumptions every three

160
00:06:34,390 --> 00:06:37,330
to six months because fixes very
well might have come into

161
00:06:37,330 --> 00:06:38,260
the specification.

162
00:06:38,260 --> 00:06:41,570
Or better still, go to the WebGL
mailing list and start

163
00:06:41,570 --> 00:06:44,200
talking about what it is you
need and want, because they're

164
00:06:44,200 --> 00:06:48,620
very responsive, and a lot of
changes are getting made.

165
00:06:48,620 --> 00:06:50,020
So you can render polygons.

166
00:06:50,020 --> 00:06:52,300
Next thing you need to do on
your way to a prototype is to

167
00:06:52,300 --> 00:06:54,560
be able to play some audio.

168
00:06:54,560 --> 00:06:58,100
HTML5 audio is a notorious
sticking point.

169
00:06:58,100 --> 00:07:01,560
Everyone in the HTML5 games
community has heard everybody

170
00:07:01,560 --> 00:07:04,710
else complain about how
painful audio is.

171
00:07:04,710 --> 00:07:07,550
And that's pretty true,
quite honestly.

172
00:07:07,550 --> 00:07:11,740
It's pretty safe to say that
audio in HTML5 is the most

173
00:07:11,740 --> 00:07:14,970
important, least standardized
thing.

174
00:07:14,970 --> 00:07:17,710
And so there actually is no
specification that's really

175
00:07:17,710 --> 00:07:19,740
suitable for this kind of game
that's going to work

176
00:07:19,740 --> 00:07:20,400
everywhere.

177
00:07:20,400 --> 00:07:22,960
So you're stuck falling back and
doing different things for

178
00:07:22,960 --> 00:07:23,670
different browsers.

179
00:07:23,670 --> 00:07:25,500
I wish it wasn't the case, but
that's sort of the world we

180
00:07:25,500 --> 00:07:26,710
live in today.

181
00:07:26,710 --> 00:07:29,440
Of all the specifications out
there, the one that I

182
00:07:29,440 --> 00:07:32,090
personally think is the best and
most suitable for games is

183
00:07:32,090 --> 00:07:34,810
the web audio API, which is
only in Chrome right now.

184
00:07:34,810 --> 00:07:37,290
And it offers just a lot
of features, sort of a

185
00:07:37,290 --> 00:07:40,590
graph-based audio processing
system, all kinds of

186
00:07:40,590 --> 00:07:42,920
out-of-the-box nodes and filters
you can just use.

187
00:07:42,920 --> 00:07:44,110
It's hardware accelerated.

188
00:07:44,110 --> 00:07:45,470
It's very accurate in
its timing, and

189
00:07:45,470 --> 00:07:46,500
so on, and so forth.

190
00:07:46,500 --> 00:07:49,100
So it will help you out.

191
00:07:49,100 --> 00:07:51,790
And then, there's so much more
that I just don't have time to

192
00:07:51,790 --> 00:07:52,500
get to today.

193
00:07:52,500 --> 00:07:55,570
There's all kinds of new APIs
being added to the HTML5

194
00:07:55,570 --> 00:07:58,190
standards all the time.

195
00:07:58,190 --> 00:08:00,560
Instead of trying to go over
them here, because I just

196
00:08:00,560 --> 00:08:02,860
don't have time, I'm going to
add a resources slide at the

197
00:08:02,860 --> 00:08:05,040
end where you can go and read
about any one of these

198
00:08:05,040 --> 00:08:06,150
particular things.

199
00:08:06,150 --> 00:08:07,720
There are also lots of
presentations that sort of

200
00:08:07,720 --> 00:08:09,610
catalog APIs for games.

201
00:08:09,610 --> 00:08:12,320
But suffice to say for the
moment, there are a lot of

202
00:08:12,320 --> 00:08:13,550
things that you should
look into.

203
00:08:13,550 --> 00:08:16,660
If these things don't look
familiar to you yet, then you

204
00:08:16,660 --> 00:08:20,290
should go look them up and see
if they're useful to you.

205
00:08:20,290 --> 00:08:22,180
And that's pretty
much for HTML5.

206
00:08:22,180 --> 00:08:24,060
Pretty much two things you need,
You need to be able to

207
00:08:24,060 --> 00:08:24,800
render triangles.

208
00:08:24,800 --> 00:08:26,870
You need to be able
to play sound.

209
00:08:26,870 --> 00:08:28,700
From there, you can
make a prototype.

210
00:08:28,700 --> 00:08:31,550
Once you've got a prototype, now
comes the hard part where

211
00:08:31,550 --> 00:08:33,159
you take prototype
to game engine.

212
00:08:33,159 --> 00:08:36,390
And that transition is all about
writing high-performance

213
00:08:36,390 --> 00:08:37,340
JavaScript.

214
00:08:37,340 --> 00:08:40,140
So that's what we're going
to talk about now.

215
00:08:40,140 --> 00:08:43,390
And before I get too deep into
it, a great big caveat that

216
00:08:43,390 --> 00:08:45,870
what I'm talking about
is JavaScript

217
00:08:45,870 --> 00:08:47,780
performance for Chrome.

218
00:08:47,780 --> 00:08:50,500
Every browser has its own
JavaScript engine, or there

219
00:08:50,500 --> 00:08:53,210
are many different JavaScript
implementations.

220
00:08:53,210 --> 00:08:55,330
And they're all going to have
different performance quirks.

221
00:08:55,330 --> 00:08:57,570
Certain operations are going to
be slow over here, and fast

222
00:08:57,570 --> 00:08:58,810
over there, and all that.

223
00:08:58,810 --> 00:09:01,100
So this presentation, I'm
going to try to give you

224
00:09:01,100 --> 00:09:02,530
general information.

225
00:09:02,530 --> 00:09:05,680
But this information has been
written in the context of V8

226
00:09:05,680 --> 00:09:08,580
and sort of confirmed with
the V8 team for accuracy.

227
00:09:08,580 --> 00:09:10,410
And I'm not trying to
or qualified to

228
00:09:10,410 --> 00:09:13,740
speak for other browsers.

229
00:09:13,740 --> 00:09:15,380
So let's talk JavaScript.

230
00:09:15,380 --> 00:09:18,620
JavaScript is a high-level
scripting language.

231
00:09:18,620 --> 00:09:21,250
And it's extremely permissive
in what it allows you to do,

232
00:09:21,250 --> 00:09:23,570
extremely squishy
in its syntax.

233
00:09:23,570 --> 00:09:24,730
It's typeless.

234
00:09:24,730 --> 00:09:25,650
It's kind of interpreted.

235
00:09:25,650 --> 00:09:27,280
It's just-in-time compiled.

236
00:09:27,280 --> 00:09:30,050
There's no explicit syntax
for memory management.

237
00:09:30,050 --> 00:09:33,990
And it's all running on a single
thread with some HTML5

238
00:09:33,990 --> 00:09:36,660
exceptions called web workers
which you should go look up if

239
00:09:36,660 --> 00:09:38,980
you don't know what
they are already.

240
00:09:38,980 --> 00:09:41,610
So the nice thing about
JavaScript is that it's great

241
00:09:41,610 --> 00:09:44,460
to have an application running
in JavaScript in front of your

242
00:09:44,460 --> 00:09:48,100
end users because it is great
at not falling down.

243
00:09:48,100 --> 00:09:51,280
JavaScript is great at eating
bad input and staying up.

244
00:09:51,280 --> 00:09:52,410
Nothing makes it crash.

245
00:09:52,410 --> 00:09:57,340
It's super effective at being
robust. The sort of dark side

246
00:09:57,340 --> 00:10:00,110
of that, though, is that because
JavaScript doesn't

247
00:10:00,110 --> 00:10:03,900
have a lot of structure of its
own and because it is really,

248
00:10:03,900 --> 00:10:06,270
really permissive in what it
allows you to do, and it never

249
00:10:06,270 --> 00:10:08,930
sort of spits errors at you,
that while you're developing,

250
00:10:08,930 --> 00:10:10,590
you're sort of stuck
in this Wild West

251
00:10:10,590 --> 00:10:11,520
kind of lawless world.

252
00:10:11,520 --> 00:10:15,470
And it's really hard to work in
that kind of unstructured

253
00:10:15,470 --> 00:10:16,400
environment.

254
00:10:16,400 --> 00:10:18,800
So from a developer standpoint,
what I usually

255
00:10:18,800 --> 00:10:21,420
think is that you want a really
permissive system for

256
00:10:21,420 --> 00:10:24,080
deployment, because you don't
want to put something in front

257
00:10:24,080 --> 00:10:25,710
of end users that will crash.

258
00:10:25,710 --> 00:10:28,230
And you want a really strict
system for development so that

259
00:10:28,230 --> 00:10:31,740
JavaScript doesn't allow you
to do anything silly.

260
00:10:31,740 --> 00:10:34,260
And JavaScript being way over
on the permissive end of the

261
00:10:34,260 --> 00:10:37,180
spectrum, development of
large-scale systems in it can

262
00:10:37,180 --> 00:10:39,830
be difficult.

263
00:10:39,830 --> 00:10:42,680
So what people do, because
JavaScript doesn't bring a lot

264
00:10:42,680 --> 00:10:45,750
of structure of its own, is that
they impose artificial

265
00:10:45,750 --> 00:10:47,400
structure on JavaScript.

266
00:10:47,400 --> 00:10:50,200
So either they have their team
follow very strict coding

267
00:10:50,200 --> 00:10:52,330
standards, or there are patterns
that allow you to

268
00:10:52,330 --> 00:10:53,330
privatize data.

269
00:10:53,330 --> 00:10:56,380
Even though JavaScript doesn't
have an actual way to

270
00:10:56,380 --> 00:10:58,230
privatize data, you can
sort of fake it

271
00:10:58,230 --> 00:10:59,590
with certain patterns.

272
00:10:59,590 --> 00:11:02,310
There are post-processing tools
that will warn you or

273
00:11:02,310 --> 00:11:04,550
add static types and tell
you when you're

274
00:11:04,550 --> 00:11:05,830
doing something silly.

275
00:11:05,830 --> 00:11:07,780
So there's all that kind of
stuff that you should be aware

276
00:11:07,780 --> 00:11:10,720
if you're making a large-scale
JavaScript application.

277
00:11:10,720 --> 00:11:13,590
And then you should also just
be aware that JavaScript is

278
00:11:13,590 --> 00:11:15,380
not going to spit a lot
of errors at you.

279
00:11:15,380 --> 00:11:18,680
So when there are problems in a
certain part of your system,

280
00:11:18,680 --> 00:11:21,370
it might be hard to figure out
what exactly has gone wrong,

281
00:11:21,370 --> 00:11:23,990
because JavaScript always thinks
that everything is OK.

282
00:11:23,990 --> 00:11:26,190
So it's hard to trace
back error chains.

283
00:11:26,190 --> 00:11:29,440
And in an environment like that,
you want to code extra

284
00:11:29,440 --> 00:11:30,480
defensively.

285
00:11:30,480 --> 00:11:33,760
The idea is that you want to
design your system in a

286
00:11:33,760 --> 00:11:35,900
modular way, which is
always a good idea.

287
00:11:35,900 --> 00:11:38,560
And then, hopefully, you can
design it such that if one of

288
00:11:38,560 --> 00:11:41,780
your modules starts behaving
strangely, starts going wonky,

289
00:11:41,780 --> 00:11:43,680
and you can't figure out why,
you can just kill it, and

290
00:11:43,680 --> 00:11:45,860
restart a fresh one, and
reconnect it to your system

291
00:11:45,860 --> 00:11:46,900
while the whole thing
is running.

292
00:11:46,900 --> 00:11:49,250
And if you can design in that
way, you'll save yourself a

293
00:11:49,250 --> 00:11:53,635
lot of pain dealing in the
system that's sort of squishy.

294
00:11:53,635 --> 00:11:56,720

295
00:11:56,720 --> 00:11:59,270
So if you're still one of those
people who thinks to

296
00:11:59,270 --> 00:12:01,910
themselves, well, JavaScript,
that's a scripting language.

297
00:12:01,910 --> 00:12:04,670
You could never actually write
a high-performance credible

298
00:12:04,670 --> 00:12:05,880
game in JavaScript.

299
00:12:05,880 --> 00:12:09,000
You are dealing with seriously
dated information.

300
00:12:09,000 --> 00:12:11,840
JavaScript engines are really
fast these days.

301
00:12:11,840 --> 00:12:14,700
They are absolutely capable of
doing the kind of processing

302
00:12:14,700 --> 00:12:16,960
required for this
kind of game.

303
00:12:16,960 --> 00:12:20,310
The problem is that it's just
really easy to write bad code

304
00:12:20,310 --> 00:12:21,230
in JavaScript.

305
00:12:21,230 --> 00:12:23,760
And there are a ton of examples
of bad code in

306
00:12:23,760 --> 00:12:26,600
JavaScript that people tend
to follow as patterns.

307
00:12:26,600 --> 00:12:31,440
So not only is JavaScript
performance squirrely in that

308
00:12:31,440 --> 00:12:34,220
it's hard to tell what exactly
is going wrong, or small

309
00:12:34,220 --> 00:12:36,550
changes in your JavaScript can
have really, really big

310
00:12:36,550 --> 00:12:39,280
performance implications, and
that information isn't really

311
00:12:39,280 --> 00:12:42,810
surfaced all that well to you as
a developer, but on top of

312
00:12:42,810 --> 00:12:46,110
all that, the VM itself, the
actual virtual machine that's

313
00:12:46,110 --> 00:12:48,860
executing your JavaScript, V8
in Chrome's case, is under

314
00:12:48,860 --> 00:12:49,730
development too.

315
00:12:49,730 --> 00:12:53,330
So something that was slow
yesterday might be fast today.

316
00:12:53,330 --> 00:12:55,960
And so you have to keep all of
this in your mind as you're

317
00:12:55,960 --> 00:12:59,180
trying to write high-performance
JavaScript.

318
00:12:59,180 --> 00:13:02,150
So the best way I know how to
give advice on how to write

319
00:13:02,150 --> 00:13:05,800
high-performance JavaScript is
to explain to you the pieces,

320
00:13:05,800 --> 00:13:07,540
the general components
of how V8 is

321
00:13:07,540 --> 00:13:09,260
actually executing things.

322
00:13:09,260 --> 00:13:12,180
And then, you can develop an
intuition for what might be

323
00:13:12,180 --> 00:13:14,440
fast and what might be slow,
and go from there.

324
00:13:14,440 --> 00:13:17,860
So again, I'm talking about
components of V8 here.

325
00:13:17,860 --> 00:13:19,700
In general, these are components
you find in a lot

326
00:13:19,700 --> 00:13:20,940
of JavaScript engines.

327
00:13:20,940 --> 00:13:23,510
But this, in particular,
is referencing V8's

328
00:13:23,510 --> 00:13:25,500
implementation.

329
00:13:25,500 --> 00:13:27,930
So the components are you have
a just-in-time compiler.

330
00:13:27,930 --> 00:13:30,600
That compiler compiles two sum
representations, so you have

331
00:13:30,600 --> 00:13:32,560
an object model under
the hood.

332
00:13:32,560 --> 00:13:34,100
You have an optimizing
compiler that

333
00:13:34,100 --> 00:13:35,210
compiles after that.

334
00:13:35,210 --> 00:13:36,710
And then, at the end of the
day, you have a garbage

335
00:13:36,710 --> 00:13:39,010
collector that's running around
cleaning up after you.

336
00:13:39,010 --> 00:13:42,360
So I'll talk about each
of these components.

337
00:13:42,360 --> 00:13:45,550
First of all, the just-in-time
compiler.

338
00:13:45,550 --> 00:13:47,590
So the just-in-time compiler,
what it does is

339
00:13:47,590 --> 00:13:48,520
very easy to explain.

340
00:13:48,520 --> 00:13:50,230
It looks at the JavaScript
you wrote.

341
00:13:50,230 --> 00:13:52,780
And it takes snippets of your
JavaScript, and it turns them

342
00:13:52,780 --> 00:13:54,230
into native code.

343
00:13:54,230 --> 00:13:57,650
And that translation, the
directive of the just-in-time

344
00:13:57,650 --> 00:14:00,060
compiler, is to do that as
quickly as possible.

345
00:14:00,060 --> 00:14:05,190
It doesn't try to be overly
clever or to specialize or

346
00:14:05,190 --> 00:14:06,510
optimize at that point.

347
00:14:06,510 --> 00:14:08,520
It's trying to make the
interpretation of JavaScript

348
00:14:08,520 --> 00:14:10,380
files fast. So it just
does that translation

349
00:14:10,380 --> 00:14:11,310
as fast as it can.

350
00:14:11,310 --> 00:14:13,960
And it does a great job of it.

351
00:14:13,960 --> 00:14:15,660
So when we talk about the
just-in-time compiler, we're

352
00:14:15,660 --> 00:14:17,950
talking about generating
native code.

353
00:14:17,950 --> 00:14:20,080
So now we need to talk
about what kind of

354
00:14:20,080 --> 00:14:21,840
native code gets generated.

355
00:14:21,840 --> 00:14:23,770
We need to talk about
data types.

356
00:14:23,770 --> 00:14:26,980
So the first data type of
interest is numbers, numeric

357
00:14:26,980 --> 00:14:29,420
types, of course,
very important.

358
00:14:29,420 --> 00:14:33,700
So V8 has two major internal
representations of numbers.

359
00:14:33,700 --> 00:14:36,220
There are small ints values
and heap numbers, and they

360
00:14:36,220 --> 00:14:38,460
have different performance
profiles.

361
00:14:38,460 --> 00:14:41,960
So small ints are the case you
want to be in if you can.

362
00:14:41,960 --> 00:14:45,470
They are immediate values as
opposed to heap numbers, which

363
00:14:45,470 --> 00:14:47,490
are allocated somewhere
else on the heap.

364
00:14:47,490 --> 00:14:49,660
Small ints are something you're
just holding on to.

365
00:14:49,660 --> 00:14:52,710
And that means they're really
fast to interact with.

366
00:14:52,710 --> 00:14:55,250

367
00:14:55,250 --> 00:14:57,750
The size of a heap number is
an interesting question.

368
00:14:57,750 --> 00:15:01,990
On 32-bit machines, heap numbers
are ints that are 31

369
00:15:01,990 --> 00:15:02,970
bits or less.

370
00:15:02,970 --> 00:15:07,010
On 64-bit machines, small ints
are 32 bits or less.

371
00:15:07,010 --> 00:15:10,820
So there's some sort
of intricacy there.

372
00:15:10,820 --> 00:15:13,650
In general, you probably want to
target both 32-bit machines

373
00:15:13,650 --> 00:15:15,250
and 64-bit machines.

374
00:15:15,250 --> 00:15:18,390
So you probably want
to aim for 31-bit

375
00:15:18,390 --> 00:15:19,940
integers if you can.

376
00:15:19,940 --> 00:15:22,410
Now, don't go crazy with this,
because other kinds of numbers

377
00:15:22,410 --> 00:15:24,150
can be optimized later too.

378
00:15:24,150 --> 00:15:26,970
But if you have a system, like
your OPT tree system or your

379
00:15:26,970 --> 00:15:30,510
particle system that lends
itself to being cast in terms

380
00:15:30,510 --> 00:15:34,210
of integer math, it might be a
major performance improvement

381
00:15:34,210 --> 00:15:37,950
for you if you can get into
these SMI values.

382
00:15:37,950 --> 00:15:39,020
So that's SMIs.

383
00:15:39,020 --> 00:15:40,070
Then we have heap numbers.

384
00:15:40,070 --> 00:15:43,480
So heap numbers are anything
that won't fit into an SMI and

385
00:15:43,480 --> 00:15:45,340
is not a local variable.

386
00:15:45,340 --> 00:15:48,380
So exactly like you'd expect,
these numbers can't be

387
00:15:48,380 --> 00:15:49,680
allocated in an immediate
mode.

388
00:15:49,680 --> 00:15:52,170
So they need to be wrapped up
and allocated on the heap,

389
00:15:52,170 --> 00:15:54,100
which means that now they're
going to be slightly slower to

390
00:15:54,100 --> 00:15:56,110
deal with because you're
referencing a number that's

391
00:15:56,110 --> 00:15:58,180
somewhere else.

392
00:15:58,180 --> 00:16:00,250
Now, before you go crazy, again,
I want to make sure

393
00:16:00,250 --> 00:16:02,880
that I don't accidentally tell
you to overspecialize.

394
00:16:02,880 --> 00:16:04,960
Doubles are sometimes
optimized.

395
00:16:04,960 --> 00:16:06,820
V8 knows that math is
really important.

396
00:16:06,820 --> 00:16:08,550
It's something people
want to do a lot of.

397
00:16:08,550 --> 00:16:10,930
So we'll try to optimize
your doubles.

398
00:16:10,930 --> 00:16:12,710
It'll try to allocate them
in immediate mode.

399
00:16:12,710 --> 00:16:15,560
It'll try to allocate them
in registers if it can.

400
00:16:15,560 --> 00:16:18,000
But it might not be able to, so
there's no guarantee there.

401
00:16:18,000 --> 00:16:20,480
So again, don't go crazy trying
to make all small ints.

402
00:16:20,480 --> 00:16:23,320
But if you can, if it lends
itself to your system, it

403
00:16:23,320 --> 00:16:26,450
could work for you.

404
00:16:26,450 --> 00:16:27,400
So that's numbers.

405
00:16:27,400 --> 00:16:29,620
Next, we need to talk
about arrays.

406
00:16:29,620 --> 00:16:33,360
So the first type of array to
talk about in JavaScript is

407
00:16:33,360 --> 00:16:34,540
the TypedArray.

408
00:16:34,540 --> 00:16:38,095
So TypedArrays are going to make
a lot of sense to you if

409
00:16:38,095 --> 00:16:39,930
you're coming from
a C background.

410
00:16:39,930 --> 00:16:43,930
They are contiguous blocks of
memory that are specified for

411
00:16:43,930 --> 00:16:45,250
a particular data type.

412
00:16:45,250 --> 00:16:48,430
So you have Uint32Array,
Float64Array, Uint8Array, and

413
00:16:48,430 --> 00:16:50,940
so on, and so forth, which
actually, if you're familiar

414
00:16:50,940 --> 00:16:52,610
with JavaScript, is
sort of unusual.

415
00:16:52,610 --> 00:16:54,690
Because most things in
JavaScript have no type.

416
00:16:54,690 --> 00:16:58,220
So this idea that we're
specifying a very specific

417
00:16:58,220 --> 00:17:01,420
size for our numbers is actually
like pretty unique.

418
00:17:01,420 --> 00:17:04,200
And that's because the
TypedArray specification grew

419
00:17:04,200 --> 00:17:07,060
up alongside the WebGL
specification.

420
00:17:07,060 --> 00:17:10,940
And you can imagine how you need
that level of specificity

421
00:17:10,940 --> 00:17:12,180
if you're doing graphics
programming.

422
00:17:12,180 --> 00:17:13,460
So that's sort of where
the TypedArray

423
00:17:13,460 --> 00:17:14,730
specification came from.

424
00:17:14,730 --> 00:17:17,349
But it's been adopted
into other things

425
00:17:17,349 --> 00:17:18,410
now that it's there.

426
00:17:18,410 --> 00:17:19,700
So again, they're memory
efficient.

427
00:17:19,700 --> 00:17:20,690
You don't have to box them.

428
00:17:20,690 --> 00:17:21,810
They behave as you'd expect.

429
00:17:21,810 --> 00:17:24,760
They're a very nice
option for arrays.

430
00:17:24,760 --> 00:17:27,030
But if you can't use TypedArrays
for whatever

431
00:17:27,030 --> 00:17:29,750
reason, you need to use
JavaScript Arrays.

432
00:17:29,750 --> 00:17:31,560
So JavaScript Array object &mdash;

433
00:17:31,560 --> 00:17:33,050
Array with a capital A &mdash;

434
00:17:33,050 --> 00:17:35,970
has an API which is going to
look a little weird to you if

435
00:17:35,970 --> 00:17:38,030
you are used to C-style
arrays.

436
00:17:38,030 --> 00:17:40,040
It's going to have operations
that are different.

437
00:17:40,040 --> 00:17:41,590
It's going to have like
push and pop.

438
00:17:41,590 --> 00:17:44,730
It's going to allow you to
index out of bounds.

439
00:17:44,730 --> 00:17:48,090
It's going to have just sort
of odd behavior to me as

440
00:17:48,090 --> 00:17:50,260
somebody coming from C.

441
00:17:50,260 --> 00:17:54,400
So as you can imagine, because
the API allows all these non-C

442
00:17:54,400 --> 00:17:57,850
array-like things, the backing
storage in V8 is not always

443
00:17:57,850 --> 00:18:00,390
something that looks
like an array.

444
00:18:00,390 --> 00:18:02,290
There are actually two different
types of backing

445
00:18:02,290 --> 00:18:03,380
storage for arrays.

446
00:18:03,380 --> 00:18:06,720
There are sparse arrays and
dense arrays, which map to

447
00:18:06,720 --> 00:18:08,700
either something that looks
like a C-style array, like

448
00:18:08,700 --> 00:18:11,150
you'd expect, or a hash table.

449
00:18:11,150 --> 00:18:14,920
And if your array is backed by a
V8 hash table, that's called

450
00:18:14,920 --> 00:18:16,360
being in dictionary
mode, and it's

451
00:18:16,360 --> 00:18:17,880
considerably less efficient.

452
00:18:17,880 --> 00:18:19,320
It's a case that you
want to avoid.

453
00:18:19,320 --> 00:18:22,130

454
00:18:22,130 --> 00:18:24,440
There are many factors in V8
that causes you to be kicked

455
00:18:24,440 --> 00:18:27,650
into dictionary mode or not.

456
00:18:27,650 --> 00:18:30,210
So it's kind of complicated
to define them all.

457
00:18:30,210 --> 00:18:33,110
But one of them, for instance,
is space efficiency.

458
00:18:33,110 --> 00:18:36,700
So if the codes you wrote will
be three times more efficient,

459
00:18:36,700 --> 00:18:40,860
use three times less space if it
was backed by a hash table

460
00:18:40,860 --> 00:18:43,680
than an array, then it'll be a
hash table on the back end.

461
00:18:43,680 --> 00:18:45,810
So there are criteria
like that.

462
00:18:45,810 --> 00:18:47,430
Let me give you an example.

463
00:18:47,430 --> 00:18:50,360
So this is something that
JavaScript allows you to do.

464
00:18:50,360 --> 00:18:52,590
JavaScript allows you to create
a new uninitialized

465
00:18:52,590 --> 00:18:54,500
array and then just suddenly
index into

466
00:18:54,500 --> 00:18:56,850
it at whatever index.

467
00:18:56,850 --> 00:18:58,920
This, of course, doesn't make
any sense in C. It's not

468
00:18:58,920 --> 00:19:00,660
something you'd actually do.

469
00:19:00,660 --> 00:19:04,450
And in V8, it will immediately
trigger dictionary mode.

470
00:19:04,450 --> 00:19:07,580
So this, you will now have a
nice, slow array to work with,

471
00:19:07,580 --> 00:19:09,810
not something you want.

472
00:19:09,810 --> 00:19:12,210
This is an example of a better
way to do things.

473
00:19:12,210 --> 00:19:13,530
So real simple change.

474
00:19:13,530 --> 00:19:14,980
All you have to do is
declare how much

475
00:19:14,980 --> 00:19:16,280
storage you want up front.

476
00:19:16,280 --> 00:19:19,350
Now you have declared to V8
that you actually want an

477
00:19:19,350 --> 00:19:20,580
array of a certain size.

478
00:19:20,580 --> 00:19:23,840
V8 will back your array by a
contiguous array of that size,

479
00:19:23,840 --> 00:19:24,960
and you can go from there.

480
00:19:24,960 --> 00:19:28,980
Very sensible, kind of
no-brainerish, but again,

481
00:19:28,980 --> 00:19:31,810
JavaScript allows you to do it
in a way that ends up being

482
00:19:31,810 --> 00:19:35,830
very inefficient, so it's
important to know.

483
00:19:35,830 --> 00:19:38,870
So that is the numeric
representation and the

484
00:19:38,870 --> 00:19:41,730
immediate representation
of objects.

485
00:19:41,730 --> 00:19:44,060
Now, we're going to talk about
representing JavaScript

486
00:19:44,060 --> 00:19:46,670
objects in V8.

487
00:19:46,670 --> 00:19:49,620
So objects in JavaScript
are these very

488
00:19:49,620 --> 00:19:50,860
poorly defined things.

489
00:19:50,860 --> 00:19:52,630
They are associative arrays.

490
00:19:52,630 --> 00:19:55,340
They're just bundles of key
value pairs of properties.

491
00:19:55,340 --> 00:19:58,030
So you have string value for
key, property value.

492
00:19:58,030 --> 00:20:01,450
And all property values are
these undefined whatevers,

493
00:20:01,450 --> 00:20:03,740
because JavaScript doesn't
have a notion of type.

494
00:20:03,740 --> 00:20:05,350
Objects have prototype chains.

495
00:20:05,350 --> 00:20:08,440
You can add and remove
properties anywhere at the

496
00:20:08,440 --> 00:20:11,270
prototype chain and on the
object itself at any point.

497
00:20:11,270 --> 00:20:14,950
JavaScript doesn't enforce
any specificity or

498
00:20:14,950 --> 00:20:17,630
structure in your code.

499
00:20:17,630 --> 00:20:20,940
So if you wanted to, you could
make every single object in

500
00:20:20,940 --> 00:20:24,770
your whole program absolutely
a unique set of properties.

501
00:20:24,770 --> 00:20:27,510
Nothing in JavaScript will
enforce structure or

502
00:20:27,510 --> 00:20:29,100
self-similarity.

503
00:20:29,100 --> 00:20:32,130
But just because JavaScript
allows you to do that, you

504
00:20:32,130 --> 00:20:32,910
really, really shouldn't.

505
00:20:32,910 --> 00:20:35,230
That's actually a terrible thing
to do for performance.

506
00:20:35,230 --> 00:20:37,080
And I'll explain why
in a minute.

507
00:20:37,080 --> 00:20:39,870

508
00:20:39,870 --> 00:20:45,220
So in V8, the V8 team looked
at trying to write a

509
00:20:45,220 --> 00:20:47,830
large-scale application in
JavaScript and thought, hey,

510
00:20:47,830 --> 00:20:49,800
you know what's important in
large-scale systems is

511
00:20:49,800 --> 00:20:50,870
object-orientedness.

512
00:20:50,870 --> 00:20:52,770
And if you have
object-orientedness in your

513
00:20:52,770 --> 00:20:56,020
system, then now, property
access is one of the key

514
00:20:56,020 --> 00:20:59,140
things that you need to make
fast. So V8 designed its

515
00:20:59,140 --> 00:21:03,210
structure to make property
access on objects as efficient

516
00:21:03,210 --> 00:21:04,660
as it could be.

517
00:21:04,660 --> 00:21:07,220
So the internal representation
of an object

518
00:21:07,220 --> 00:21:09,300
in V8 is three words.

519
00:21:09,300 --> 00:21:12,290
So first, we have a hidden class
pointer, which is an

520
00:21:12,290 --> 00:21:15,010
internal notion of type, which
I'll explain in a second.

521
00:21:15,010 --> 00:21:16,800
And then we have two pointers
to different kinds of

522
00:21:16,800 --> 00:21:17,380
properties.

523
00:21:17,380 --> 00:21:20,330
We have properties that have
string names and then

524
00:21:20,330 --> 00:21:21,800
properties that have
int names.

525
00:21:21,800 --> 00:21:24,330
But really, the only thing
that's important is you have a

526
00:21:24,330 --> 00:21:27,890
type, and then you have
property storage.

527
00:21:27,890 --> 00:21:29,500
So what's this hidden
class thing?

528
00:21:29,500 --> 00:21:31,490
So hidden classes, again,
they're V8's

529
00:21:31,490 --> 00:21:32,620
internal notion of type.

530
00:21:32,620 --> 00:21:34,845
JavaScript itself isn't going to
enforce any kind of notion

531
00:21:34,845 --> 00:21:36,080
of type on you.

532
00:21:36,080 --> 00:21:39,680
But in order to make things
efficient, V8 itself needs to

533
00:21:39,680 --> 00:21:42,770
have some sort of structure in
what it thinks you're doing.

534
00:21:42,770 --> 00:21:44,840
So it introduces
a type system.

535
00:21:44,840 --> 00:21:46,990
And that type system
groups objects

536
00:21:46,990 --> 00:21:47,830
with the same structure.

537
00:21:47,830 --> 00:21:50,990
So as you're adding properties
to objects, which you can do

538
00:21:50,990 --> 00:21:54,340
in JavaScript, V8 will be
looking at the properties on

539
00:21:54,340 --> 00:21:57,740
each object and mapping that
bundle of properties to a

540
00:21:57,740 --> 00:22:01,580
hidden class, which defines an
object with exactly those

541
00:22:01,580 --> 00:22:01,920
properties.

542
00:22:01,920 --> 00:22:06,150
So, for instance, if I have this
constructor in JavaScript

543
00:22:06,150 --> 00:22:09,660
where I have a point, and it
has an x and y, and the way

544
00:22:09,660 --> 00:22:12,340
those values are added by first
adding x to the object

545
00:22:12,340 --> 00:22:15,800
and then adding y, that's going
to generate a hidden

546
00:22:15,800 --> 00:22:19,110
class that backs objects that
are created from this function

547
00:22:19,110 --> 00:22:22,340
that has exactly the
properties x and y.

548
00:22:22,340 --> 00:22:24,510
And that really seems
sort of obvious.

549
00:22:24,510 --> 00:22:27,800
But then, the first time this
function is run, that hidden

550
00:22:27,800 --> 00:22:30,980
class is going to be built
for the first time.

551
00:22:30,980 --> 00:22:34,180
And then, all subsequent times
this function is run, those

552
00:22:34,180 --> 00:22:36,930
new objects can share the
same hidden class.

553
00:22:36,930 --> 00:22:38,840
So you only pay the price
for building it

554
00:22:38,840 --> 00:22:39,720
the very first time.

555
00:22:39,720 --> 00:22:43,480
After that, you can just
use the same object.

556
00:22:43,480 --> 00:22:45,190
So we went through all this
trouble of building up a

557
00:22:45,190 --> 00:22:45,930
notion of type.

558
00:22:45,930 --> 00:22:49,050
So now, we have types that
correspond to specifically

559
00:22:49,050 --> 00:22:50,960
what exact properties
are on an object.

560
00:22:50,960 --> 00:22:58,020
We can use that notion of type
to make property access quick

561
00:22:58,020 --> 00:23:01,180
using something called
inline caching.

562
00:23:01,180 --> 00:23:04,850
So if you want to look up a
property on an object in

563
00:23:04,850 --> 00:23:07,110
JavaScript, you're going to say,
I am looking for property

564
00:23:07,110 --> 00:23:11,920
with name x on object y.

565
00:23:11,920 --> 00:23:14,660
The first thing you do when
you're trying to look up a

566
00:23:14,660 --> 00:23:19,020
property is check the hidden
class of the object.

567
00:23:19,020 --> 00:23:21,990
If you've never tried to look up
that property on an object

568
00:23:21,990 --> 00:23:24,600
of that type before, then what
you're going to have to do is

569
00:23:24,600 --> 00:23:27,280
a fully generic search
for that property.

570
00:23:27,280 --> 00:23:28,590
So again, we just have a bundle

571
00:23:28,590 --> 00:23:29,450
of properties somewhere.

572
00:23:29,450 --> 00:23:30,600
They all have string names.

573
00:23:30,600 --> 00:23:32,580
You have a string of the
property you're looking for.

574
00:23:32,580 --> 00:23:34,880
And you're going to have to look
through that list for the

575
00:23:34,880 --> 00:23:36,750
property that has
a matching name.

576
00:23:36,750 --> 00:23:39,020
That's a pretty slow
operation.

577
00:23:39,020 --> 00:23:41,860
But once you found that
property once, you can

578
00:23:41,860 --> 00:23:43,270
remember the offset to it.

579
00:23:43,270 --> 00:23:45,620
You can remember where you found
that property and use it

580
00:23:45,620 --> 00:23:49,300
later, which means that you can
use that to generate new

581
00:23:49,300 --> 00:23:52,900
optimized code which specifies
how you look up that

582
00:23:52,900 --> 00:23:55,520
particular property on that
particular object.

583
00:23:55,520 --> 00:23:58,110
And the next time you want to
look up property with that

584
00:23:58,110 --> 00:24:00,920
name on an object of
that type, you

585
00:24:00,920 --> 00:24:01,830
can have direct access.

586
00:24:01,830 --> 00:24:04,220
You know exactly where to go
in an object of that type.

587
00:24:04,220 --> 00:24:06,190
And it's much, much,
much faster.

588
00:24:06,190 --> 00:24:09,470
So that's really what the notion
of having hidden class

589
00:24:09,470 --> 00:24:12,910
is getting us, is now we can
make property access really

590
00:24:12,910 --> 00:24:15,970
fast through inline caching.

591
00:24:15,970 --> 00:24:19,110
So this is a classic example
of a bad idea.

592
00:24:19,110 --> 00:24:21,380
So I have another constructor.

593
00:24:21,380 --> 00:24:23,200
It's creating a vector object.

594
00:24:23,200 --> 00:24:25,190
It's adding an x and y.

595
00:24:25,190 --> 00:24:27,730
But then, after I go through the
trouble of doing that, I

596
00:24:27,730 --> 00:24:31,100
decide that I now wanted
property z on this object.

597
00:24:31,100 --> 00:24:34,140
The problem with that is that
if you add a property z to

598
00:24:34,140 --> 00:24:36,760
that object at some future
point, if you just dynamically

599
00:24:36,760 --> 00:24:39,480
do that, you're going to change
the hidden class of the

600
00:24:39,480 --> 00:24:42,290
object, which means that all
this nice caching you've done

601
00:24:42,290 --> 00:24:44,140
and building up a notion of
where the properties are,

602
00:24:44,140 --> 00:24:45,520
that's just blown away
because now you have

603
00:24:45,520 --> 00:24:46,350
a new hidden class.

604
00:24:46,350 --> 00:24:48,090
You have to pay to build the new
hidden class, and now you

605
00:24:48,090 --> 00:24:50,720
have to deal with a
new hidden class.

606
00:24:50,720 --> 00:24:53,160
So one of the best things you
can do to make your code

607
00:24:53,160 --> 00:24:56,250
efficient is to create a
few well-defined types.

608
00:24:56,250 --> 00:24:58,910
Don't do a lot of dynamic
property adding and removing

609
00:24:58,910 --> 00:25:00,350
outside of constructors.

610
00:25:00,350 --> 00:25:03,100
Pretty much set things up once,
have them look alike so

611
00:25:03,100 --> 00:25:05,890
that they can share the same
hidden class, and don't mess

612
00:25:05,890 --> 00:25:09,520
with the properties they have.

613
00:25:09,520 --> 00:25:11,730
So now we know an object
has properties.

614
00:25:11,730 --> 00:25:15,680
Those properties can be in
different storage states.

615
00:25:15,680 --> 00:25:17,830
So the first state, the default,
is that they can be

616
00:25:17,830 --> 00:25:19,690
stored directly in an
array on the object.

617
00:25:19,690 --> 00:25:20,330
That's great.

618
00:25:20,330 --> 00:25:22,270
That's fast. That's where
you want to be.

619
00:25:22,270 --> 00:25:25,410
A second state they can be in
is being stored in array off

620
00:25:25,410 --> 00:25:26,020
the objects.

621
00:25:26,020 --> 00:25:26,640
Still great.

622
00:25:26,640 --> 00:25:27,260
Still an array.

623
00:25:27,260 --> 00:25:28,710
No problem.

624
00:25:28,710 --> 00:25:30,980
The third case, which is the
one you really have to look

625
00:25:30,980 --> 00:25:33,650
out for, is when they're
stored in a hash table.

626
00:25:33,650 --> 00:25:36,900
So much like just the array case
in general where arrays

627
00:25:36,900 --> 00:25:39,210
can have different types of
backing storage, properties

628
00:25:39,210 --> 00:25:41,120
can have different types
of backing storage too.

629
00:25:41,120 --> 00:25:43,350
So properties can either be in
normal mode where they're

630
00:25:43,350 --> 00:25:46,280
stored as an array or a
dictionary mode where they're

631
00:25:46,280 --> 00:25:47,530
stored as a hash table.

632
00:25:47,530 --> 00:25:49,640
And if you have an object in
dictionary mode, it's going to

633
00:25:49,640 --> 00:25:51,070
be much slower to
interact with.

634
00:25:51,070 --> 00:25:53,420
So you don't want that.

635
00:25:53,420 --> 00:25:56,440
So what triggers dictionary
mode, and how do you avoid it?

636
00:25:56,440 --> 00:25:58,850
Well, one thing that triggers
it is too many properties.

637
00:25:58,850 --> 00:26:01,390
So if you have so many
properties that they won't fit

638
00:26:01,390 --> 00:26:03,780
into the internal storage for
properties, then you have to

639
00:26:03,780 --> 00:26:05,860
have a hash table elsewhere.

640
00:26:05,860 --> 00:26:07,580
And that number of too
many properties is

641
00:26:07,580 --> 00:26:08,580
somewhere around 30.

642
00:26:08,580 --> 00:26:12,620
It's quite generous, but you
might hit it in some cases.

643
00:26:12,620 --> 00:26:16,890
The other things you can do to
confuse your object and kick

644
00:26:16,890 --> 00:26:19,450
it into dictionary mode
are to change the

645
00:26:19,450 --> 00:26:20,490
properties on that object.

646
00:26:20,490 --> 00:26:23,150
You can change the attribute,
you can delete properties,

647
00:26:23,150 --> 00:26:23,710
that kind of thing.

648
00:26:23,710 --> 00:26:25,030
Those things are all going
to kick you straight to

649
00:26:25,030 --> 00:26:25,910
dictionary mode.

650
00:26:25,910 --> 00:26:28,720
Again, and now you're going to
make your object much slower

651
00:26:28,720 --> 00:26:29,970
to interact with.

652
00:26:29,970 --> 00:26:33,330

653
00:26:33,330 --> 00:26:34,480
So that's object storage.

654
00:26:34,480 --> 00:26:37,180
And we have a general idea of
what we want to do, which is

655
00:26:37,180 --> 00:26:41,490
pretty much create repeating
common stable structures in

656
00:26:41,490 --> 00:26:43,620
our code, not change them too
much so we can do all our nice

657
00:26:43,620 --> 00:26:44,790
caching and stuff.

658
00:26:44,790 --> 00:26:46,670
Now, we're going to talk about
the optimizing compiler which

659
00:26:46,670 --> 00:26:50,220
is how you really make
JavaScript fast.

660
00:26:50,220 --> 00:26:53,550
So the optimizing compiler is
the second of two compilers.

661
00:26:53,550 --> 00:26:55,550
Remember, we had the
just-in-time compiler first,

662
00:26:55,550 --> 00:26:57,930
which is doing its best to just
make the translation from

663
00:26:57,930 --> 00:27:00,750
JavaScript to native code
as fast as it can.

664
00:27:00,750 --> 00:27:02,650
And then, we have this other
compiler, the optimizing

665
00:27:02,650 --> 00:27:04,670
compiler, which is actually
going to look at that code

666
00:27:04,670 --> 00:27:09,550
that's generated and try to make
it really good fast code.

667
00:27:09,550 --> 00:27:14,050
So because JavaScript doesn't
give you any language to tell

668
00:27:14,050 --> 00:27:17,130
V8 what you're intending, the
only thing that the optimizing

669
00:27:17,130 --> 00:27:20,820
compiler can do is sit back and
watch your system as it

670
00:27:20,820 --> 00:27:23,330
warms up and try to infer
structures in your code.

671
00:27:23,330 --> 00:27:24,500
It's going to watch
what you're doing.

672
00:27:24,500 --> 00:27:28,620
It's going to watch for what
types are where and how the

673
00:27:28,620 --> 00:27:31,250
data is flowing through it, and
then make inferences about

674
00:27:31,250 --> 00:27:34,120
the kinds of optimizations
that it can do.

675
00:27:34,120 --> 00:27:38,710
So this is a costly operation,
which is why we don't actually

676
00:27:38,710 --> 00:27:41,200
just try to optimize
everything.

677
00:27:41,200 --> 00:27:43,850
The system only tries to
optimize functions that have

678
00:27:43,850 --> 00:27:47,125
been deemed to be worthwhile,
and that decision is made from

679
00:27:47,125 --> 00:27:48,030
a profiler thread.

680
00:27:48,030 --> 00:27:51,070
So when Crankshaft, which is
the name of V8's optimizing

681
00:27:51,070 --> 00:27:54,470
compiler, spins up, spins up a
profiling thread to watch for

682
00:27:54,470 --> 00:27:57,880
what functions are hot, when
it sees a function that it

683
00:27:57,880 --> 00:28:00,640
thinks should be optimized, it
then looks at the type data

684
00:28:00,640 --> 00:28:01,600
it's collected so far.

685
00:28:01,600 --> 00:28:03,890
So it's like, ah, this function
seems to take ints

686
00:28:03,890 --> 00:28:04,440
all the time.

687
00:28:04,440 --> 00:28:06,690
And it seems to return this
kind of data, and

688
00:28:06,690 --> 00:28:07,770
so on, and so forth.

689
00:28:07,770 --> 00:28:11,160
And using that type data that
it's collected, it can do all

690
00:28:11,160 --> 00:28:12,170
sorts of optimization.

691
00:28:12,170 --> 00:28:13,400
It can inline code.

692
00:28:13,400 --> 00:28:16,210
It can do loop invariant
code motion.

693
00:28:16,210 --> 00:28:18,710
It can do all sorts of
optimizations and specialize

694
00:28:18,710 --> 00:28:19,620
on those types.

695
00:28:19,620 --> 00:28:23,160
Then, it can take the new
optimized fast path code it

696
00:28:23,160 --> 00:28:25,790
generated, do on-stack
replacement to just swap it

697
00:28:25,790 --> 00:28:28,820
out in place, hold on to the old
slow code, just in case it

698
00:28:28,820 --> 00:28:32,530
needs it later, and continue on
executing without anybody

699
00:28:32,530 --> 00:28:34,140
knowing the difference except
for that the code is much,

700
00:28:34,140 --> 00:28:35,500
much faster now.

701
00:28:35,500 --> 00:28:39,140
So the optimizing compiler is
really the heart of what will

702
00:28:39,140 --> 00:28:42,590
make your game JavaScript
performant.

703
00:28:42,590 --> 00:28:45,330
And you really need to be
working with this system to

704
00:28:45,330 --> 00:28:48,170
try to play nice with it.

705
00:28:48,170 --> 00:28:51,200
So what kind of structures are
optimized by Crankshaft?

706
00:28:51,200 --> 00:28:52,350
Well, I'll tell you,
not everything.

707
00:28:52,350 --> 00:28:55,230
Not everything is an eligible
construct in your JavaScript

708
00:28:55,230 --> 00:28:57,130
for optimization.

709
00:28:57,130 --> 00:28:59,870
When Crankshaft looks at a
function, it's like, ah, I

710
00:28:59,870 --> 00:29:00,610
want to optimize that.

711
00:29:00,610 --> 00:29:02,170
It starts trying to
optimize the code.

712
00:29:02,170 --> 00:29:04,240
And then in the middle, it hits
something that it can't

713
00:29:04,240 --> 00:29:05,000
actually do.

714
00:29:05,000 --> 00:29:07,180
It finds something that
it can't optimize.

715
00:29:07,180 --> 00:29:09,500
That's a condition
we call bailout.

716
00:29:09,500 --> 00:29:11,230
Bailout means I tried
to optimize this.

717
00:29:11,230 --> 00:29:12,680
I tried for you, but actually,
I couldn't

718
00:29:12,680 --> 00:29:13,640
do it for some reason.

719
00:29:13,640 --> 00:29:16,950
So I'm just going to not
try to optimize that.

720
00:29:16,950 --> 00:29:18,940
And there are a number of things
that cause bailouts.

721
00:29:18,940 --> 00:29:20,800
And they actually change
a good deal.

722
00:29:20,800 --> 00:29:24,170
So one thing is that functions
are too long.

723
00:29:24,170 --> 00:29:26,080
Functions that are really,
really long are not candidates

724
00:29:26,080 --> 00:29:27,170
for optimization.

725
00:29:27,170 --> 00:29:30,030
This is an interesting case
because some of these tools

726
00:29:30,030 --> 00:29:31,730
that try to make your JavaScript
fast, like

727
00:29:31,730 --> 00:29:35,640
post-processing tools, like
closure, some of those in some

728
00:29:35,640 --> 00:29:38,530
cases do such aggressive
in-lining that they create

729
00:29:38,530 --> 00:29:39,690
these giant functions.

730
00:29:39,690 --> 00:29:41,590
And then, those giant functions
are no longer

731
00:29:41,590 --> 00:29:44,570
candidates for optimization
by Crankshaft.

732
00:29:44,570 --> 00:29:46,280
And so they actually make the
code a good deal slower.

733
00:29:46,280 --> 00:29:47,870
I've seen this happen.

734
00:29:47,870 --> 00:29:50,860
So when I see function too long,
you probably wouldn't

735
00:29:50,860 --> 00:29:52,560
write it, a function
that long.

736
00:29:52,560 --> 00:29:53,670
But something that's

737
00:29:53,670 --> 00:29:55,520
post-processing your code might.

738
00:29:55,520 --> 00:29:58,820
So you should keep
your eye on it.

739
00:29:58,820 --> 00:30:01,310
And other than that, there are
just a number of specific

740
00:30:01,310 --> 00:30:02,890
cases that can't be optimized.

741
00:30:02,890 --> 00:30:05,570
If you want to see what's
being optimized and what

742
00:30:05,570 --> 00:30:08,430
isn't, you can use these
two handy V8 flags.

743
00:30:08,430 --> 00:30:10,600
You can use trace-bailout,
and trace-opt.

744
00:30:10,600 --> 00:30:13,490
Tract-bailout will spit out
the function names of what

745
00:30:13,490 --> 00:30:15,010
things are bailing
out and why.

746
00:30:15,010 --> 00:30:16,190
Trace-opt will tell you what

747
00:30:16,190 --> 00:30:17,740
functions are getting optimized.

748
00:30:17,740 --> 00:30:22,450
So I have a bunch of specific
output from trace-bailout.

749
00:30:22,450 --> 00:30:26,270
These actually came from a
recent trace that I ran.

750
00:30:26,270 --> 00:30:28,170
And you can see, this
sort of makes sense.

751
00:30:28,170 --> 00:30:29,230
They're very readable &mdash;

752
00:30:29,230 --> 00:30:31,260
tryCatch not supported,
Forin not supported,

753
00:30:31,260 --> 00:30:33,250
NonStringToString
not supported.

754
00:30:33,250 --> 00:30:35,270
I debated a lot putting
them on the slide.

755
00:30:35,270 --> 00:30:38,620
I wanted to put something up
here as representative.

756
00:30:38,620 --> 00:30:41,050
But just know that these are the
types of things that will

757
00:30:41,050 --> 00:30:43,840
change, like the V8 team is
trying to optimize this.

758
00:30:43,840 --> 00:30:45,350
They're trying to handle
more cases.

759
00:30:45,350 --> 00:30:48,540
So just keep checking in about
what in your code is bailing

760
00:30:48,540 --> 00:30:50,620
out and what is working
well, and keep

761
00:30:50,620 --> 00:30:51,870
watching with the flags.

762
00:30:51,870 --> 00:30:54,520

763
00:30:54,520 --> 00:30:58,070
So the thing is, all those
wonderful optimizations that

764
00:30:58,070 --> 00:31:00,870
Crankshaft made for you when it
does successfully optimize

765
00:31:00,870 --> 00:31:02,750
functions are speculative.

766
00:31:02,750 --> 00:31:05,170
They are based on the
information that Crankshaft

767
00:31:05,170 --> 00:31:07,040
has at the time they are made.

768
00:31:07,040 --> 00:31:08,720
So again, the way Crankshaft
works, it

769
00:31:08,720 --> 00:31:09,880
just watches the system.

770
00:31:09,880 --> 00:31:11,590
It infers what patterns
are where.

771
00:31:11,590 --> 00:31:14,260
It sees what the types kind of
are, and then, it tries to

772
00:31:14,260 --> 00:31:15,930
specialize based on that.

773
00:31:15,930 --> 00:31:18,510
So if your code always did
things a certain way, it

774
00:31:18,510 --> 00:31:20,750
always passed this function
ints, and then suddenly, it's

775
00:31:20,750 --> 00:31:22,980
like, nah, I want to pass this
function objects or strings or

776
00:31:22,980 --> 00:31:28,570
whatever, suddenly, the
assumptions that were made to

777
00:31:28,570 --> 00:31:30,440
optimize that code
are violated.

778
00:31:30,440 --> 00:31:32,770
And that results in something
called the deopt, which is

779
00:31:32,770 --> 00:31:36,080
where we have to take that slow
code that we kept around

780
00:31:36,080 --> 00:31:38,940
just in case and swap it back
in for the fast code.

781
00:31:38,940 --> 00:31:40,970
And deoptimizations
are really tragic.

782
00:31:40,970 --> 00:31:42,410
They're sort of a double fail.

783
00:31:42,410 --> 00:31:45,400
Because you paid to optimize the
code, which was expensive.

784
00:31:45,400 --> 00:31:46,330
And you paid to swap it in.

785
00:31:46,330 --> 00:31:48,580
And then you paid to swap
it back out again.

786
00:31:48,580 --> 00:31:51,100
And now, you're running slow
code again on a function that

787
00:31:51,100 --> 00:31:52,470
Crankshaft thought it
should optimize.

788
00:31:52,470 --> 00:31:55,180
So you really don't want
deoptimizations.

789
00:31:55,180 --> 00:31:59,330
The way you tell whether your
code is deopting is using

790
00:31:59,330 --> 00:32:01,260
another handy flag in
V8 &mdash; trace-deopt.

791
00:32:01,260 --> 00:32:02,870
And that, again, it'll
tell you the

792
00:32:02,870 --> 00:32:03,820
names of the functions.

793
00:32:03,820 --> 00:32:08,270
It'll output them to stdout,
the names of the functions

794
00:32:08,270 --> 00:32:09,260
that are deopting and why.

795
00:32:09,260 --> 00:32:13,140
So keep an eye on that as
you write your game.

796
00:32:13,140 --> 00:32:16,140
So in general, what you should
be taking away from all this

797
00:32:16,140 --> 00:32:18,640
is that JavaScript, it's
this wonderfully

798
00:32:18,640 --> 00:32:19,940
elegant dynamic language.

799
00:32:19,940 --> 00:32:22,110
So once you get used to it,
you can do all this stuff

800
00:32:22,110 --> 00:32:24,000
which is very JavaScripty.

801
00:32:24,000 --> 00:32:26,810
You can dynamically add
properties and take optional

802
00:32:26,810 --> 00:32:29,230
arguments to functions and
use closures in this

803
00:32:29,230 --> 00:32:31,830
very elegant way.

804
00:32:31,830 --> 00:32:34,320
Whenever you see something
that's really dynamic and

805
00:32:34,320 --> 00:32:37,740
really JavaScripty, you should
be a little bit suspicious,

806
00:32:37,740 --> 00:32:41,090
because, just because you're
not writing native code,

807
00:32:41,090 --> 00:32:43,180
doesn't mean that someone isn't
writing native code.

808
00:32:43,180 --> 00:32:46,270
Remember that Crankshaft is over
here watching what you do

809
00:32:46,270 --> 00:32:49,190
and trying to figure out what
you mean, trying to infer from

810
00:32:49,190 --> 00:32:50,560
your program's behavior
what you mean.

811
00:32:50,560 --> 00:32:53,560
So if you keep changing what
your program does, it can't

812
00:32:53,560 --> 00:32:54,800
help you optimize.

813
00:32:54,800 --> 00:32:58,390
So the more type stable and
predictable and C-like you can

814
00:32:58,390 --> 00:33:02,160
make your code, the better
you're going to be.

815
00:33:02,160 --> 00:33:04,600
So again, that's a
rule of thumb.

816
00:33:04,600 --> 00:33:09,740
JavaScripty JavaScriptisms can
be fast. But if you want like

817
00:33:09,740 --> 00:33:13,860
a hard-and-fast rule, the more
like C it is, those things are

818
00:33:13,860 --> 00:33:16,830
likely to be faster.

819
00:33:16,830 --> 00:33:19,960
So in terms of other rules, so
create a few well-defined

820
00:33:19,960 --> 00:33:22,230
object types.

821
00:33:22,230 --> 00:33:25,880
Don't add way too many
properties to objects.

822
00:33:25,880 --> 00:33:27,300
Keep it reasonable.

823
00:33:27,300 --> 00:33:30,310
Don't start changing the data
types your functions take.

824
00:33:30,310 --> 00:33:33,730
Try to make things type
stable and C like.

825
00:33:33,730 --> 00:33:36,980
Don't use functions that
are way too big.

826
00:33:36,980 --> 00:33:40,180
And in general, just as you
develop, keep an eye on what's

827
00:33:40,180 --> 00:33:41,140
going on in V8.

828
00:33:41,140 --> 00:33:44,270
Profile occasionally with
trace-deopt, trace-GC,

829
00:33:44,270 --> 00:33:50,140
trace-bailout, and see what's
going on and just keep an eye.

830
00:33:50,140 --> 00:33:51,700
Now the last thing.

831
00:33:51,700 --> 00:33:54,290
We'll talk about the
garbage collector.

832
00:33:54,290 --> 00:33:58,330
So JavaScript, of course, is a
garbage-collected language.

833
00:33:58,330 --> 00:34:02,660
And garbage collection hitches
are one of the very first

834
00:34:02,660 --> 00:34:05,200
performance problems I hear
people complaining about.

835
00:34:05,200 --> 00:34:08,290
When people write large-scale
JavaScript systems, one of the

836
00:34:08,290 --> 00:34:10,580
first things they come back
with is like, wow, we're

837
00:34:10,580 --> 00:34:12,570
getting this like sawtooth
performance curve.

838
00:34:12,570 --> 00:34:13,250
What's up with that?

839
00:34:13,250 --> 00:34:17,139
And that's the garbage
collector going.

840
00:34:17,139 --> 00:34:21,080
So V8's garbage collector is
a precise, incremental,

841
00:34:21,080 --> 00:34:23,020
generational garbage
collector.

842
00:34:23,020 --> 00:34:25,480
Of all those adjectives, the
one you really need to care

843
00:34:25,480 --> 00:34:28,170
about is generational, which
really just means there are

844
00:34:28,170 --> 00:34:31,360
two areas of memory,
two or more.

845
00:34:31,360 --> 00:34:32,320
There are actually more.

846
00:34:32,320 --> 00:34:35,270
But two areas of memory for
all intents and purposes.

847
00:34:35,270 --> 00:34:37,130
There is a small
area that's for

848
00:34:37,130 --> 00:34:38,250
really short-lived objects.

849
00:34:38,250 --> 00:34:41,340
And then, there's an area for
objects that are going to live

850
00:34:41,340 --> 00:34:43,590
a long time.

851
00:34:43,590 --> 00:34:45,650
And if you want to see what's
going on with the garbage

852
00:34:45,650 --> 00:34:48,940
collector, you could run again
a handy dandy V8 flag &mdash;

853
00:34:48,940 --> 00:34:49,659
trace-GC.

854
00:34:49,659 --> 00:34:51,790
And that will spew a bunch of
information about what's going

855
00:34:51,790 --> 00:34:56,159
on with the garbage collector
for your perusal.

856
00:34:56,159 --> 00:34:58,640
So if you're trying to make
an application that is

857
00:34:58,640 --> 00:35:00,870
garbage-collector friendly, one
of the things you should

858
00:35:00,870 --> 00:35:03,330
be aware of is that promotion
is expensive.

859
00:35:03,330 --> 00:35:03,960
So again, we have a

860
00:35:03,960 --> 00:35:05,240
generational garbage collector.

861
00:35:05,240 --> 00:35:07,750
So we have a young generation
and an older generation.

862
00:35:07,750 --> 00:35:11,730
And the promotion of objects
from the young to the old

863
00:35:11,730 --> 00:35:14,190
generation is expensive because
you're actually

864
00:35:14,190 --> 00:35:16,890
copying an object out of one
area of memory into another

865
00:35:16,890 --> 00:35:17,840
area of memory.

866
00:35:17,840 --> 00:35:21,110
So one of the worst things you
can do is you can have an

867
00:35:21,110 --> 00:35:23,520
object that lives just long
enough to get promoted, and

868
00:35:23,520 --> 00:35:25,300
then you forget about it.

869
00:35:25,300 --> 00:35:28,050
So you want, in general, either
objects that are going

870
00:35:28,050 --> 00:35:30,290
to live a very short time or
objects that are going to live

871
00:35:30,290 --> 00:35:31,120
a very long time.

872
00:35:31,120 --> 00:35:36,120
Medium-lived objects, you're
kind of wasting some time

873
00:35:36,120 --> 00:35:38,440
promoting them.

874
00:35:38,440 --> 00:35:42,810
The other thing you need to be
aware of is that in a system

875
00:35:42,810 --> 00:35:45,700
that is garbage collected, it's
very important that you

876
00:35:45,700 --> 00:35:47,880
release your references
to things.

877
00:35:47,880 --> 00:35:51,980
Pretty obvious, except for that
in JavaScript, you can

878
00:35:51,980 --> 00:35:53,590
have these large systems that
are sort of hard to tell

879
00:35:53,590 --> 00:35:54,420
what's going.

880
00:35:54,420 --> 00:35:57,040
Also, there are some tricky
things in JavaScript that can

881
00:35:57,040 --> 00:35:58,550
hold on to references for you.

882
00:35:58,550 --> 00:36:02,030
So for instance, execution
contexts and closures can both

883
00:36:02,030 --> 00:36:04,100
hold onto references
for objects and not

884
00:36:04,100 --> 00:36:05,070
let them get collected.

885
00:36:05,070 --> 00:36:07,300
So you need to be a little
careful with your JavaScript.

886
00:36:07,300 --> 00:36:11,120
Keep track of where all
your memory is.

887
00:36:11,120 --> 00:36:13,450
And then, the number one thing
you can do to make a

888
00:36:13,450 --> 00:36:15,470
garbage-collector friendly
application is to

889
00:36:15,470 --> 00:36:16,900
not generate garbage.

890
00:36:16,900 --> 00:36:20,110
And that will help you
avoid GC stalls.

891
00:36:20,110 --> 00:36:24,130
So the difficulty with that is
that most things are objects

892
00:36:24,130 --> 00:36:24,840
in JavaScript.

893
00:36:24,840 --> 00:36:27,370
Temp variables, closures, all of
this other kind of stuff is

894
00:36:27,370 --> 00:36:28,000
JavaScript.

895
00:36:28,000 --> 00:36:30,890
Very few things aren't.

896
00:36:30,890 --> 00:36:33,940
Small ints, for instance,
are one thing that is

897
00:36:33,940 --> 00:36:34,700
an immediate value.

898
00:36:34,700 --> 00:36:37,290
So that's another really good
reason to use small ints.

899
00:36:37,290 --> 00:36:39,780
Other than that, good rules of
thumb are to use scratch pads,

900
00:36:39,780 --> 00:36:44,100
sort of reuse variables between
functions, and to

901
00:36:44,100 --> 00:36:46,690
update things in place
where you can.

902
00:36:46,690 --> 00:36:49,870
So, for instance, this is an
example of a classic bad idea.

903
00:36:49,870 --> 00:36:52,170
So it's just a simple
vector add function.

904
00:36:52,170 --> 00:36:53,200
One of the first things
you're going to

905
00:36:53,200 --> 00:36:54,590
need is a math library.

906
00:36:54,590 --> 00:36:57,460
You might think that this was a
good way to write it, except

907
00:36:57,460 --> 00:36:59,900
for that this actually allocates
a brand new vector

908
00:36:59,900 --> 00:37:02,080
object every time you try to
do a vector add, which is

909
00:37:02,080 --> 00:37:03,460
going to be often.

910
00:37:03,460 --> 00:37:05,500
So that's going to be really,
really garbage-collector

911
00:37:05,500 --> 00:37:07,300
unfriendly.

912
00:37:07,300 --> 00:37:08,670
This is a much better
way to write it.

913
00:37:08,670 --> 00:37:11,930
I actually much prefer
the first syntax.

914
00:37:11,930 --> 00:37:14,310
But this is a much better way to
write it in the context of

915
00:37:14,310 --> 00:37:16,540
a garbage collector where
you actually add

916
00:37:16,540 --> 00:37:17,510
to the first vector.

917
00:37:17,510 --> 00:37:19,490
You just update the first
vector in place.

918
00:37:19,490 --> 00:37:21,920
You don't allocate
a new object.

919
00:37:21,920 --> 00:37:24,410
So this is going to
work a lot better.

920
00:37:24,410 --> 00:37:27,680
Subtle point here is that if
you're working with doubles

921
00:37:27,680 --> 00:37:32,270
again, you might be boxing and
allocating new heap numbers.

922
00:37:32,270 --> 00:37:33,870
So this might create
some garbage

923
00:37:33,870 --> 00:37:34,920
collector pressure anyway.

924
00:37:34,920 --> 00:37:36,210
But it's still going
to be much better.

925
00:37:36,210 --> 00:37:38,900

926
00:37:38,900 --> 00:37:41,710
So now you know how to write a
high-performance JavaScript

927
00:37:41,710 --> 00:37:42,260
application.

928
00:37:42,260 --> 00:37:45,120
Or hopefully, you have some
intuition as to what might be

929
00:37:45,120 --> 00:37:47,510
fast, what might be slow, and
how to check whether things

930
00:37:47,510 --> 00:37:49,350
are going well or not
in your JavaScript.

931
00:37:49,350 --> 00:37:50,610
That's awesome.

932
00:37:50,610 --> 00:37:53,470
Now, we have to take that
application and put it Chrome

933
00:37:53,470 --> 00:37:55,240
in the context of Chrome
where all this other

934
00:37:55,240 --> 00:37:55,950
stuff is going on.

935
00:37:55,950 --> 00:37:58,700
So let's talk about that.

936
00:37:58,700 --> 00:38:00,480
So first of all, when you're
in Chrome or when you're in

937
00:38:00,480 --> 00:38:04,490
any browser, it's just very
different than being on a PC

938
00:38:04,490 --> 00:38:05,050
or a console.

939
00:38:05,050 --> 00:38:06,810
There's a lot of stuff
you don't know.

940
00:38:06,810 --> 00:38:09,730
You don't know what
browser you're in.

941
00:38:09,730 --> 00:38:12,590
And different browsers, they
have different performance

942
00:38:12,590 --> 00:38:14,100
profiles for different
operations.

943
00:38:14,100 --> 00:38:17,080
And also, they support
different HTML5 API.

944
00:38:17,080 --> 00:38:19,780
So every single thing you do,
you need to check whether it's

945
00:38:19,780 --> 00:38:22,090
supported here.

946
00:38:22,090 --> 00:38:23,840
You don't know anything about
the local hardware.

947
00:38:23,840 --> 00:38:26,730
And this is a really hard one
for people to get their head

948
00:38:26,730 --> 00:38:29,370
around how important this is.

949
00:38:29,370 --> 00:38:32,210
Most game developers who are
coming from the console PC

950
00:38:32,210 --> 00:38:36,330
space have never had to deal
with a range of hardware so

951
00:38:36,330 --> 00:38:39,340
broad as you have
to for the web.

952
00:38:39,340 --> 00:38:42,630
Everything from a five-year-old
phone to the

953
00:38:42,630 --> 00:38:45,420
latest and greatest desktop
system of today, that's the

954
00:38:45,420 --> 00:38:48,920
range of things that
can run HTML5.

955
00:38:48,920 --> 00:38:51,220
And so you can get these huge
performance differences, which

956
00:38:51,220 --> 00:38:55,200
means that it's very important
that you do a lot of checking

957
00:38:55,200 --> 00:38:59,410
in your code about what the
local system can handle.

958
00:38:59,410 --> 00:39:00,590
Another thing you have
to know is that your

959
00:39:00,590 --> 00:39:02,060
game lives in a tab.

960
00:39:02,060 --> 00:39:03,520
What does that mean to you?

961
00:39:03,520 --> 00:39:05,740
It means that that tab can
actually close at any time.

962
00:39:05,740 --> 00:39:06,580
Now, this is always true.

963
00:39:06,580 --> 00:39:09,630
If you're writing a console
game, the user can walk up and

964
00:39:09,630 --> 00:39:11,340
hit the power button
on the console.

965
00:39:11,340 --> 00:39:14,320
That's always an issue, except
for that the way people

966
00:39:14,320 --> 00:39:17,260
interact with tabs in a browser
is far more ephemeral.

967
00:39:17,260 --> 00:39:19,610
It's very normal for somebody
to be playing a web game and

968
00:39:19,610 --> 00:39:21,840
then be like, oh, I want to
check email and just close

969
00:39:21,840 --> 00:39:22,800
that tab down.

970
00:39:22,800 --> 00:39:25,040
And this is important for you
to know, because if you're

971
00:39:25,040 --> 00:39:27,610
writing files to local cache or
something like that, you're

972
00:39:27,610 --> 00:39:29,340
going to have to be very careful
that you're ready to

973
00:39:29,340 --> 00:39:32,600
be shut down at any time.

974
00:39:32,600 --> 00:39:34,260
There might be other
applications running in your

975
00:39:34,260 --> 00:39:34,910
same thread.

976
00:39:34,910 --> 00:39:37,240
Here, I'm talking about
Chrome specifically.

977
00:39:37,240 --> 00:39:39,950
So you might not have the whole
thread to work with.

978
00:39:39,950 --> 00:39:42,230
And there's this other
compositing and rendering

979
00:39:42,230 --> 00:39:44,840
cycle that's going around your
game that's making the whole

980
00:39:44,840 --> 00:39:46,090
web page itself.

981
00:39:46,090 --> 00:39:49,070
And so you need to fit
into that as well.

982
00:39:49,070 --> 00:39:51,380
So let's talk about this
local hardware thing.

983
00:39:51,380 --> 00:39:53,980
So you know nothing about
the local environment.

984
00:39:53,980 --> 00:39:56,100
And I know I just said
this, but I really

985
00:39:56,100 --> 00:39:58,150
can't stress it enough.

986
00:39:58,150 --> 00:40:01,660
Because of privacy concerns,
there's nothing in JavaScript

987
00:40:01,660 --> 00:40:04,200
that allows you to ask detailed
questions about a

988
00:40:04,200 --> 00:40:05,180
user's local machine.

989
00:40:05,180 --> 00:40:07,320
So there's no way that
you can ask what kind

990
00:40:07,320 --> 00:40:08,370
of hardware is this?

991
00:40:08,370 --> 00:40:09,860
What can it support?

992
00:40:09,860 --> 00:40:12,270
So you're just in charge
of being able to

993
00:40:12,270 --> 00:40:14,780
scale on your own.

994
00:40:14,780 --> 00:40:16,330
And in the PC world,
this is not a

995
00:40:16,330 --> 00:40:18,850
problem because PC games &mdash;

996
00:40:18,850 --> 00:40:20,520
console games don't have this
problem to begin with.

997
00:40:20,520 --> 00:40:23,660
PC games specifically say
on them what the system

998
00:40:23,660 --> 00:40:24,370
requirements are.

999
00:40:24,370 --> 00:40:25,290
And everybody's used to that.

1000
00:40:25,290 --> 00:40:27,740
Everybody's happy with that.

1001
00:40:27,740 --> 00:40:31,120
On the web, people have this
expectation that everything be

1002
00:40:31,120 --> 00:40:33,170
lowest common denominator,
which is a

1003
00:40:33,170 --> 00:40:34,000
blessing and a curse.

1004
00:40:34,000 --> 00:40:35,760
I love that you get broad
distribution.

1005
00:40:35,760 --> 00:40:38,680
However, it makes it really
hard if you're trying to

1006
00:40:38,680 --> 00:40:40,580
target the high end.

1007
00:40:40,580 --> 00:40:43,640
And so what you can do that
this is just be very, very

1008
00:40:43,640 --> 00:40:46,590
clear with your users about
how your game will run on

1009
00:40:46,590 --> 00:40:47,390
their machine.

1010
00:40:47,390 --> 00:40:50,560
The last thing you want is to
have your users buy your game

1011
00:40:50,560 --> 00:40:53,520
from some web app store, the
Chrome Web Store, for

1012
00:40:53,520 --> 00:40:56,760
instance, and try to play it,
and then find that it doesn't

1013
00:40:56,760 --> 00:40:59,290
run, or it runs at 5 FPS or
whatever, because they're

1014
00:40:59,290 --> 00:41:00,740
running on very old hardware.

1015
00:41:00,740 --> 00:41:02,120
And then, they give you
a one-star review.

1016
00:41:02,120 --> 00:41:03,050
They're like, this game sucks.

1017
00:41:03,050 --> 00:41:03,730
I can't run it.

1018
00:41:03,730 --> 00:41:07,180
So you really, really need to
be communicating proactively

1019
00:41:07,180 --> 00:41:08,790
with your users about
what they can

1020
00:41:08,790 --> 00:41:09,770
expect from your game.

1021
00:41:09,770 --> 00:41:10,810
I can't stress that enough.

1022
00:41:10,810 --> 00:41:14,610
It's like really important
for end-user experience.

1023
00:41:14,610 --> 00:41:16,950
Also, if you can, you want
graceful degradation where

1024
00:41:16,950 --> 00:41:18,080
it's not just a binary thing.

1025
00:41:18,080 --> 00:41:20,840
You want to be able to make your
games gracefully scaled

1026
00:41:20,840 --> 00:41:24,320
down to fit on lower-end
hardware.

1027
00:41:24,320 --> 00:41:26,320
So one thing you can do
to that end is micro

1028
00:41:26,320 --> 00:41:27,230
benchmarking.

1029
00:41:27,230 --> 00:41:28,760
And so this is where
you, yourself &mdash;

1030
00:41:28,760 --> 00:41:29,950
again, it's all home brew.

1031
00:41:29,950 --> 00:41:31,550
Nothing in the JavaScript
standards helps you.

1032
00:41:31,550 --> 00:41:34,550
But you, yourself, write little
benchmarks that stress

1033
00:41:34,550 --> 00:41:37,370
what your game is going
to stress and

1034
00:41:37,370 --> 00:41:38,350
collects data about that.

1035
00:41:38,350 --> 00:41:41,290
So maybe, during your loading
screen, you run a bunch of

1036
00:41:41,290 --> 00:41:44,410
tests, get a feeling about what
the local system is, and

1037
00:41:44,410 --> 00:41:47,560
then suggest settings or send
that data back to your service

1038
00:41:47,560 --> 00:41:48,660
for analysis.

1039
00:41:48,660 --> 00:41:52,340
Or while the game is running,
you see what the FPS is and

1040
00:41:52,340 --> 00:41:54,980
adjust accordingly or take
data accordingly.

1041
00:41:54,980 --> 00:41:57,100
But you really need to
be proactive about

1042
00:41:57,100 --> 00:41:59,750
collecting this data.

1043
00:41:59,750 --> 00:42:02,570
And that's pretty much it for
dealing with the hardware

1044
00:42:02,570 --> 00:42:04,960
variation you're going to
find in HTML5 games.

1045
00:42:04,960 --> 00:42:08,190
Collect data, communicate, and
make sure, above all, that you

1046
00:42:08,190 --> 00:42:10,185
set your users' expectations
appropriately.

1047
00:42:10,185 --> 00:42:13,180

1048
00:42:13,180 --> 00:42:16,110
So up until now, I've been
talking about HTML5

1049
00:42:16,110 --> 00:42:16,920
specifications.

1050
00:42:16,920 --> 00:42:19,700
I've been talking about how to
make JavaScript fast. Those

1051
00:42:19,700 --> 00:42:20,950
things all live within V8.

1052
00:42:20,950 --> 00:42:23,350
So here, we're talking about
things that live in V8.

1053
00:42:23,350 --> 00:42:25,740
Let's talk about what
goes around that.

1054
00:42:25,740 --> 00:42:29,400
So V8 lives in WebKit alongside
CSS and HTML.

1055
00:42:29,400 --> 00:42:33,570
So the same way V8 executes
JavaScript, there's another

1056
00:42:33,570 --> 00:42:37,140
machine for HTML and another
system for CSS.

1057
00:42:37,140 --> 00:42:39,450
All of those things
live side by side.

1058
00:42:39,450 --> 00:42:42,010
When they want to render things,
any one of those

1059
00:42:42,010 --> 00:42:44,480
things can send commands
on this RPC

1060
00:42:44,480 --> 00:42:47,220
buffer to the GPU process.

1061
00:42:47,220 --> 00:42:50,430
All rendering in Chrome is done
in a separate process

1062
00:42:50,430 --> 00:42:53,190
entirely, not just a separate
thread, a separate process.

1063
00:42:53,190 --> 00:42:56,040
And it's done on a separate
process for security reasons.

1064
00:42:56,040 --> 00:42:59,570
And so this structure is very
important to understand

1065
00:42:59,570 --> 00:43:01,670
because you're sharing this
RPC buffer with everything

1066
00:43:01,670 --> 00:43:04,310
else that's trying to
render anything.

1067
00:43:04,310 --> 00:43:07,400
Then from the GPU process, it'll
actually communicate

1068
00:43:07,400 --> 00:43:09,600
with the drivers and the
hardware itself to do the

1069
00:43:09,600 --> 00:43:10,780
actual rendering.

1070
00:43:10,780 --> 00:43:13,130
But there are a couple of
additional pieces of

1071
00:43:13,130 --> 00:43:14,150
complexity here.

1072
00:43:14,150 --> 00:43:17,610
One is that on Windows where
you don't have good OpenGL

1073
00:43:17,610 --> 00:43:20,090
drivers, there's this layer
called ANGLE, Almost Native

1074
00:43:20,090 --> 00:43:21,240
Graphics Layer Engine.

1075
00:43:21,240 --> 00:43:24,930
And that will do a translation
from OpenGL to DirectX.

1076
00:43:24,930 --> 00:43:26,760
And then, there's this other
translation layer called

1077
00:43:26,760 --> 00:43:27,380
SwiftShader.

1078
00:43:27,380 --> 00:43:30,330
So on machines that don't have
good drivers or drivers that

1079
00:43:30,330 --> 00:43:33,660
are good enough for WebGL,
SwiftShader will actually do

1080
00:43:33,660 --> 00:43:34,770
software rasterization.

1081
00:43:34,770 --> 00:43:38,000
So there's all this complexity
from your game on down into

1082
00:43:38,000 --> 00:43:38,950
the actual rendering.

1083
00:43:38,950 --> 00:43:41,200
So let's talk about that.

1084
00:43:41,200 --> 00:43:45,050
So first, let's talk about
the RPC buffer part.

1085
00:43:45,050 --> 00:43:47,830
So if you remember way back
when I was talking about

1086
00:43:47,830 --> 00:43:50,210
WebGL, I mentioned that
certain commands have

1087
00:43:50,210 --> 00:43:52,600
unexpectedly slow performance.

1088
00:43:52,600 --> 00:43:54,730
And those are anything that
starts with "read," anything

1089
00:43:54,730 --> 00:43:57,680
that starts with "get," these
things that require round

1090
00:43:57,680 --> 00:43:59,110
trips to the GPU.

1091
00:43:59,110 --> 00:44:01,540
And now that you understand that
there's an RPC buffer in

1092
00:44:01,540 --> 00:44:03,810
there and rendering is done on a
separate process, I'm hoping

1093
00:44:03,810 --> 00:44:05,850
that you'll have some intuition
for why that is and

1094
00:44:05,850 --> 00:44:07,970
what sorts of command
might be slow.

1095
00:44:07,970 --> 00:44:11,820
So besides that, the other thing
you have to know about

1096
00:44:11,820 --> 00:44:13,750
that buffer is that
it's shared, and

1097
00:44:13,750 --> 00:44:15,210
it's limited in size.

1098
00:44:15,210 --> 00:44:18,520
So there's a specific size
limit on that buffer.

1099
00:44:18,520 --> 00:44:21,970
And all the resources that you
upload to the GPU are going to

1100
00:44:21,970 --> 00:44:22,980
eat up that size.

1101
00:44:22,980 --> 00:44:25,680
And it's total size of
resources, not total of number

1102
00:44:25,680 --> 00:44:26,280
of resources.

1103
00:44:26,280 --> 00:44:27,950
But all your textures, all
your buffers, all your

1104
00:44:27,950 --> 00:44:29,150
commands, they're all
going to go into the

1105
00:44:29,150 --> 00:44:31,890
budget for that buffer.

1106
00:44:31,890 --> 00:44:36,690
And if you go over that buffer
size, then you're going to

1107
00:44:36,690 --> 00:44:39,000
trigger something called a sink
flush, which is slow.

1108
00:44:39,000 --> 00:44:40,350
And it's going to amount
to a stall.

1109
00:44:40,350 --> 00:44:42,350
So that means that you're trying
to send another command

1110
00:44:42,350 --> 00:44:43,430
on that buffer.

1111
00:44:43,430 --> 00:44:44,650
But the buffer is
already full.

1112
00:44:44,650 --> 00:44:46,730
And so the buffer is like,
ah, no room for that.

1113
00:44:46,730 --> 00:44:49,200
So I have to stop and actually
process through the whole

1114
00:44:49,200 --> 00:44:50,910
thing, have to flush everything
out before I can

1115
00:44:50,910 --> 00:44:52,430
process this new command.

1116
00:44:52,430 --> 00:44:56,750
And what that's going to look
like to you is that suddenly,

1117
00:44:56,750 --> 00:44:58,870
one of the commands you're
sending to OpenGL is going to

1118
00:44:58,870 --> 00:45:01,420
look like it takes a really
long time for no reason in

1119
00:45:01,420 --> 00:45:02,170
your profiling view.

1120
00:45:02,170 --> 00:45:04,690
You're like, wow, that command
was always perfectly fine, and

1121
00:45:04,690 --> 00:45:06,430
now, it's taking 40
milliseconds.

1122
00:45:06,430 --> 00:45:08,650
And that's because you spilled
the buffer, and you triggered

1123
00:45:08,650 --> 00:45:10,920
a sink flush.

1124
00:45:10,920 --> 00:45:14,250
So really, the only thing you
can do here is try to amortize

1125
00:45:14,250 --> 00:45:16,100
the cost of uploading
across frames.

1126
00:45:16,100 --> 00:45:17,920
So just try to limit what
you do per frame.

1127
00:45:17,920 --> 00:45:20,750
If you see these big stalls, you
can have an intuition that

1128
00:45:20,750 --> 00:45:23,950
you're probably or might be
spilling that buffer and act

1129
00:45:23,950 --> 00:45:25,410
accordingly.

1130
00:45:25,410 --> 00:45:27,760
One note here is that when I
talked about this with the

1131
00:45:27,760 --> 00:45:30,490
Chrome GPU team, they said yes,
this is true for now.

1132
00:45:30,490 --> 00:45:31,500
This is good information.

1133
00:45:31,500 --> 00:45:33,060
But this is something
that's subject to

1134
00:45:33,060 --> 00:45:34,080
change in the future.

1135
00:45:34,080 --> 00:45:35,900
So keep checking back in
with this assumption.

1136
00:45:35,900 --> 00:45:40,480
Hopefully, this will get better,
that this problem of

1137
00:45:40,480 --> 00:45:42,150
causing sink flushes won't be
a problem in the future.

1138
00:45:42,150 --> 00:45:46,170
But for now, this
is good advice.

1139
00:45:46,170 --> 00:45:49,050
So now, let's talk about the
close to the hardware type

1140
00:45:49,050 --> 00:45:51,240
part of the system.

1141
00:45:51,240 --> 00:45:53,660
So what do you need to
know about drivers?

1142
00:45:53,660 --> 00:45:57,150
Really just that they're
there, and that not all

1143
00:45:57,150 --> 00:45:58,410
drivers are secure.

1144
00:45:58,410 --> 00:46:01,950
Not all drivers are stable
for use with WebGL.

1145
00:46:01,950 --> 00:46:04,770
And that means in order to
keep people's browsing

1146
00:46:04,770 --> 00:46:08,550
experiences secure and stable,
that many or some drivers are

1147
00:46:08,550 --> 00:46:10,180
blacklisted.

1148
00:46:10,180 --> 00:46:12,930
So sometimes, people running
on a computer that is

1149
00:46:12,930 --> 00:46:15,360
perfectly a &mdash; computer and
browser perfectly capable of

1150
00:46:15,360 --> 00:46:19,560
playing your game will not be
able to use WebGL because

1151
00:46:19,560 --> 00:46:21,580
their drivers are blacklisted.

1152
00:46:21,580 --> 00:46:25,520
And unfortunately, the only way
to test whether the local

1153
00:46:25,520 --> 00:46:29,630
machine is capable of running
WebGL is by actually trying to

1154
00:46:29,630 --> 00:46:31,660
create a context and
seeing if it fails.

1155
00:46:31,660 --> 00:46:33,770
So the first thing you do when
you're making a WebGL

1156
00:46:33,770 --> 00:46:35,910
application is make
a WebGL context.

1157
00:46:35,910 --> 00:46:38,560
And you really just have to try
it, see if it works, and

1158
00:46:38,560 --> 00:46:39,880
then handle accordingly.

1159
00:46:39,880 --> 00:46:43,360
There's no more elegant
way than that.

1160
00:46:43,360 --> 00:46:46,590
The other thing I mentioned is
this Almost Native Graphics

1161
00:46:46,590 --> 00:46:50,520
Layer Engine, which in response
to the fact that, in

1162
00:46:50,520 --> 00:46:53,780
general, DirectX rendering works
better on Windows than

1163
00:46:53,780 --> 00:46:57,330
OpenGL rendering, or rather,
OpenGL drivers for Windows

1164
00:46:57,330 --> 00:47:00,880
tend to be somewhat buggy or
unstable, there's this layer

1165
00:47:00,880 --> 00:47:03,850
called ANGLE, which will
translate your OpenGL calls

1166
00:47:03,850 --> 00:47:07,370
into DirectX before rendering
on Windows only.

1167
00:47:07,370 --> 00:47:10,000
Hopefully, you never need
to know about this.

1168
00:47:10,000 --> 00:47:11,220
It's just sort of trivia.

1169
00:47:11,220 --> 00:47:14,870
But it's good for you to know
that it's there just in case.

1170
00:47:14,870 --> 00:47:16,610
And then, finally, we
have SwiftShader.

1171
00:47:16,610 --> 00:47:18,850
Again, this is software
rasterization.

1172
00:47:18,850 --> 00:47:24,060
So if you have a system that's
capable of running your game,

1173
00:47:24,060 --> 00:47:27,030
but for some reason, their
drivers don't work, then you

1174
00:47:27,030 --> 00:47:29,270
might get SwiftShader,
SwiftShader software

1175
00:47:29,270 --> 00:47:30,950
rasterization.

1176
00:47:30,950 --> 00:47:34,130
Now, this is just another case
where you're going to have to

1177
00:47:34,130 --> 00:47:36,660
be really proactive about
judging the performance of the

1178
00:47:36,660 --> 00:47:39,000
local machine, because, of
course, software rasterization

1179
00:47:39,000 --> 00:47:41,550
is going to be nowhere
near as performant as

1180
00:47:41,550 --> 00:47:44,070
hardware-accelerated OpenGL.

1181
00:47:44,070 --> 00:47:46,400
So you need to be really careful
that you're catching

1182
00:47:46,400 --> 00:47:49,290
these cases, and testing the
performance, and degrading

1183
00:47:49,290 --> 00:47:51,700
appropriately, or informing
the user appropriately.

1184
00:47:51,700 --> 00:47:54,770
Again, you never had any
guarantees about software

1185
00:47:54,770 --> 00:47:56,310
rasterization or not.

1186
00:47:56,310 --> 00:47:59,040
It could always have been a
10-year-old graphics card.

1187
00:47:59,040 --> 00:48:01,110
Now, you have software
rasterization in the mix.

1188
00:48:01,110 --> 00:48:05,530
That just hammers home that
point a little bit harder.

1189
00:48:05,530 --> 00:48:08,940
So let's talk about your
rendering loop for your game.

1190
00:48:08,940 --> 00:48:12,800
So old-style JavaScript, the
way you would do periodic

1191
00:48:12,800 --> 00:48:16,020
function calls are with these
two methods, setInterval and

1192
00:48:16,020 --> 00:48:17,140
setTimeout.

1193
00:48:17,140 --> 00:48:19,940
But the problem with those is
that there's no way to tell

1194
00:48:19,940 --> 00:48:20,980
the browser what you're doing.

1195
00:48:20,980 --> 00:48:24,040
And again, much like we were
seeing with the V8 case when

1196
00:48:24,040 --> 00:48:26,130
we were talking about performant
JavaScript,

1197
00:48:26,130 --> 00:48:28,060
performant rendering in general,
being performant in

1198
00:48:28,060 --> 00:48:31,680
general, is about being able
to inform the system what

1199
00:48:31,680 --> 00:48:34,590
you're doing in specific
terms so that it can

1200
00:48:34,590 --> 00:48:36,420
optimize around you.

1201
00:48:36,420 --> 00:48:38,780
SetInterval and setTimeout are
not specific about what

1202
00:48:38,780 --> 00:48:39,170
they're doing.

1203
00:48:39,170 --> 00:48:40,670
They could be doing anything.

1204
00:48:40,670 --> 00:48:42,270
We don't know that this
is an animation.

1205
00:48:42,270 --> 00:48:44,200
So the browser can't do
anything to help you.

1206
00:48:44,200 --> 00:48:46,400
And that's why they're
bad ideas.

1207
00:48:46,400 --> 00:48:50,270
Instead, there's this nice API
in the HTML5 family of APIs

1208
00:48:50,270 --> 00:48:51,820
called RequestAnimationFrame.

1209
00:48:51,820 --> 00:48:56,060
And this is a way to do periodic
rendering in a way

1210
00:48:56,060 --> 00:48:58,890
that tells the browser exactly
what you mean.

1211
00:48:58,890 --> 00:49:02,590
So RequestAnimationFrame will
try to call at 60 hertz, and

1212
00:49:02,590 --> 00:49:07,420
it'll adapts down if you can't
actually call at 60 hertz.

1213
00:49:07,420 --> 00:49:08,530
It'll never call faster
than that.

1214
00:49:08,530 --> 00:49:10,486
But it'll call slower
if it needs to.

1215
00:49:10,486 --> 00:49:15,260

1216
00:49:15,260 --> 00:49:18,660
So because the
RequestAnimationFrame callback

1217
00:49:18,660 --> 00:49:21,260
is always going to be scaling
its performance to how long

1218
00:49:21,260 --> 00:49:25,550
your frames are taking, if you
can't run at 60 hertz, then

1219
00:49:25,550 --> 00:49:27,850
your frame rate's going to go
a little jaggy, because it's

1220
00:49:27,850 --> 00:49:32,620
going to be based on how long
one of the recent frames took.

1221
00:49:32,620 --> 00:49:35,010
And so if you don't want your
frame rate to wander, you need

1222
00:49:35,010 --> 00:49:37,430
to clamp it to either
60 or 30.

1223
00:49:37,430 --> 00:49:39,750
If you're trying to clamp your
frame rate to 30, what you do

1224
00:49:39,750 --> 00:49:41,120
is just the simplest
thing possible.

1225
00:49:41,120 --> 00:49:43,570
You're just going to manually
skip frames by making a

1226
00:49:43,570 --> 00:49:45,785
counter that counts up, and you
render on even frames and

1227
00:49:45,785 --> 00:49:48,200
not on odd frames,
or whatever.

1228
00:49:48,200 --> 00:49:52,030
So that's what you want to do
if having a jaggy frame rate

1229
00:49:52,030 --> 00:49:54,250
bothers you.

1230
00:49:54,250 --> 00:49:56,220
And the other thing that
RequestAnimationFrame can do

1231
00:49:56,220 --> 00:50:01,000
for you, because it knows that
you are animating, it can feed

1232
00:50:01,000 --> 00:50:02,870
Chrome's rendering pipeline
with your data at

1233
00:50:02,870 --> 00:50:04,120
a consistent rate.

1234
00:50:04,120 --> 00:50:08,470
And it can adapt the work you do
on the GPU and CPU to make

1235
00:50:08,470 --> 00:50:10,790
sure that you're not just
throwing a bunch of commands

1236
00:50:10,790 --> 00:50:12,740
over the wall that you could
never possibly render on the

1237
00:50:12,740 --> 00:50:15,500
GPU, that you're not totally
swamping everything.

1238
00:50:15,500 --> 00:50:15,880
That's what

1239
00:50:15,880 --> 00:50:17,170
RequestAnimationFrame gives you.

1240
00:50:17,170 --> 00:50:20,180

1241
00:50:20,180 --> 00:50:21,630
So this is a typical
game loop.

1242
00:50:21,630 --> 00:50:24,070
You have update, render, swap,
update, render, swap.

1243
00:50:24,070 --> 00:50:26,720
That's pretty normal, you know,
while true, do this.

1244
00:50:26,720 --> 00:50:28,610
That's a game.

1245
00:50:28,610 --> 00:50:29,770
This is the way it
fits into Chrome.

1246
00:50:29,770 --> 00:50:31,410
So you have
RequestAnimationFrame, which

1247
00:50:31,410 --> 00:50:32,710
is your JavaScript code.

1248
00:50:32,710 --> 00:50:36,230
You have composite, which Chrome
takes care of that.

1249
00:50:36,230 --> 00:50:38,160
That's where everything is
smooshed together and rendered

1250
00:50:38,160 --> 00:50:41,110
on the screen, and then, you
have a swap as well.

1251
00:50:41,110 --> 00:50:43,590
So that loop is going on if you
have the main loop of your

1252
00:50:43,590 --> 00:50:45,030
game in there.

1253
00:50:45,030 --> 00:50:47,330
If you didn't have that, the
browser would just go back to

1254
00:50:47,330 --> 00:50:48,810
idle and sit idly.

1255
00:50:48,810 --> 00:50:51,640
User input can also cause a
screen dirty, which causes a

1256
00:50:51,640 --> 00:50:54,190
composite, which causes a swap,
which then either goes

1257
00:50:54,190 --> 00:50:55,570
back to idle or goes
back into your

1258
00:50:55,570 --> 00:50:56,820
RequestAnimationFrame loop.

1259
00:50:56,820 --> 00:51:02,070

1260
00:51:02,070 --> 00:51:04,940
So now, let's talk about
the life of a frame.

1261
00:51:04,940 --> 00:51:10,310
So the way frames work in
Chrome is that we have

1262
00:51:10,310 --> 00:51:11,490
RequestAnimationFrame calls.

1263
00:51:11,490 --> 00:51:16,050
So first thing that's done is
that your JavaScript in your

1264
00:51:16,050 --> 00:51:18,660
RequestAnimationFrame
call is executed.

1265
00:51:18,660 --> 00:51:21,470
And during that JavaScript,
it'll kick off a bunch of

1266
00:51:21,470 --> 00:51:23,790
calls that result in commands
on the GPU.

1267
00:51:23,790 --> 00:51:25,920
So you're going to kick off
commands down that RPC buffer

1268
00:51:25,920 --> 00:51:28,420
that are going to go on to this
other rendering process.

1269
00:51:28,420 --> 00:51:31,530
When all your JavaScript is
completed, and all your GPU

1270
00:51:31,530 --> 00:51:34,540
work is completed, you have all
the information you need,

1271
00:51:34,540 --> 00:51:36,950
so you can composite the whole
frame together, and

1272
00:51:36,950 --> 00:51:38,220
you could do a swap.

1273
00:51:38,220 --> 00:51:40,140
So that's the general cycle.

1274
00:51:40,140 --> 00:51:43,860
You do your JavaScript
callback, which kicks

1275
00:51:43,860 --> 00:51:44,870
off your GPU work.

1276
00:51:44,870 --> 00:51:47,040
When all that's done,
you can composite.

1277
00:51:47,040 --> 00:51:48,660
And then you just wait out
the rest of the frame.

1278
00:51:48,660 --> 00:51:55,160
If your frame is under 16
milliseconds, it'll just wait

1279
00:51:55,160 --> 00:51:57,600
until the next call of
RequestAnimationFrame.

1280
00:51:57,600 --> 00:52:01,320
So yes, it just keeps
on like that.

1281
00:52:01,320 --> 00:52:04,180
So in that diagram I showed
you before about how all

1282
00:52:04,180 --> 00:52:06,370
things fit together, one thing
I left out is user input.

1283
00:52:06,370 --> 00:52:10,440
So I want to talk a little
bit about user input now.

1284
00:52:10,440 --> 00:52:14,250
One really important thing you
need to know is that while

1285
00:52:14,250 --> 00:52:19,070
your main JavaScript thread
is busy, input is queued.

1286
00:52:19,070 --> 00:52:21,620
And that can introduce
a lot of input

1287
00:52:21,620 --> 00:52:23,780
latency into your code.

1288
00:52:23,780 --> 00:52:25,920
So let me talk about how
that actually works.

1289
00:52:25,920 --> 00:52:29,550
So here we have a diagram
similar to before, so it's

1290
00:52:29,550 --> 00:52:30,990
showing a series of frames.

1291
00:52:30,990 --> 00:52:33,100
First, you do your
JavaScript work.

1292
00:52:33,100 --> 00:52:35,140
Then you do your GPU work.

1293
00:52:35,140 --> 00:52:37,450
And you just keep doing that.

1294
00:52:37,450 --> 00:52:41,190
If during my JavaScript work
I get a bunch of mouse move

1295
00:52:41,190 --> 00:52:43,600
events, I'm not going to
hear them right away.

1296
00:52:43,600 --> 00:52:46,300
I can't hear them while the
main thread is busy.

1297
00:52:46,300 --> 00:52:48,530
And they came in when the
main thread is busy.

1298
00:52:48,530 --> 00:52:52,140
Once the JavaScript execution
is done, you're eligible to

1299
00:52:52,140 --> 00:52:53,540
hear a mouse event.

1300
00:52:53,540 --> 00:52:54,960
So here, in this case,
I'm going to

1301
00:52:54,960 --> 00:52:57,120
hear this most freshest &mdash;

1302
00:52:57,120 --> 00:53:00,170
most recent, freshest
mouse click.

1303
00:53:00,170 --> 00:53:03,330
Then during the next frame,
now I've got a m event.

1304
00:53:03,330 --> 00:53:06,070
Now I'm eligible during the
next frame to process that

1305
00:53:06,070 --> 00:53:07,040
mouse event.

1306
00:53:07,040 --> 00:53:08,830
And then at the very end
of the next frame when

1307
00:53:08,830 --> 00:53:11,550
everything's rendered, the
result of that mouse input can

1308
00:53:11,550 --> 00:53:13,210
get rendered.

1309
00:53:13,210 --> 00:53:15,840
And so you can see, especially
with this queuing delay, where

1310
00:53:15,840 --> 00:53:18,270
if events come in while the main
thread is busy, they just

1311
00:53:18,270 --> 00:53:21,950
get queued up, and you can't
hear them until later, you can

1312
00:53:21,950 --> 00:53:24,420
have a lot of input latency.

1313
00:53:24,420 --> 00:53:27,940
The rule of thumb is that your
input latency is going to be

1314
00:53:27,940 --> 00:53:30,990
approximately twice
your frame length.

1315
00:53:30,990 --> 00:53:34,480
So if these are 16-millisecond
frames, then the maximum input

1316
00:53:34,480 --> 00:53:38,020
latency you can get if you're
unlucky is 32 milliseconds,

1317
00:53:38,020 --> 00:53:39,420
which is a hell of
a lot of latency.

1318
00:53:39,420 --> 00:53:41,470
But that's sort of the system
that you live in.

1319
00:53:41,470 --> 00:53:44,300
So you just have to be ready
to deal with that.

1320
00:53:44,300 --> 00:53:47,240
The other thing you can do to
help yourself is to move work

1321
00:53:47,240 --> 00:53:48,290
off the main thread.

1322
00:53:48,290 --> 00:53:50,530
So moving work to
the GPU is good.

1323
00:53:50,530 --> 00:53:52,750
Moving work to web
workers is good.

1324
00:53:52,750 --> 00:53:55,570
Anything that helps you free up
the main thread to be able

1325
00:53:55,570 --> 00:53:58,960
to receive user input
is good for you.

1326
00:53:58,960 --> 00:54:01,580

1327
00:54:01,580 --> 00:54:04,770
So one more thing to talk about
user input is that one

1328
00:54:04,770 --> 00:54:07,210
of the really important things
that RequestAnimationFrame

1329
00:54:07,210 --> 00:54:10,660
does is it allows Chrome
to schedule your work

1330
00:54:10,660 --> 00:54:11,560
accordingly.

1331
00:54:11,560 --> 00:54:14,350
So again, we see the same
simplified version of the

1332
00:54:14,350 --> 00:54:16,440
diagram we've been looking at
where you have your work, and

1333
00:54:16,440 --> 00:54:17,910
then Chrome's work,
and then wait.

1334
00:54:17,910 --> 00:54:19,900
Your work, and then Chrome's
work, and then wait, and so

1335
00:54:19,900 --> 00:54:20,980
on, and so forth.

1336
00:54:20,980 --> 00:54:24,350
This all makes perfect sense,
nice repeating pattern.

1337
00:54:24,350 --> 00:54:27,410
But when you have outside
events, DOM events or timers,

1338
00:54:27,410 --> 00:54:30,220
or things going off that cause
things at unexpected

1339
00:54:30,220 --> 00:54:33,060
intervals, Chrome no longer has
the ability to schedule

1340
00:54:33,060 --> 00:54:33,520
those things.

1341
00:54:33,520 --> 00:54:35,200
They just happened
in on events.

1342
00:54:35,200 --> 00:54:38,560
So in this case, on the slide,
I got this on-click event.

1343
00:54:38,560 --> 00:54:40,470
It required some work.

1344
00:54:40,470 --> 00:54:42,845
That processing all would have
fit in this frame nicely.

1345
00:54:42,845 --> 00:54:45,040
But because Chrome didn't know
about that work, it couldn't

1346
00:54:45,040 --> 00:54:48,200
schedule, it which means that
this frame is actually going

1347
00:54:48,200 --> 00:54:49,110
to be delivered late.

1348
00:54:49,110 --> 00:54:51,480
It's going to wait for that
on-click event to complete.

1349
00:54:51,480 --> 00:54:52,740
It's going to deliver
the frame late.

1350
00:54:52,740 --> 00:54:55,160
And then, the next frame, frame
N+1, is actually going

1351
00:54:55,160 --> 00:54:57,860
to have a shorter time
in which to execute.

1352
00:54:57,860 --> 00:55:03,140
So what this means to you is
essentially never do any work

1353
00:55:03,140 --> 00:55:05,050
outside of
RequestAnimationFrame.

1354
00:55:05,050 --> 00:55:09,210
If you want like a DOM-based hub
over your WebGL game, what

1355
00:55:09,210 --> 00:55:12,060
you really want to be doing is
buffering up all user input

1356
00:55:12,060 --> 00:55:14,300
and then handling those
user inputs in the

1357
00:55:14,300 --> 00:55:15,780
RequestAnimationFrame
callback.

1358
00:55:15,780 --> 00:55:18,030
You don't want to just handle
them whenever they come in.

1359
00:55:18,030 --> 00:55:20,110
Because you have to think about
how Chrome is actually

1360
00:55:20,110 --> 00:55:21,500
scheduling the work.

1361
00:55:21,500 --> 00:55:23,770
You have to give Chrome a chance
to pack that work in

1362
00:55:23,770 --> 00:55:26,060
nicely, which means that you
have to actually do any

1363
00:55:26,060 --> 00:55:28,280
processing you want
to do inside the

1364
00:55:28,280 --> 00:55:29,530
RequestAnimationFrame
callback.

1365
00:55:29,530 --> 00:55:32,180

1366
00:55:32,180 --> 00:55:34,460
So just in summary of what we've
learned about living

1367
00:55:34,460 --> 00:55:36,610
inside Chrome, first
of all, throttle

1368
00:55:36,610 --> 00:55:37,800
your upload per frame.

1369
00:55:37,800 --> 00:55:40,290
Watch out for big performance
stalls.

1370
00:55:40,290 --> 00:55:42,460
Those are probably
sink flushes.

1371
00:55:42,460 --> 00:55:44,830
And they mean that you're
uploading too much data at

1372
00:55:44,830 --> 00:55:47,520
once essentially.

1373
00:55:47,520 --> 00:55:50,200
Your game lives inside Chrome,
so you have to respect

1374
00:55:50,200 --> 00:55:53,070
Chrome's natural rendering cycle
and have to be prepared

1375
00:55:53,070 --> 00:55:56,490
to give 2 to 4 milliseconds per
frame to Chrome for all

1376
00:55:56,490 --> 00:55:59,030
the compositing and swapping
and finalizing that Chrome

1377
00:55:59,030 --> 00:55:59,800
needs to do.

1378
00:55:59,800 --> 00:56:01,610
So you don't actually have
16 milliseconds.

1379
00:56:01,610 --> 00:56:02,910
You actually have 12.

1380
00:56:02,910 --> 00:56:05,580
Hopefully, it will come in under
4, but you have to be

1381
00:56:05,580 --> 00:56:08,840
prepared to give
that much away.

1382
00:56:08,840 --> 00:56:10,880
Never handle outside
events directly.

1383
00:56:10,880 --> 00:56:14,010
Never handle user events
directly in events.

1384
00:56:14,010 --> 00:56:17,080
Make sure you queue all the
work you need to do up and

1385
00:56:17,080 --> 00:56:17,950
handle it in RAF.

1386
00:56:17,950 --> 00:56:19,860
All the work you do should
be inside your

1387
00:56:19,860 --> 00:56:22,720
RequestAnimationFrame callback
if you want Chrome to be able

1388
00:56:22,720 --> 00:56:25,910
to schedule it nicely.

1389
00:56:25,910 --> 00:56:28,490
And then, if you're concerned
about input latency, if that's

1390
00:56:28,490 --> 00:56:31,350
a big deal for you, then the
best thing you can do there is

1391
00:56:31,350 --> 00:56:32,970
move work off your
main thread.

1392
00:56:32,970 --> 00:56:35,480
Move it to the GPU, move it
to Web Workers, whatever.

1393
00:56:35,480 --> 00:56:38,970
Just know that the input is
blocked or queued while the

1394
00:56:38,970 --> 00:56:39,820
main thread is busy.

1395
00:56:39,820 --> 00:56:44,340
And that's just going to imply
some input latency for you.

1396
00:56:44,340 --> 00:56:47,225
So in general, all this amounts
to be aware of what

1397
00:56:47,225 --> 00:56:49,430
Chrome is doing and how you
fit inside it and try

1398
00:56:49,430 --> 00:56:50,680
to work with that.

1399
00:56:50,680 --> 00:56:53,470

1400
00:56:53,470 --> 00:56:57,120
So we've talked about how to
write fast JavaScript.

1401
00:56:57,120 --> 00:56:59,180
We've talked about how to make
that JavaScript work well

1402
00:56:59,180 --> 00:57:00,270
inside of Chrome.

1403
00:57:00,270 --> 00:57:02,920
And now, just in the short time
I have left, I'm going to

1404
00:57:02,920 --> 00:57:05,860
talk about the developer tools
you need to check how well

1405
00:57:05,860 --> 00:57:08,000
you're doing.

1406
00:57:08,000 --> 00:57:10,370
So first of all, just be aware
that Chrome's got all these

1407
00:57:10,370 --> 00:57:11,280
handy dandy flags.

1408
00:57:11,280 --> 00:57:13,740
So you can type about and then
a number of things different

1409
00:57:13,740 --> 00:57:16,250
into Chrome to get
some cool stats.

1410
00:57:16,250 --> 00:57:18,970
So there's about:flags, which
has a lot of graphics options,

1411
00:57:18,970 --> 00:57:21,860
including an FPS counter,
which I essentially just

1412
00:57:21,860 --> 00:57:23,120
perpetually leave on.

1413
00:57:23,120 --> 00:57:25,380
There's about:memory, which
shows you exactly what's going

1414
00:57:25,380 --> 00:57:26,490
on with memory in Chrome.

1415
00:57:26,490 --> 00:57:28,630
It's a very in-depth
detailed view.

1416
00:57:28,630 --> 00:57:31,910
There's about:gpu, which is
useful for figuring out what

1417
00:57:31,910 --> 00:57:33,590
Chrome thinks your
GPU stats are.

1418
00:57:33,590 --> 00:57:36,410
Or if you're taking bug reports
from external people,

1419
00:57:36,410 --> 00:57:38,060
it's really nice to get
them to dump that data

1420
00:57:38,060 --> 00:57:38,940
and give it to you.

1421
00:57:38,940 --> 00:57:42,000
So these are all tools you
should be aware of.

1422
00:57:42,000 --> 00:57:43,540
Then we have the Chrome
developer tools.

1423
00:57:43,540 --> 00:57:48,560
So the Chrome developer tools
are really, really useful.

1424
00:57:48,560 --> 00:57:51,100
They were designed. or
had been used most

1425
00:57:51,100 --> 00:57:52,850
often on web pages.

1426
00:57:52,850 --> 00:57:54,990
They're really, really
great for web pages.

1427
00:57:54,990 --> 00:57:57,060
They're also good for games,
but they've been optimized

1428
00:57:57,060 --> 00:57:58,000
around that case.

1429
00:57:58,000 --> 00:58:01,290
So for instance, the CPU
profiler only take samples

1430
00:58:01,290 --> 00:58:03,040
every 1 or 2 milliseconds.

1431
00:58:03,040 --> 00:58:06,550
So it's a lot less resolution
than you would want.

1432
00:58:06,550 --> 00:58:07,600
But they're really good
for some things.

1433
00:58:07,600 --> 00:58:10,110
So how you get to the developer
tools, there's a

1434
00:58:10,110 --> 00:58:13,110
wrench icon up in the upper
right hand of Chrome.

1435
00:58:13,110 --> 00:58:15,590
Then you go to the Tools menu,
go to Developer Tools.

1436
00:58:15,590 --> 00:58:18,160
And the things you should be
aware of there are the

1437
00:58:18,160 --> 00:58:21,610
timeline view, which completely
rocks for trying to

1438
00:58:21,610 --> 00:58:23,620
see how your resource
loads are going.

1439
00:58:23,620 --> 00:58:26,220
That's the thing that I find it
most useful for, is seeing

1440
00:58:26,220 --> 00:58:29,420
where resource requests were
made and how long they took.

1441
00:58:29,420 --> 00:58:32,380
There's the CPU profiler,
standard profiler.

1442
00:58:32,380 --> 00:58:34,590
Again, resolution a little
low, but it still can be

1443
00:58:34,590 --> 00:58:36,210
really useful.

1444
00:58:36,210 --> 00:58:38,720
And then there's the heap
profiler, which is a super

1445
00:58:38,720 --> 00:58:41,080
useful in-depth look
at exactly where

1446
00:58:41,080 --> 00:58:42,450
all your memory is.

1447
00:58:42,450 --> 00:58:46,180
So those are the tools that are
most important, I think,

1448
00:58:46,180 --> 00:58:50,200
of the Chrome developer tools
for game developers.

1449
00:58:50,200 --> 00:58:52,050
And then, there's
about:tracing.

1450
00:58:52,050 --> 00:58:55,970
So about:tracing is the heaviest
weight tool you

1451
00:58:55,970 --> 00:58:58,470
should be aware of in Chrome if
you're actually trying to

1452
00:58:58,470 --> 00:58:59,880
debug a game.

1453
00:58:59,880 --> 00:59:02,650
So this view that's on the
slide, pretty confusing the

1454
00:59:02,650 --> 00:59:03,840
first time you look at it.

1455
00:59:03,840 --> 00:59:06,840
Every one of these colored
lines, colored vertical lines,

1456
00:59:06,840 --> 00:59:09,670
represents a function call
that's instrumented.

1457
00:59:09,670 --> 00:59:13,310
And so this actually gives you a
list of all the instrumented

1458
00:59:13,310 --> 00:59:16,110
function calls on every Chrome
process, so for every open

1459
00:59:16,110 --> 00:59:18,740
tab, as well as calls
for the GPU.

1460
00:59:18,740 --> 00:59:20,710
So this is the tool you're going
to look at if you're

1461
00:59:20,710 --> 00:59:22,710
going to want to see how
your CPU work and

1462
00:59:22,710 --> 00:59:24,130
your GPU work relate.

1463
00:59:24,130 --> 00:59:26,410
This is what's going
to be useful.

1464
00:59:26,410 --> 00:59:29,110
If you zoom way in on that view
I just showed you, you

1465
00:59:29,110 --> 00:59:32,060
can see that each one of those
colored boxes, actually, you

1466
00:59:32,060 --> 00:59:33,470
can see a function name in it.

1467
00:59:33,470 --> 00:59:35,490
And that function name
data is really raw.

1468
00:59:35,490 --> 00:59:36,800
Again, it's right out
of the source code.

1469
00:59:36,800 --> 00:59:41,810
So if you don't know what draw
layers means in this

1470
00:59:41,810 --> 00:59:44,460
particular context, then
that's too bad.

1471
00:59:44,460 --> 00:59:47,370
But you can kind of look at the
function names and make

1472
00:59:47,370 --> 00:59:49,240
educated guesses about
what they mean.

1473
00:59:49,240 --> 00:59:52,430
And then the really useful thing
you can do with this is

1474
00:59:52,430 --> 00:59:55,530
that from JavaScript, you
can add console.time and

1475
00:59:55,530 --> 00:59:58,990
console.timeEnd tags with
your own string tag.

1476
00:59:58,990 --> 01:00:01,770
And that will create a colored
box in this view, just like

1477
01:00:01,770 --> 01:00:04,380
all the other function calls
that will manually instrument

1478
01:00:04,380 --> 01:00:05,480
a function call for you.

1479
01:00:05,480 --> 01:00:08,260
And you can see exactly where
your function call happened

1480
01:00:08,260 --> 01:00:09,660
within your frame.

1481
01:00:09,660 --> 01:00:11,730
So this is a tool you
definitely, definitely want to

1482
01:00:11,730 --> 01:00:13,870
be aware of.

1483
01:00:13,870 --> 01:00:16,910
And then finally, I know I
mentioned this in the section

1484
01:00:16,910 --> 01:00:19,270
about JavaScript, but you really
should be checking your

1485
01:00:19,270 --> 01:00:20,320
code with V8 flags.

1486
01:00:20,320 --> 01:00:23,080
Unfortunately, this information
about what

1487
01:00:23,080 --> 01:00:25,310
JavaScript is fast and
slow isn't surfaced

1488
01:00:25,310 --> 01:00:26,920
really well to the user.

1489
01:00:26,920 --> 01:00:28,770
It's all sort of at
the command line.

1490
01:00:28,770 --> 01:00:30,890
But it's very, very important
information.

1491
01:00:30,890 --> 01:00:33,200
And so I also put up
here exactly how to

1492
01:00:33,200 --> 01:00:35,990
run this for a Mac.

1493
01:00:35,990 --> 01:00:38,560
It's not really friendly being
on a slide, but I wanted

1494
01:00:38,560 --> 01:00:41,490
people to have these slides
after the fact as reference to

1495
01:00:41,490 --> 01:00:43,230
be able to refer to it.

1496
01:00:43,230 --> 01:00:45,370
So that's actually a call you
can cut and paste into your

1497
01:00:45,370 --> 01:00:48,270
Mac to make this happen.

1498
01:00:48,270 --> 01:00:50,750
And then finally, there's
WebGL Inspector.

1499
01:00:50,750 --> 01:00:54,360
So WebGL Inspector is an
open-source Chrome extension

1500
01:00:54,360 --> 01:00:57,690
which patterns itself after
PIX or one of these other

1501
01:00:57,690 --> 01:01:00,640
heavyweight graphics debugging
tools that people in the games

1502
01:01:00,640 --> 01:01:02,540
industry especially are
really fond of.

1503
01:01:02,540 --> 01:01:05,400
So if you want to step through
your draw calls or see exactly

1504
01:01:05,400 --> 01:01:07,550
how your textures are bound
something like that, WebGL

1505
01:01:07,550 --> 01:01:10,220
Inspector is going to be very,
very useful to you.

1506
01:01:10,220 --> 01:01:13,130
So you should definitely
check that out.

1507
01:01:13,130 --> 01:01:15,710
And then finally, one more note
before I'm out of time.

1508
01:01:15,710 --> 01:01:18,370
I just want to stress
that we really,

1509
01:01:18,370 --> 01:01:20,030
really, really want feedback.

1510
01:01:20,030 --> 01:01:23,530
It's not at all knowing or
unwelcome to file bugs.

1511
01:01:23,530 --> 01:01:24,860
It's really welcome.

1512
01:01:24,860 --> 01:01:28,240
I really, really look forward to
working with teams that are

1513
01:01:28,240 --> 01:01:29,430
verbose about what they want.

1514
01:01:29,430 --> 01:01:30,750
And they file bugs in Chrome.

1515
01:01:30,750 --> 01:01:33,170
And they sort of squawk a lot
about what's working and

1516
01:01:33,170 --> 01:01:35,090
what's not working.

1517
01:01:35,090 --> 01:01:37,740
So please, please, please,
when you find things that

1518
01:01:37,740 --> 01:01:39,620
don't work in Chrome, or things
you'd like to work

1519
01:01:39,620 --> 01:01:41,140
better, or features
you want, please

1520
01:01:41,140 --> 01:01:42,990
log things into crbug.com.

1521
01:01:42,990 --> 01:01:44,390
That's the Chrome
bug database.

1522
01:01:44,390 --> 01:01:47,740
Or if there are features you
want in WebGL or in any of the

1523
01:01:47,740 --> 01:01:50,840
HTML5 specifications, please go
to those mailing lists and

1524
01:01:50,840 --> 01:01:53,660
talk about what you need and
what your experience is.

1525
01:01:53,660 --> 01:01:55,830
The community is not so large
that you can't make a

1526
01:01:55,830 --> 01:01:56,990
difference.

1527
01:01:56,990 --> 01:01:59,830
Really, the decisions are made
by the people who show up.

1528
01:01:59,830 --> 01:02:02,950
And you are really capable
of influencing what

1529
01:02:02,950 --> 01:02:03,670
actually gets done.

1530
01:02:03,670 --> 01:02:05,690
So please, please, please
email those

1531
01:02:05,690 --> 01:02:07,210
mailing lists, file bugs.

1532
01:02:07,210 --> 01:02:10,710
Everybody really wants
to hear from you.

1533
01:02:10,710 --> 01:02:11,180
All right.

1534
01:02:11,180 --> 01:02:12,050
And that's it.

1535
01:02:12,050 --> 01:02:13,300
Thank you very much.

1536
01:02:13,300 --> 01:02:14,030

