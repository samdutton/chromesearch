1
00:00:00,000 --> 00:00:01,280

2
00:00:01,280 --> 00:00:01,520
LARS BAK: Hello.

3
00:00:01,520 --> 00:00:03,225
Welcome, everybody.

4
00:00:03,225 --> 00:00:03,610
Oh.

5
00:00:03,610 --> 00:00:04,880
They fixed the sound.

6
00:00:04,880 --> 00:00:05,820
Great.

7
00:00:05,820 --> 00:00:08,380
So welcome to the Dart,
a modern web language

8
00:00:08,380 --> 00:00:09,410
presentation.

9
00:00:09,410 --> 00:00:11,530
This is the first ever
presentation about

10
00:00:11,530 --> 00:00:13,310
Dart at Google IO.

11
00:00:13,310 --> 00:00:15,260
And I'm here.

12
00:00:15,260 --> 00:00:18,680
I'm Lars Bak with Kaspar Lund,
coming all the way from

13
00:00:18,680 --> 00:00:20,200
Denmark to present Dart.

14
00:00:20,200 --> 00:00:23,300

15
00:00:23,300 --> 00:00:26,050
I can just say right away, we
will not be doing any base

16
00:00:26,050 --> 00:00:29,270
jumping nor stage diving.

17
00:00:29,270 --> 00:00:30,975
This will be fairly boring
in that respect.

18
00:00:30,975 --> 00:00:33,480

19
00:00:33,480 --> 00:00:36,260
What I can tell you about is
about this new programming

20
00:00:36,260 --> 00:00:38,780
language we have been working
on for a year.

21
00:00:38,780 --> 00:00:41,550
And this presentation will
include a few things.

22
00:00:41,550 --> 00:00:45,190
We'll talk about the
motivation for it.

23
00:00:45,190 --> 00:00:49,990
And part of the motivation
is our work on V8.

24
00:00:49,990 --> 00:00:53,790
Kasper and I have been working
on V8 for many years, I guess.

25
00:00:53,790 --> 00:00:54,810
Four or so?

26
00:00:54,810 --> 00:00:55,630
KASPER LUND: Four years, yeah.

27
00:00:55,630 --> 00:00:56,260
LARS BAK: Four years.

28
00:00:56,260 --> 00:01:00,050
And some of the experience
with JavaScript

29
00:01:00,050 --> 00:01:02,820
has led us to Dart.

30
00:01:02,820 --> 00:01:04,550
We'll be talking about
the basic language.

31
00:01:04,550 --> 00:01:08,000
We'll be talking about some of
the components we have in the

32
00:01:08,000 --> 00:01:08,780
Dart project.

33
00:01:08,780 --> 00:01:11,900
And then we'll talk about the
bright future we hopefully

34
00:01:11,900 --> 00:01:12,930
have with Dart.

35
00:01:12,930 --> 00:01:14,555
So let's get started.

36
00:01:14,555 --> 00:01:19,100
We have a lot of interesting
stuff to talk about.

37
00:01:19,100 --> 00:01:22,950
So our background is in
implementing virtual machines.

38
00:01:22,950 --> 00:01:28,030
And as you probably can see,
I'm the oldest one.

39
00:01:28,030 --> 00:01:29,400
He's the younger version.

40
00:01:29,400 --> 00:01:33,000
I've been doing VMs for 26
years, and Kasper's been doing

41
00:01:33,000 --> 00:01:34,360
it for the last 12.

42
00:01:34,360 --> 00:01:36,830
We've worked together
on many projects.

43
00:01:36,830 --> 00:01:40,780
We've been doing Java,
virtual machines.

44
00:01:40,780 --> 00:01:43,140
Also JavaScript engines,
like V8.

45
00:01:43,140 --> 00:01:45,650
And that's been pretty cool.

46
00:01:45,650 --> 00:01:47,980
So this is our first project
ever where we've been

47
00:01:47,980 --> 00:01:50,160
designing a programming
language.

48
00:01:50,160 --> 00:01:53,530
KASPER LUND: Before I joined
Lars on this mission to try to

49
00:01:53,530 --> 00:01:57,720
improve the performance of
virtual machines for various

50
00:01:57,720 --> 00:01:58,230
languages &mdash;

51
00:01:58,230 --> 00:02:01,685
Lars was working on more exotic
languages, too, like

52
00:02:01,685 --> 00:02:05,000
the Beta programming language,
sort of a Scandinavian

53
00:02:05,000 --> 00:02:05,960
object-oriented language.

54
00:02:05,960 --> 00:02:09,169
So there's a lot of experience
on the stage here.

55
00:02:09,169 --> 00:02:12,480
Nearly 40 years combined.

56
00:02:12,480 --> 00:02:16,240
So we certainly know a thing or
two about virtual machines,

57
00:02:16,240 --> 00:02:18,260
so hopefully we can convince
you that we know a thing or

58
00:02:18,260 --> 00:02:21,030
two about languages as well.

59
00:02:21,030 --> 00:02:23,300
LARS BAK: So first of all, there
will be a little bit of

60
00:02:23,300 --> 00:02:25,680
a salute to the web.

61
00:02:25,680 --> 00:02:28,580
We think the web is fantastic.

62
00:02:28,580 --> 00:02:29,580
The web is everywhere today.

63
00:02:29,580 --> 00:02:32,000
You have it on your
mobile phone, your

64
00:02:32,000 --> 00:02:33,670
pads and your desktop.

65
00:02:33,670 --> 00:02:36,240
So when you do an application
it can actually cover most

66
00:02:36,240 --> 00:02:38,300
devices today.

67
00:02:38,300 --> 00:02:40,260
It's also very easy to
use as a developer.

68
00:02:40,260 --> 00:02:43,140
You can just pop into your
favorite text editor, type in

69
00:02:43,140 --> 00:02:46,760
a few lines, and then you can
start it up in your browser.

70
00:02:46,760 --> 00:02:49,190
There's no tool chain
involved in getting

71
00:02:49,190 --> 00:02:51,770
the program up running.

72
00:02:51,770 --> 00:02:54,650
And one thing I really like
about the web, there's no

73
00:02:54,650 --> 00:02:56,570
required installation
of the app.

74
00:02:56,570 --> 00:02:59,660
Whenever you start Gmail, you
get the newest version.

75
00:02:59,660 --> 00:03:02,820
So you are not bothered
by these updates.

76
00:03:02,820 --> 00:03:05,380
I assume you all have
mobile phones?

77
00:03:05,380 --> 00:03:09,390
Have you tried to get bothered
by an update notification?

78
00:03:09,390 --> 00:03:11,320
I guess.

79
00:03:11,320 --> 00:03:13,860
For me, at least, that's one
of the benefits of the web.

80
00:03:13,860 --> 00:03:16,710
That you don't have to install
an application.

81
00:03:16,710 --> 00:03:20,330

82
00:03:20,330 --> 00:03:23,190
Furthermore it's also a very
incremental experience, to

83
00:03:23,190 --> 00:03:24,560
develop for the web.

84
00:03:24,560 --> 00:03:27,960
You can change one line in the
program and use a refresh.

85
00:03:27,960 --> 00:03:30,850
So within a second, you can
have your application up

86
00:03:30,850 --> 00:03:31,220
running again.

87
00:03:31,220 --> 00:03:33,540
And that's very appealing
when you do prototype

88
00:03:33,540 --> 00:03:35,730
develop and so on.

89
00:03:35,730 --> 00:03:40,500
And one thing that's even
better, the browser industry

90
00:03:40,500 --> 00:03:42,760
is right now fairly
competitive.

91
00:03:42,760 --> 00:03:45,380
All the browser vendors, they're
competing on speed and

92
00:03:45,380 --> 00:03:46,600
functionality.

93
00:03:46,600 --> 00:03:49,180
And most implementations are
open source, so it's a

94
00:03:49,180 --> 00:03:50,430
friendly competition.

95
00:03:50,430 --> 00:03:54,910

96
00:03:54,910 --> 00:03:56,980
Here's my best attempt
to make a wheel.

97
00:03:56,980 --> 00:04:00,250
It turned out to
be three-sided.

98
00:04:00,250 --> 00:04:03,800
But I'm trying to explain
the ecosystem of browser

99
00:04:03,800 --> 00:04:06,140
development.

100
00:04:06,140 --> 00:04:10,010
When you add more performance
into a browser, you will sort

101
00:04:10,010 --> 00:04:12,750
of enable application developers
to innovate.

102
00:04:12,750 --> 00:04:15,170
They can add more functionality
on the client

103
00:04:15,170 --> 00:04:19,120
side, and that again will
require new browser features.

104
00:04:19,120 --> 00:04:20,959
And so on and so forth.

105
00:04:20,959 --> 00:04:24,140
And this is great, because
whenever you take a turn with

106
00:04:24,140 --> 00:04:27,780
this wheel, the browser will be
a better place to develop

107
00:04:27,780 --> 00:04:29,995
applications and also
use applications.

108
00:04:29,995 --> 00:04:33,570

109
00:04:33,570 --> 00:04:36,650
Here's a JavaScript performance
improvement chart.

110
00:04:36,650 --> 00:04:39,650
It'll show you the speedup
of JavaScript

111
00:04:39,650 --> 00:04:42,210
over the last 12 years.

112
00:04:42,210 --> 00:04:45,360
And as you can see, there
was a dry spell

113
00:04:45,360 --> 00:04:47,720
of a number of years.

114
00:04:47,720 --> 00:04:51,130
And then we introduced in
2008, Chrome, the beta

115
00:04:51,130 --> 00:04:55,360
version, where V8 was
part of that.

116
00:04:55,360 --> 00:05:00,530
And you can see, since 2008 the
performance of JavaScript

117
00:05:00,530 --> 00:05:03,150
has just improved
tremendously.

118
00:05:03,150 --> 00:05:08,250
In fact, JavaScript is now 100
times faster on the same

119
00:05:08,250 --> 00:05:12,140
hardware, compared to a browser
five years ago.

120
00:05:12,140 --> 00:05:14,804
That's pretty amazing,
isn't it?

121
00:05:14,804 --> 00:05:16,180
KASPER LUND: That's
a lot, yeah.

122
00:05:16,180 --> 00:05:19,310
LARS BAK: Even on mobile
devices, like an Android

123
00:05:19,310 --> 00:05:23,240
device, you can see that the
performance of JavaScript is

124
00:05:23,240 --> 00:05:26,370
comparable to a desktop
machine, when we

125
00:05:26,370 --> 00:05:29,440
introduced V8 in 2008.

126
00:05:29,440 --> 00:05:30,470
So this is pretty amazing.

127
00:05:30,470 --> 00:05:35,300
And it really allows you guys to
do better apps on the web.

128
00:05:35,300 --> 00:05:36,840
KASPER LUND: We've already seen
a few things that have

129
00:05:36,840 --> 00:05:41,370
come along that take advantage
of this new power.

130
00:05:41,370 --> 00:05:44,570
So the point with the previous
slide, where performance

131
00:05:44,570 --> 00:05:46,750
improvements of the core
platform really help you

132
00:05:46,750 --> 00:05:50,110
innovate, can be seen in one
of the latest versions of

133
00:05:50,110 --> 00:05:52,390
Google Maps for instance,
where you can enable

134
00:05:52,390 --> 00:05:55,420
client-side rendering of
things &mdash; things that you had

135
00:05:55,420 --> 00:05:57,130
to do on the server side before,
it's now possible to

136
00:05:57,130 --> 00:05:58,510
do on the client instead.

137
00:05:58,510 --> 00:06:00,070
Which is pretty cool.

138
00:06:00,070 --> 00:06:02,720
So we certainly see that this
is already now helping a lot

139
00:06:02,720 --> 00:06:06,710
on what you can do and
achieve with the web.

140
00:06:06,710 --> 00:06:10,320
LARS BAK: So during this period
the web applications

141
00:06:10,320 --> 00:06:13,000
have become more and
more complex.

142
00:06:13,000 --> 00:06:18,930
And have posed some challenges
for the web.

143
00:06:18,930 --> 00:06:21,850
What we really want, we want
to have better programmer

144
00:06:21,850 --> 00:06:23,330
productivity.

145
00:06:23,330 --> 00:06:28,110
And we also want application
scalability, so that as you

146
00:06:28,110 --> 00:06:30,670
get bigger and bigger
applications the browser can

147
00:06:30,670 --> 00:06:33,080
cope with it as you
execute it.

148
00:06:33,080 --> 00:06:35,510
And then of course you need
raw execution speed.

149
00:06:35,510 --> 00:06:39,300
We've fixed some of that with
V8, but we are not hitting the

150
00:06:39,300 --> 00:06:41,440
glass ceiling yet.

151
00:06:41,440 --> 00:06:44,080
One thing that's a problem
today, at least from my point

152
00:06:44,080 --> 00:06:47,060
of view, is that startup
performance is not where we

153
00:06:47,060 --> 00:06:48,280
want it to be.

154
00:06:48,280 --> 00:06:51,560
When you start up a big web
app, it's fairly slow.

155
00:06:51,560 --> 00:06:55,690
For instance, if you take Gmail,
you have to read in a

156
00:06:55,690 --> 00:06:58,380
lot of source code before you
can start the application.

157
00:06:58,380 --> 00:07:01,410
And that sort of delays
the startup with

158
00:07:01,410 --> 00:07:04,530
half to a full second.

159
00:07:04,530 --> 00:07:08,520
So the final item on this slide
here is that if we don't

160
00:07:08,520 --> 00:07:13,540
innovate, the web will lose out
to mobile apps, where they

161
00:07:13,540 --> 00:07:16,640
can install more native
types of applications.

162
00:07:16,640 --> 00:07:22,130

163
00:07:22,130 --> 00:07:26,000
Fortunately, we have
a solution for you.

164
00:07:26,000 --> 00:07:28,570
We have the Dart platform.

165
00:07:28,570 --> 00:07:32,550
And this is a suite of
technologies that will

166
00:07:32,550 --> 00:07:35,550
hopefully solve so some
of these issues with

167
00:07:35,550 --> 00:07:36,930
the existing platform.

168
00:07:36,930 --> 00:07:39,180
Our high-level goals
are fairly simple.

169
00:07:39,180 --> 00:07:41,740
We want to make a simple,
productive programming

170
00:07:41,740 --> 00:07:45,710
alignment and programming
language that supports for

171
00:07:45,710 --> 00:07:48,090
programming in the large.

172
00:07:48,090 --> 00:07:51,620
And we also want to have
predictable high performance.

173
00:07:51,620 --> 00:07:54,100
And that means that when you
write your code, you can

174
00:07:54,100 --> 00:07:56,020
expect some sort
of performance.

175
00:07:56,020 --> 00:07:58,170
Right now it's complicated
with JavaScript.

176
00:07:58,170 --> 00:08:01,350
It often depends on what the
browser optimized, how good

177
00:08:01,350 --> 00:08:04,180
performance you get out of it.

178
00:08:04,180 --> 00:08:07,120
We want to have ultra-fast
startup.

179
00:08:07,120 --> 00:08:09,750
Things that take more than
100 milliseconds are just

180
00:08:09,750 --> 00:08:11,740
unacceptable.

181
00:08:11,740 --> 00:08:15,280
And then of course, we are
not out to break the web.

182
00:08:15,280 --> 00:08:19,250
We really want to have
compatibility

183
00:08:19,250 --> 00:08:20,540
with all modern browsers.

184
00:08:20,540 --> 00:08:22,870
And we'll show you how we've
done that in Dart, by

185
00:08:22,870 --> 00:08:25,520
providing a translator from
Dart to JavaScript.

186
00:08:25,520 --> 00:08:28,790

187
00:08:28,790 --> 00:08:30,800
So.

188
00:08:30,800 --> 00:08:32,470
KASPER LUND: Let's talk
about JavaScript.

189
00:08:32,470 --> 00:08:33,530
LARS BAK: Let's do that.

190
00:08:33,530 --> 00:08:35,700
KASPER LUND: So, I don't know
how many people in here are

191
00:08:35,700 --> 00:08:36,950
familiar with JavaScript.

192
00:08:36,950 --> 00:08:39,320

193
00:08:39,320 --> 00:08:40,289
There are some that know it.

194
00:08:40,289 --> 00:08:40,610
OK.

195
00:08:40,610 --> 00:08:42,270
That's good.

196
00:08:42,270 --> 00:08:43,750
How many people here
actually work with

197
00:08:43,750 --> 00:08:46,670
JavaScript every day?

198
00:08:46,670 --> 00:08:47,470
Good crowd.

199
00:08:47,470 --> 00:08:47,960
I like that.

200
00:08:47,960 --> 00:08:51,690
So hopefully you're aware of
some fundamental issues with

201
00:08:51,690 --> 00:08:52,200
JavaScript.

202
00:08:52,200 --> 00:08:55,070
I'm going to run through a few
of them, just to give you a

203
00:08:55,070 --> 00:08:58,490
feel for the kind of issues
we're trying to tackle.

204
00:08:58,490 --> 00:09:02,310
So one big issue we see with
JavaScript is it's very hard

205
00:09:02,310 --> 00:09:05,030
to reason about where the
problem is actually defined.

206
00:09:05,030 --> 00:09:09,440
There is almost no declarative
syntax, and it's very hard, if

207
00:09:09,440 --> 00:09:12,820
not impossible sometimes, to
find dependencies between

208
00:09:12,820 --> 00:09:16,160
different components in a
language like JavaScript.

209
00:09:16,160 --> 00:09:18,470
It's not uncommon and not
unheard of that in JavaScript

210
00:09:18,470 --> 00:09:21,430
you do monkey patching of core
functionality to add your

211
00:09:21,430 --> 00:09:24,810
message to the object
[? or ?] prototype.

212
00:09:24,810 --> 00:09:26,930
And that makes it even harder to
reason about what's defined

213
00:09:26,930 --> 00:09:28,290
where, and who uses what.

214
00:09:28,290 --> 00:09:30,600
And understanding the program
structure is really, really

215
00:09:30,600 --> 00:09:33,270
important if you want to be
efficient as a programmer.

216
00:09:33,270 --> 00:09:36,090
You need to be able to do code
maintenance and refactoring,

217
00:09:36,090 --> 00:09:38,710
and that really requires you to
have a full and very good

218
00:09:38,710 --> 00:09:40,750
understanding of the
program structure.

219
00:09:40,750 --> 00:09:43,570
You also need that understanding
of the program

220
00:09:43,570 --> 00:09:46,000
structure if you want to write
a good tool that can analyze

221
00:09:46,000 --> 00:09:48,720
your code, and work with it, and
allow you to debug it and

222
00:09:48,720 --> 00:09:51,020
maybe navigate the code
in a clever way.

223
00:09:51,020 --> 00:09:53,000
So it's actually really
hard in JavaScript.

224
00:09:53,000 --> 00:09:54,760
Let me give you a
small example of

225
00:09:54,760 --> 00:09:55,850
what I mean with that.

226
00:09:55,850 --> 00:09:59,690
So here's a very, very simple
JavaScript function, meant as

227
00:09:59,690 --> 00:10:02,070
a constructor for points.

228
00:10:02,070 --> 00:10:04,870
So the fields of this point
class, that I'm trying to

229
00:10:04,870 --> 00:10:07,540
simulate in JavaScript, are
not actually declared

230
00:10:07,540 --> 00:10:10,930
anywhere, except that they are
implicitly defined by the

231
00:10:10,930 --> 00:10:13,770
statements that I put in the
constructor that assign x and

232
00:10:13,770 --> 00:10:16,750
y to this.x and this.y.

233
00:10:16,750 --> 00:10:18,960
This seems simple enough,
and pretty nice.

234
00:10:18,960 --> 00:10:21,290
And you could probably write a
tool that works with this kind

235
00:10:21,290 --> 00:10:22,250
of information.

236
00:10:22,250 --> 00:10:24,980
But in reality it's often more
complicated than this.

237
00:10:24,980 --> 00:10:28,370
So in JavaScript we often see
code like this, for instance,

238
00:10:28,370 --> 00:10:32,210
where you really want to make
these properties non-writable,

239
00:10:32,210 --> 00:10:33,400
like read-only.

240
00:10:33,400 --> 00:10:37,700
And suddenly you have to go
through actual control flow in

241
00:10:37,700 --> 00:10:41,230
your constructors, to figure
out what kind of fields you

242
00:10:41,230 --> 00:10:43,260
end up having on all
your points.

243
00:10:43,260 --> 00:10:45,720
Of course, this is a trivial
example, so a very good tool

244
00:10:45,720 --> 00:10:47,800
could probably analyze this
code and understand what

245
00:10:47,800 --> 00:10:48,540
you're doing.

246
00:10:48,540 --> 00:10:51,080
But for real applications,
this really quickly gets

247
00:10:51,080 --> 00:10:53,910
really, really hard.

248
00:10:53,910 --> 00:10:56,080
If you look at the tools out
there today for working with

249
00:10:56,080 --> 00:10:58,790
JavaScript code, it is pretty
clear that it's not an easy

250
00:10:58,790 --> 00:10:59,680
problem to solve.

251
00:10:59,680 --> 00:11:01,040
I mean, there are good
tools coming

252
00:11:01,040 --> 00:11:02,120
out, and it's improving.

253
00:11:02,120 --> 00:11:05,150
But it's really hard.

254
00:11:05,150 --> 00:11:09,050
Another very fundamental issue
with JavaScript is this keep

255
00:11:09,050 --> 00:11:10,410
on trucking mentality.

256
00:11:10,410 --> 00:11:13,420
So JavaScript has this idea
that it's a good thing to

257
00:11:13,420 --> 00:11:16,930
tolerate mistakes in the
program, and it's OK to

258
00:11:16,930 --> 00:11:21,210
operate on unexpected types, and
it's OK if that actually

259
00:11:21,210 --> 00:11:24,370
just leads to unusable or
unexpected results.

260
00:11:24,370 --> 00:11:27,130
So at the point in your code
where you introduce an error,

261
00:11:27,130 --> 00:11:30,030
you're very unlikely
to get that error.

262
00:11:30,030 --> 00:11:33,500
And it's much more likely that
the value you get out of that

263
00:11:33,500 --> 00:11:36,120
mistake you put in will just
flow through your program and

264
00:11:36,120 --> 00:11:38,680
end up causing a problem
later on.

265
00:11:38,680 --> 00:11:42,110
That just makes it very, very
hard to find your problem.

266
00:11:42,110 --> 00:11:44,660
Almost anything goes.

267
00:11:44,660 --> 00:11:46,900
For the program productivity,
it's much better to throw

268
00:11:46,900 --> 00:11:48,680
errors more eagerly.

269
00:11:48,680 --> 00:11:51,980
So it makes it much easier to
locate the source of an error,

270
00:11:51,980 --> 00:11:57,230
and it gives you many of the
errors when you're testing

271
00:11:57,230 --> 00:12:00,660
your code, not at run time
at the end user's side.

272
00:12:00,660 --> 00:12:02,450
So it gives you more
confidence in the

273
00:12:02,450 --> 00:12:03,280
deployed apps, too.

274
00:12:03,280 --> 00:12:06,470
It's really a good thing
for writing large scale

275
00:12:06,470 --> 00:12:08,930
applications and being able to
trust that they actually work

276
00:12:08,930 --> 00:12:10,890
as intended.

277
00:12:10,890 --> 00:12:12,470
Let me give you a few
examples of that.

278
00:12:12,470 --> 00:12:15,790
So in JavaScript,
constructors for

279
00:12:15,790 --> 00:12:18,060
objects are just functions.

280
00:12:18,060 --> 00:12:20,080
That seems pretty
nice and simple.

281
00:12:20,080 --> 00:12:23,910
I can use the function
as a constructor.

282
00:12:23,910 --> 00:12:24,740
It just sort of works.

283
00:12:24,740 --> 00:12:29,370
So if we build on the point
example from before, we can

284
00:12:29,370 --> 00:12:32,790
clearly allocate a point by
using that as a constructor.

285
00:12:32,790 --> 00:12:34,620
But what happens if we actually
forget to write new

286
00:12:34,620 --> 00:12:37,610
in front of that constructor
application?

287
00:12:37,610 --> 00:12:38,990
Well, it turns out it works.

288
00:12:38,990 --> 00:12:40,170
It doesn't give you an error.

289
00:12:40,170 --> 00:12:41,620
It's fine.

290
00:12:41,620 --> 00:12:45,570
It does give you the point
undefined back., and

291
00:12:45,570 --> 00:12:48,490
additionally it gives you two
extra global variables, x and

292
00:12:48,490 --> 00:12:50,360
y, that have the
value 2 and 3.

293
00:12:50,360 --> 00:12:54,020
So you don't get a point, but
you get extra state and the

294
00:12:54,020 --> 00:12:55,370
global object.

295
00:12:55,370 --> 00:12:59,260
That seems unintended, kind of
weird, and just is a real

296
00:12:59,260 --> 00:12:59,850
source of errors.

297
00:12:59,850 --> 00:13:02,360
We see this every day.

298
00:13:02,360 --> 00:13:05,110
During the development of V8
we've been through quite a lot

299
00:13:05,110 --> 00:13:07,960
of JavaScript code written by
many, many people, and these

300
00:13:07,960 --> 00:13:11,850
sort of subtle bugs
always pop up.

301
00:13:11,850 --> 00:13:13,100
LARS BAK: And one more thing.

302
00:13:13,100 --> 00:13:17,040
The interesting part is that
undefined [? integers, ?]

303
00:13:17,040 --> 00:13:18,740
you can see here, you
can't even rely on.

304
00:13:18,740 --> 00:13:19,800
Because it's mutable.

305
00:13:19,800 --> 00:13:21,510
You can change that property.

306
00:13:21,510 --> 00:13:23,690
So most people that would write
correct code, in this

307
00:13:23,690 --> 00:13:26,750
case, will instead of undefined
use [? write ?]

308
00:13:26,750 --> 00:13:28,430
zero.

309
00:13:28,430 --> 00:13:30,496
That makes sense
to you, right?

310
00:13:30,496 --> 00:13:32,010
KASPER LUND: Yeah, it does.

311
00:13:32,010 --> 00:13:32,990
I don't know how many
people that make

312
00:13:32,990 --> 00:13:34,440
sense to, but anyway.

313
00:13:34,440 --> 00:13:36,330
Let's take another example.

314
00:13:36,330 --> 00:13:39,430
This is probably the most common
source of issues in

315
00:13:39,430 --> 00:13:41,190
JavaScript.

316
00:13:41,190 --> 00:13:43,960
If you have a typo in your
code, that gives you real

317
00:13:43,960 --> 00:13:45,460
problems and it's
hard to find.

318
00:13:45,460 --> 00:13:47,750
So I put some code up here
that uses an XML

319
00:13:47,750 --> 00:13:49,190
HTTP request object.

320
00:13:49,190 --> 00:13:53,120
And the intent is, of course,
to install a callback that

321
00:13:53,120 --> 00:13:56,740
will get invoked whenever the
ready state changes, and if we

322
00:13:56,740 --> 00:13:59,900
reach the done state,
which is state 4,

323
00:13:59,900 --> 00:14:01,390
will log in to console.

324
00:14:01,390 --> 00:14:02,410
Very simple.

325
00:14:02,410 --> 00:14:04,520
Unfortunately this
does not work.

326
00:14:04,520 --> 00:14:07,760
The console will never have
anything here, even if the

327
00:14:07,760 --> 00:14:09,580
ready state does change to 4.

328
00:14:09,580 --> 00:14:14,670
Because ready state is spelled
with a capital S. So

329
00:14:14,670 --> 00:14:16,420
JavaScript allows this,
and it's just fine.

330
00:14:16,420 --> 00:14:18,490
It just gives you undefined
every single time you try to

331
00:14:18,490 --> 00:14:21,120
read the ready state with a
lowercase S. And undefined is

332
00:14:21,120 --> 00:14:22,880
not equal to 4.

333
00:14:22,880 --> 00:14:25,820
Maybe it should be,
I don't know.

334
00:14:25,820 --> 00:14:28,060
Anyway, it's this kind of thing
that makes you less

335
00:14:28,060 --> 00:14:29,090
productive as a programmer.

336
00:14:29,090 --> 00:14:32,870
And it kind of sucks.

337
00:14:32,870 --> 00:14:35,530
If we're sort of continuing on
that trend, we can also take a

338
00:14:35,530 --> 00:14:37,410
look at implicit conversions.

339
00:14:37,410 --> 00:14:40,100
There have been some pretty
funny videos circulating the

340
00:14:40,100 --> 00:14:42,650
web with more examples like
this, but this is a very

341
00:14:42,650 --> 00:14:43,630
simple one.

342
00:14:43,630 --> 00:14:45,450
So here we have a string.

343
00:14:45,450 --> 00:14:48,040
Strings in JavaScript
are values.

344
00:14:48,040 --> 00:14:49,910
They're immutable, you
cannot change them.

345
00:14:49,910 --> 00:14:52,390
If you try, do like string
dot hash equals

346
00:14:52,390 --> 00:14:54,220
something, it's accepted.

347
00:14:54,220 --> 00:14:56,790
What actually happens here is
that you actually implicitly

348
00:14:56,790 --> 00:15:01,030
convert string to a string
object that wraps that string.

349
00:15:01,030 --> 00:15:02,990
And you can access properties
on that, you can even set

350
00:15:02,990 --> 00:15:04,420
properties on that.

351
00:15:04,420 --> 00:15:06,260
The only problem is you actually
throw that temporary

352
00:15:06,260 --> 00:15:09,540
object away just after having
done it, so it has no effect.

353
00:15:09,540 --> 00:15:12,230
So when you try to assert that
string dot hash is something

354
00:15:12,230 --> 00:15:14,410
reasonable afterwards,
it's undefined.

355
00:15:14,410 --> 00:15:17,230
And again, I probably should
have put void 0 here.

356
00:15:17,230 --> 00:15:20,840
Because you get a different
object wrapped around the

357
00:15:20,840 --> 00:15:23,810
string value to grab
hold of the hash.

358
00:15:23,810 --> 00:15:25,600
This is surprising
to many people.

359
00:15:25,600 --> 00:15:28,230
And often you use this kind of
trick to try to add some

360
00:15:28,230 --> 00:15:29,580
caching to your code.

361
00:15:29,580 --> 00:15:31,330
And it seems to work just fine,
except that you never

362
00:15:31,330 --> 00:15:33,200
get any caching out of it.

363
00:15:33,200 --> 00:15:36,080
It's a performance problem, and
it's just annoying to have

364
00:15:36,080 --> 00:15:37,330
to deal with.

365
00:15:37,330 --> 00:15:39,770

366
00:15:39,770 --> 00:15:41,070
I think I can top
the last slide.

367
00:15:41,070 --> 00:15:42,860
How about this one?

368
00:15:42,860 --> 00:15:45,750
I don't know if anyone here can
tell me why 2.0 should be

369
00:15:45,750 --> 00:15:48,940
equal to the string two, that
is equal to a Boolean object

370
00:15:48,940 --> 00:15:51,280
that wraps the true value,
that is equal

371
00:15:51,280 --> 00:15:52,480
to the string one.

372
00:15:52,480 --> 00:15:54,920
But it is.

373
00:15:54,920 --> 00:15:56,880
There are so many implicit
conversions going on here that

374
00:15:56,880 --> 00:15:58,750
it makes my head explode.

375
00:15:58,750 --> 00:16:02,390
And having to implement this
in V8, it was a lot of fun.

376
00:16:02,390 --> 00:16:04,960
But sometimes you have to doubt
whether or not the value

377
00:16:04,960 --> 00:16:06,300
you get out of these implicit
conversions

378
00:16:06,300 --> 00:16:07,760
is worth the trouble.

379
00:16:07,760 --> 00:16:09,250
LARS BAK: Actually if you take
the [INAUDIBLE] script

380
00:16:09,250 --> 00:16:11,520
standard and go through
specification, you'll figure

381
00:16:11,520 --> 00:16:14,850
out that you need at least six
implicit conversions of

382
00:16:14,850 --> 00:16:18,330
objects before you can evaluate
this expression.

383
00:16:18,330 --> 00:16:20,060
KASPER LUND: Yeah, and they go
in different directions.

384
00:16:20,060 --> 00:16:22,040
Like sometimes you convert to
numbers implicitly, sometimes

385
00:16:22,040 --> 00:16:25,790
to strings, sometimes from
objects to primitive values.

386
00:16:25,790 --> 00:16:28,960
It's pretty messy.

387
00:16:28,960 --> 00:16:31,400
Another big issue that we see,
and this is of course also

388
00:16:31,400 --> 00:16:35,240
coming from the low level, from
the VM side up, is that

389
00:16:35,240 --> 00:16:37,820
JavaScript has really
unpredictable performance.

390
00:16:37,820 --> 00:16:40,490
There's sort of an advice
floating around that you

391
00:16:40,490 --> 00:16:42,300
should just try to use the
efficient subset of

392
00:16:42,300 --> 00:16:43,310
JavaScript.

393
00:16:43,310 --> 00:16:46,370
Because VMs over the last few
years have been optimized for

394
00:16:46,370 --> 00:16:47,630
certain patterns.

395
00:16:47,630 --> 00:16:49,120
And if you want to benefit
from the performance

396
00:16:49,120 --> 00:16:53,270
improvements, and you probably
do want to do that, you have

397
00:16:53,270 --> 00:16:57,040
to hit that sweet spot, and have
all your code fit in that

398
00:16:57,040 --> 00:16:58,770
efficient subset.

399
00:16:58,770 --> 00:17:00,980
The problem is that it's
actually kind of hard to find

400
00:17:00,980 --> 00:17:01,580
that subset.

401
00:17:01,580 --> 00:17:03,790
Nobody can tell you what
that subset is.

402
00:17:03,790 --> 00:17:05,589
It depends on the browser,
it depends on the

403
00:17:05,589 --> 00:17:06,920
version of the browser.

404
00:17:06,920 --> 00:17:09,190
And it's not just about using
the right syntactic

405
00:17:09,190 --> 00:17:10,170
constructs.

406
00:17:10,170 --> 00:17:13,579
It can be about not fetching
local variables from the

407
00:17:13,579 --> 00:17:14,410
context chain.

408
00:17:14,410 --> 00:17:16,300
It can be about many
different things.

409
00:17:16,300 --> 00:17:18,770
If you see a site like
jsperf.com, where people try

410
00:17:18,770 --> 00:17:21,859
to upload these mini-snippets
of code to figure out what

411
00:17:21,859 --> 00:17:24,579
works well in certain browsers,
this is an act of

412
00:17:24,579 --> 00:17:25,359
desperation.

413
00:17:25,359 --> 00:17:27,579
People are trying to figure
out what works well.

414
00:17:27,579 --> 00:17:28,740
They just don't know.

415
00:17:28,740 --> 00:17:30,890
So the only way to write a
really high-performance

416
00:17:30,890 --> 00:17:33,680
JavaScript application is
to profile all the time.

417
00:17:33,680 --> 00:17:36,230
That takes time, again limiting
your productivity.

418
00:17:36,230 --> 00:17:38,780
So you can do amazing things
with JavaScript.

419
00:17:38,780 --> 00:17:41,980
It's just kind of tricky
and time consuming.

420
00:17:41,980 --> 00:17:45,620
And JavaScript performance
is pretty unpredictable.

421
00:17:45,620 --> 00:17:47,920
Sometimes it's really great, and
sometimes you get like a

422
00:17:47,920 --> 00:17:53,400
factor of 20 slower code, just
by using some slightly less

423
00:17:53,400 --> 00:17:55,640
common version of something.

424
00:17:55,640 --> 00:17:56,890
That's not a good place to be.

425
00:17:56,890 --> 00:17:59,990

426
00:17:59,990 --> 00:18:00,300
LARS BAK: All right.

427
00:18:00,300 --> 00:18:03,740
So this is the summary for
the JavaScript portion.

428
00:18:03,740 --> 00:18:09,290
And as Kasper stated, programs
are hard to understand when

429
00:18:09,290 --> 00:18:10,950
you look at the source code.

430
00:18:10,950 --> 00:18:15,170
And it's also hard to reason
about if you're a tool.

431
00:18:15,170 --> 00:18:17,930
One thing that's really bad in
JavaScript is you can monkey

432
00:18:17,930 --> 00:18:19,280
patch the basic objects.

433
00:18:19,280 --> 00:18:22,290
That means that if you have two
different components that

434
00:18:22,290 --> 00:18:26,220
rely on the same library,
you get into problems.

435
00:18:26,220 --> 00:18:29,370
Because if one component patches
the library in a way

436
00:18:29,370 --> 00:18:31,550
the other component cannot
handle, then

437
00:18:31,550 --> 00:18:32,720
your program breaks.

438
00:18:32,720 --> 00:18:36,380
So compatibility is
out the window.

439
00:18:36,380 --> 00:18:39,670
Keep on trucking mentality is
just surprising to most.

440
00:18:39,670 --> 00:18:41,930
And we have gotten programs
in to analyze

441
00:18:41,930 --> 00:18:43,920
where this is an error.

442
00:18:43,920 --> 00:18:46,730
So programmers actually sent
their programs out, in

443
00:18:46,730 --> 00:18:51,480
production, with these keep on
trucking errors in them.

444
00:18:51,480 --> 00:18:52,300
And then of course there's

445
00:18:52,300 --> 00:18:55,850
unpredictability about the code.

446
00:18:55,850 --> 00:18:58,060
You should try to take your
favorite fast-running

447
00:18:58,060 --> 00:19:03,520
JavaScript code and put delete
property in a crucial place,

448
00:19:03,520 --> 00:19:04,500
and then the performance
[? quota ?]

449
00:19:04,500 --> 00:19:06,950
will go down the toilet.

450
00:19:06,950 --> 00:19:10,010
So this was the motivational
part.

451
00:19:10,010 --> 00:19:12,620
And hopefully you can see
innovation is needed, if you

452
00:19:12,620 --> 00:19:15,420
want to move the platform
forward so it's more

453
00:19:15,420 --> 00:19:16,670
productive for programmers.

454
00:19:16,670 --> 00:19:19,380

455
00:19:19,380 --> 00:19:23,210
So let's talk about that.

456
00:19:23,210 --> 00:19:26,166
And you'll get that
in one slide.

457
00:19:26,166 --> 00:19:26,875
It's here.

458
00:19:26,875 --> 00:19:28,110
KASPER LUND: Here it is.

459
00:19:28,110 --> 00:19:30,600
LARS BAK: So since we're VM
developers, we don't really

460
00:19:30,600 --> 00:19:32,040
know how to design languages.

461
00:19:32,040 --> 00:19:35,560
So we thought a good idea would
be to take different

462
00:19:35,560 --> 00:19:38,020
languages, and take the best
aspects of them, and

463
00:19:38,020 --> 00:19:39,390
put them into one.

464
00:19:39,390 --> 00:19:43,610
So Dart is basically sort of a
combination of the syntax from

465
00:19:43,610 --> 00:19:47,590
JavaScript, the [? optional ?]
types in Strongtalk, the

466
00:19:47,590 --> 00:19:54,020
object model in Smalltalk, some
concepts from C#, and

467
00:19:54,020 --> 00:19:57,250
then an isolate model that's
inspired by Erlang.

468
00:19:57,250 --> 00:20:00,160
So that is very simple.

469
00:20:00,160 --> 00:20:05,740
And to specify what it is,
is an unsurprising simple

470
00:20:05,740 --> 00:20:06,240
[INAUDIBLE]

471
00:20:06,240 --> 00:20:06,800
language.

472
00:20:06,800 --> 00:20:11,130
With simple inheritance &mdash; we
have classes, and we have

473
00:20:11,130 --> 00:20:13,640
interfaces, and we have
a familiar syntax.

474
00:20:13,640 --> 00:20:18,520
So if you know how to program in
C# or Java or JavaScript, I

475
00:20:18,520 --> 00:20:21,850
would expect that you can get
productive within a few hours.

476
00:20:21,850 --> 00:20:23,540
KASPER LUND: One thing that's
worth mentioning here is that

477
00:20:23,540 --> 00:20:26,120
at some point we found that
if you want to develop a

478
00:20:26,120 --> 00:20:29,830
language, design it to make it
appealing to people, it has to

479
00:20:29,830 --> 00:20:31,620
have curly braces.

480
00:20:31,620 --> 00:20:34,910
It is not possible to come up
with a mainstream programming

481
00:20:34,910 --> 00:20:37,260
language that gets any
kind of acceptance

482
00:20:37,260 --> 00:20:38,350
without curly braces.

483
00:20:38,350 --> 00:20:41,440
So we have tons of
curly braces.

484
00:20:41,440 --> 00:20:42,670
You're welcome.

485
00:20:42,670 --> 00:20:48,560
[APPLAUSE]

486
00:20:48,560 --> 00:20:49,810
LARS BAK: It's sad, but true.

487
00:20:49,810 --> 00:20:55,250

488
00:20:55,250 --> 00:20:58,040
So let me just go on.

489
00:20:58,040 --> 00:21:01,780
So here is the point
example in Dart.

490
00:21:01,780 --> 00:21:04,930
This is the first Dart
example of this talk.

491
00:21:04,930 --> 00:21:07,390
And there's a class
named point.

492
00:21:07,390 --> 00:21:09,880
It has two fields, x and y.

493
00:21:09,880 --> 00:21:12,310
And there's a constructor.

494
00:21:12,310 --> 00:21:15,450
And parameters for the
constructor are this.x and

495
00:21:15,450 --> 00:21:18,500
this.y means when you call the
constructor it will assign the

496
00:21:18,500 --> 00:21:20,720
parameters to the two fields.

497
00:21:20,720 --> 00:21:23,520
So there's no body of the
constructor in this case.

498
00:21:23,520 --> 00:21:28,250
It also has an operator plus
that takes us another point,

499
00:21:28,250 --> 00:21:32,640
and then it returns a new point
that's actually the

500
00:21:32,640 --> 00:21:34,430
addition of the two points, the

501
00:21:34,430 --> 00:21:36,860
receiver and the parameter.

502
00:21:36,860 --> 00:21:40,860
Here you can see the shorthand
notation for a function, where

503
00:21:40,860 --> 00:21:42,340
you see the arrow.

504
00:21:42,340 --> 00:21:45,810
Syntax just means that there's
one expression to the right,

505
00:21:45,810 --> 00:21:50,270
and the function will return the
result of that expression.

506
00:21:50,270 --> 00:21:54,650
There's also a to string method,
and it returns a

507
00:21:54,650 --> 00:21:59,450
string so you can see what
coordinates the point has.

508
00:21:59,450 --> 00:22:01,450
Here we're using string
interpolation, it's fairly

509
00:22:01,450 --> 00:22:03,280
obvious what's going on.

510
00:22:03,280 --> 00:22:06,420
And then we have a top level
main that creates a new point.

511
00:22:06,420 --> 00:22:10,690
And then it has an expression
where we add one point to

512
00:22:10,690 --> 00:22:14,220
another point, which
is new point 4, 5.

513
00:22:14,220 --> 00:22:17,382
One thing I should point out,
you cannot call the

514
00:22:17,382 --> 00:22:20,030
constructor without new.

515
00:22:20,030 --> 00:22:21,260
That's a good thing.

516
00:22:21,260 --> 00:22:22,790
KASPER LUND: Hopefully this
syntax does not look

517
00:22:22,790 --> 00:22:23,840
too scary to people.

518
00:22:23,840 --> 00:22:26,450
I mean, the feedback we've
gotten so far is that this

519
00:22:26,450 --> 00:22:29,280
kind of code is actually fairly
easy for people to just

520
00:22:29,280 --> 00:22:30,840
read on the slide
and understand.

521
00:22:30,840 --> 00:22:32,616
That's exactly what
we're going for.

522
00:22:32,616 --> 00:22:36,990

523
00:22:36,990 --> 00:22:40,350
LARS BAK: When we designed the
language, we looked at various

524
00:22:40,350 --> 00:22:43,340
attempts to make scalable
programs.

525
00:22:43,340 --> 00:22:47,860
And there needs to be a way
where the programmer can

526
00:22:47,860 --> 00:22:51,530
specify the intent
of a library.

527
00:22:51,530 --> 00:22:53,720
And one way of doing that
is by specifying type

528
00:22:53,720 --> 00:22:55,130
annotations.

529
00:22:55,130 --> 00:22:56,700
And we have that in Dart.

530
00:22:56,700 --> 00:22:57,480
They're optional, though.

531
00:22:57,480 --> 00:23:00,370
So you can write without
types if you want to.

532
00:23:00,370 --> 00:23:03,530
And as your program matures and
you get more structure on

533
00:23:03,530 --> 00:23:07,070
it, you can add the types
any time you want.

534
00:23:07,070 --> 00:23:10,485
But they act as checkable
documentation for the code and

535
00:23:10,485 --> 00:23:11,280
the interfaces.

536
00:23:11,280 --> 00:23:14,750
So you can decide only to put in
types in the interface, but

537
00:23:14,750 --> 00:23:18,730
you can also decide to really
put in static types everywhere

538
00:23:18,730 --> 00:23:20,080
in your program.

539
00:23:20,080 --> 00:23:23,660
And people that are familiar
with the Java or C#, they have

540
00:23:23,660 --> 00:23:24,910
a tendency to do that.

541
00:23:24,910 --> 00:23:27,420

542
00:23:27,420 --> 00:23:29,430
We also have generics.

543
00:23:29,430 --> 00:23:31,800
And that makes really useful, so
you can specify you have a

544
00:23:31,800 --> 00:23:36,080
list of apples or a
set of oranges.

545
00:23:36,080 --> 00:23:39,210
States intent.

546
00:23:39,210 --> 00:23:41,650
The type system is a little
bit special in that it is

547
00:23:41,650 --> 00:23:47,810
considered unsound, because we
allow downcasts when steadily

548
00:23:47,810 --> 00:23:48,920
checking a Dart program.

549
00:23:48,920 --> 00:23:50,970
However, these abilities
are run time.

550
00:23:50,970 --> 00:23:54,060
So if you violate the assignment
rules, you'll get a

551
00:23:54,060 --> 00:23:55,240
runtime error.

552
00:23:55,240 --> 00:23:56,960
But it makes it very,
very flexible.

553
00:23:56,960 --> 00:23:59,540
And I'll show you that on the
next slide, hopefully.

554
00:23:59,540 --> 00:24:02,360

555
00:24:02,360 --> 00:24:04,570
Or the next slide.

556
00:24:04,570 --> 00:24:07,680
This one here is the point
example again, where we have

557
00:24:07,680 --> 00:24:09,780
added the types.

558
00:24:09,780 --> 00:24:14,980
So you can see that the fields
are now annotated with num,

559
00:24:14,980 --> 00:24:17,470
which is a number in Dart.

560
00:24:17,470 --> 00:24:22,390
And also the return type of the
operator plus will be a

561
00:24:22,390 --> 00:24:26,360
point, and the parameter to
that is also a point.

562
00:24:26,360 --> 00:24:28,800
So you can see, if you contrast
it to the first

563
00:24:28,800 --> 00:24:31,920
example, as little changes
you have to make in

564
00:24:31,920 --> 00:24:34,360
order to type it.

565
00:24:34,360 --> 00:24:38,370
And this hopefully here also
is very easy to read.

566
00:24:38,370 --> 00:24:41,230
KASPER LUND: We see people start
out without writing a

567
00:24:41,230 --> 00:24:42,230
lot of type notations.

568
00:24:42,230 --> 00:24:44,860
While they're prototyping, just
wanted to get some things

569
00:24:44,860 --> 00:24:47,160
done, they will write in a style
where they have less

570
00:24:47,160 --> 00:24:47,880
type notations.

571
00:24:47,880 --> 00:24:50,170
And once they want to coordinate
their work with

572
00:24:50,170 --> 00:24:54,450
coworkers, or maybe send it out
for a code review, they

573
00:24:54,450 --> 00:24:56,930
will add more types to try to
document what they felt like

574
00:24:56,930 --> 00:25:00,660
doing, an what the different
constructs were meant to do.

575
00:25:00,660 --> 00:25:05,330
Usually we end up having types
in interfaces and return types

576
00:25:05,330 --> 00:25:07,520
and parameters, and
less types in the

577
00:25:07,520 --> 00:25:08,820
implementations of methods.

578
00:25:08,820 --> 00:25:12,550
But it's a matter of taste,
and you can choose,

579
00:25:12,550 --> 00:25:13,800
essentially, what you like.

580
00:25:13,800 --> 00:25:17,940

581
00:25:17,940 --> 00:25:21,350
LARS BAK: So to some of you
that are used to generics,

582
00:25:21,350 --> 00:25:24,630
from Java or C#, this might
sound surprising.

583
00:25:24,630 --> 00:25:26,980
But we have covariant
generic types.

584
00:25:26,980 --> 00:25:35,370
And it basically means that if
apple is a fruit, then a list

585
00:25:35,370 --> 00:25:38,130
of apples is clearly
a list of fruits.

586
00:25:38,130 --> 00:25:42,290
In this example we have
the main function.

587
00:25:42,290 --> 00:25:47,070
It calls a pick apples
from a tree, and it

588
00:25:47,070 --> 00:25:49,220
returns a list of apples.

589
00:25:49,220 --> 00:25:52,190
And then you call the print
fruits method &mdash;

590
00:25:52,190 --> 00:25:53,060
hello &mdash;

591
00:25:53,060 --> 00:25:55,080
and that takes a
list of fruits.

592
00:25:55,080 --> 00:25:56,250
And it seems to work.

593
00:25:56,250 --> 00:25:57,770
And that's how it should work.

594
00:25:57,770 --> 00:26:01,420
But if you take Java or
C#, that will fail.

595
00:26:01,420 --> 00:26:05,470
Because if you take these two
generic types in these

596
00:26:05,470 --> 00:26:07,330
languages, they are unrelated.

597
00:26:07,330 --> 00:26:11,710
And the type system cannot
cope with it.

598
00:26:11,710 --> 00:26:14,100
It works like you
want it to work.

599
00:26:14,100 --> 00:26:16,370
KASPER LUND: That's exactly
what I wanted to say.

600
00:26:16,370 --> 00:26:19,220
This fits with your intuition
in most cases.

601
00:26:19,220 --> 00:26:22,690
And of course there are some
theoretical reasons why other

602
00:26:22,690 --> 00:26:24,410
languages have not
done this before.

603
00:26:24,410 --> 00:26:27,500
But this actually works pretty
well in practice.

604
00:26:27,500 --> 00:26:28,850
So it does give you some
runtime checks

605
00:26:28,850 --> 00:26:29,430
every now and then.

606
00:26:29,430 --> 00:26:31,370
But it works really
well in practice.

607
00:26:31,370 --> 00:26:37,020
And it makes the types
not get in your way

608
00:26:37,020 --> 00:26:38,290
LARS BAK: All right.

609
00:26:38,290 --> 00:26:40,380
So let's go for a small demo.

610
00:26:40,380 --> 00:26:47,160

611
00:26:47,160 --> 00:26:49,360
KASPER LUND: Let me show you
just a tiny bit of Dart code,

612
00:26:49,360 --> 00:26:50,530
and how it works in practice.

613
00:26:50,530 --> 00:26:55,260
And I want to try to illustrate
how these types can

614
00:26:55,260 --> 00:26:58,820
be checked at runtime to give
you very recognizable and very

615
00:26:58,820 --> 00:27:02,280
strong error signals, that allow
you to fix issues in

616
00:27:02,280 --> 00:27:03,520
your code much more quickly.

617
00:27:03,520 --> 00:27:06,410
So here's an instance of the
Dart editor running.

618
00:27:06,410 --> 00:27:08,580
I'm not going to go into a lot
of detail about the editor.

619
00:27:08,580 --> 00:27:13,340
You should come to the next talk
at 2:45 in Room Three.

620
00:27:13,340 --> 00:27:15,600
You'll get much more insights
into what the editor can do

621
00:27:15,600 --> 00:27:16,540
and how it works.

622
00:27:16,540 --> 00:27:18,950
This will just be
a small teaser.

623
00:27:18,950 --> 00:27:21,160
So here I have a
sunflower demo.

624
00:27:21,160 --> 00:27:25,000
I can show you that running in
our custom build of Chrome,

625
00:27:25,000 --> 00:27:26,750
that has the Dart VM enabled.

626
00:27:26,750 --> 00:27:30,120
And it's a fairly simple,
small thing.

627
00:27:30,120 --> 00:27:32,370
It just allows me to have a
slider and adjust the size of

628
00:27:32,370 --> 00:27:34,230
this sunflower thing.

629
00:27:34,230 --> 00:27:37,050
If I go back to the editor and
I deliberately introduce a

630
00:27:37,050 --> 00:27:38,810
small issue in the code &mdash;

631
00:27:38,810 --> 00:27:40,580
let me scroll down here,
find the main thing.

632
00:27:40,580 --> 00:27:44,690
Something like messing up and
providing a rubbish argument

633
00:27:44,690 --> 00:27:45,620
to draw frame.

634
00:27:45,620 --> 00:27:47,520
Instead of providing the
context, I'll give it the

635
00:27:47,520 --> 00:27:48,810
canvas instead.

636
00:27:48,810 --> 00:27:49,950
I'll say that.

637
00:27:49,950 --> 00:27:53,630
And because the VM is enabled
in this Dart [INAUDIBLE], I

638
00:27:53,630 --> 00:27:55,730
can just go and refresh the
browser, and it gets the

639
00:27:55,730 --> 00:27:56,320
latest source code.

640
00:27:56,320 --> 00:27:59,190
No compilation necessary.

641
00:27:59,190 --> 00:28:01,920
What actually happens is I go
back into the editor, because

642
00:28:01,920 --> 00:28:03,470
this actually gives
me an exception.

643
00:28:03,470 --> 00:28:06,650
Because I'm supposed to be
passing a canvas rendering

644
00:28:06,650 --> 00:28:07,500
context 2D.

645
00:28:07,500 --> 00:28:09,750
That's a nice, short name.

646
00:28:09,750 --> 00:28:12,100
It wants the context, and I'm
giving it a canvas instead.

647
00:28:12,100 --> 00:28:15,610
So I get a very recognizable
error, right here when I have

648
00:28:15,610 --> 00:28:16,360
the mistake.

649
00:28:16,360 --> 00:28:18,560
It doesn't try to keep
on trucking.

650
00:28:18,560 --> 00:28:21,310
And it really helps me, as a
developer, to figure out what

651
00:28:21,310 --> 00:28:22,600
I messed up.

652
00:28:22,600 --> 00:28:25,630
So this was a very small teaser,
just to show you that

653
00:28:25,630 --> 00:28:28,520
the checking of these types at
runtime can really help you

654
00:28:28,520 --> 00:28:33,210
just find those issues
really quickly.

655
00:28:33,210 --> 00:28:35,440
LARS BAK: And this is a good
example, where there's a

656
00:28:35,440 --> 00:28:38,890
mixture between untyped
code and typed code.

657
00:28:38,890 --> 00:28:42,020
And even though you have a
mixture, the typing in the

658
00:28:42,020 --> 00:28:44,990
type part will help you validate
that you used the

659
00:28:44,990 --> 00:28:46,460
code the right way.

660
00:28:46,460 --> 00:28:49,120
KASPER LUND: So the canvas
that I provided as the

661
00:28:49,120 --> 00:28:51,340
argument was untyped.

662
00:28:51,340 --> 00:28:53,130
That's OK to pass to something
that expects a type, but we

663
00:28:53,130 --> 00:28:55,640
will check it.

664
00:28:55,640 --> 00:28:57,060
Let's go back to the
presentation, here.

665
00:28:57,060 --> 00:29:00,000

666
00:29:00,000 --> 00:29:01,640
LARS BAK: All right.

667
00:29:01,640 --> 00:29:05,770
Since this is a full language,
we decided to select a small

668
00:29:05,770 --> 00:29:09,190
portfolio of cool language
features I hope you like.

669
00:29:09,190 --> 00:29:12,620
So let's go through
them quickly.

670
00:29:12,620 --> 00:29:15,980
So we have name constructors.

671
00:29:15,980 --> 00:29:19,540
And it means that you can have
more than one constructor in

672
00:29:19,540 --> 00:29:20,820
the same class.

673
00:29:20,820 --> 00:29:23,520
In this case here we
have added a name

674
00:29:23,520 --> 00:29:24,530
constructor to point.

675
00:29:24,530 --> 00:29:26,150
It's called polar.

676
00:29:26,150 --> 00:29:29,310
So if you have polar
coordinates, you can pass that

677
00:29:29,310 --> 00:29:32,070
in and also create a point.

678
00:29:32,070 --> 00:29:35,860
The main reason for doing that
is we don't have type

679
00:29:35,860 --> 00:29:38,710
overloading in Dart.

680
00:29:38,710 --> 00:29:42,380
And this will give you
flexibility compared to other

681
00:29:42,380 --> 00:29:46,820
languages, where you often
have to do several steady

682
00:29:46,820 --> 00:29:49,810
factory methods to get
to the same result.

683
00:29:49,810 --> 00:29:52,540
So, cool feature.

684
00:29:52,540 --> 00:29:54,200
Next.

685
00:29:54,200 --> 00:29:55,510
We have interfaces.

686
00:29:55,510 --> 00:29:58,240
But what we have also added
something called default

687
00:29:58,240 --> 00:30:00,560
implementations to interfaces.

688
00:30:00,560 --> 00:30:05,370
And it's mainly designed so that
novice users do not have

689
00:30:05,370 --> 00:30:09,180
to know all the implementation
types in the system.

690
00:30:09,180 --> 00:30:12,610
So all they have to know is
the simple interfaces.

691
00:30:12,610 --> 00:30:16,250
And you can say new to a list,
which is an interface, and the

692
00:30:16,250 --> 00:30:18,760
only thing that will happened
is it will just delegate the

693
00:30:18,760 --> 00:30:22,160
constructor call to the default
implementation.

694
00:30:22,160 --> 00:30:24,890
And in this case it's the
list [? factoring. ?]

695
00:30:24,890 --> 00:30:27,810
So we created two lists
for you here.

696
00:30:27,810 --> 00:30:30,890
In main, the first one,
is just a list

697
00:30:30,890 --> 00:30:33,050
without a generic parameter.

698
00:30:33,050 --> 00:30:37,360
And in that list you can add
any update you have.

699
00:30:37,360 --> 00:30:39,910
The second one is a
list of points.

700
00:30:39,910 --> 00:30:44,170
You can pass the optional
parameter linked to it.

701
00:30:44,170 --> 00:30:49,000
So we'll get a list of 12
elements, and you can only add

702
00:30:49,000 --> 00:30:51,430
points to it.

703
00:30:51,430 --> 00:30:53,980
KASPER LUND: So if you look at
the list constructor up in the

704
00:30:53,980 --> 00:30:57,140
interface, that square bracket
notation means that that

705
00:30:57,140 --> 00:30:58,460
parameter is optional.

706
00:30:58,460 --> 00:30:59,845
It can be provided by
the caller, and

707
00:30:59,845 --> 00:31:03,000
it can not be provided.

708
00:31:03,000 --> 00:31:05,873
The default implementation gets
to decide what to do it

709
00:31:05,873 --> 00:31:07,990
it's not provided, and in this
case it just initializes the

710
00:31:07,990 --> 00:31:10,150
list with zero elements and
you get to add your stuff

711
00:31:10,150 --> 00:31:11,750
afterwards.

712
00:31:11,750 --> 00:31:15,010
But it's a nice thing that you
can specify in the interface,

713
00:31:15,010 --> 00:31:17,050
that the intent is that you can
provide this if you want

714
00:31:17,050 --> 00:31:19,980
to, or you may not want to do
that and you get the default

715
00:31:19,980 --> 00:31:21,440
behavior instead.

716
00:31:21,440 --> 00:31:23,470
So that's another language
feature on the same slide.

717
00:31:23,470 --> 00:31:26,260
Like two in one.

718
00:31:26,260 --> 00:31:28,040
LARS BAK: Next one is
cascaded calls.

719
00:31:28,040 --> 00:31:31,180
How many of you have
used Smalltalk?

720
00:31:31,180 --> 00:31:32,860
KASPER LUND: Wow.

721
00:31:32,860 --> 00:31:36,070
LARS BAK: Out of the five,
how many like cascaded

722
00:31:36,070 --> 00:31:37,660
[? sends? ?]

723
00:31:37,660 --> 00:31:38,290
Nobody?

724
00:31:38,290 --> 00:31:42,020
Anyways, we have added
cascaded [? sends. ?]

725
00:31:42,020 --> 00:31:43,800
I'm a true believer in them.

726
00:31:43,800 --> 00:31:48,640
So it basically means we have a
construct that allows you to

727
00:31:48,640 --> 00:31:51,640
do multiple calls on
the same object.

728
00:31:51,640 --> 00:31:55,380
Here's an example where you
want to draw a circle.

729
00:31:55,380 --> 00:31:57,800
You get the canvas, the
x- and y-coordinates,

730
00:31:57,800 --> 00:31:59,380
and the size in.

731
00:31:59,380 --> 00:32:04,800
And you first compute the
context from the canvas, and

732
00:32:04,800 --> 00:32:08,650
then you want to do a
number of calls on

733
00:32:08,650 --> 00:32:10,120
that object, the context.

734
00:32:10,120 --> 00:32:12,430
And this is how it's
done in Dart.

735
00:32:12,430 --> 00:32:15,740
You use the dot dot notation,
and it means that you first

736
00:32:15,740 --> 00:32:19,290
call beginPath on the context,
then arc, then fill, then

737
00:32:19,290 --> 00:32:21,710
closePath, and then stroke.

738
00:32:21,710 --> 00:32:24,890
It's just a simple way to avoid
introducing yet another

739
00:32:24,890 --> 00:32:26,140
local variable.

740
00:32:26,140 --> 00:32:28,190

741
00:32:28,190 --> 00:32:30,510
KASPER LUND: It also gives us
great typing information.

742
00:32:30,510 --> 00:32:34,680
So if you have a canvas out of
context and that is typed in

743
00:32:34,680 --> 00:32:38,290
the definition of the canvas,
the system will know and be

744
00:32:38,290 --> 00:32:41,060
able to give you code completion
suggestions when

745
00:32:41,060 --> 00:32:43,500
you're doing these
cascaded things.

746
00:32:43,500 --> 00:32:48,320
So it helps, at least if the
alternative was to do a bar

747
00:32:48,320 --> 00:32:50,020
declaration, and have
to go through all

748
00:32:50,020 --> 00:32:50,290
the things with that.

749
00:32:50,290 --> 00:32:52,380
So this is shorter, and
nicer in many ways.

750
00:32:52,380 --> 00:32:56,350

751
00:32:56,350 --> 00:32:59,110
LARS BAK: Here's
another thing.

752
00:32:59,110 --> 00:33:02,030
This illustrates how we do
proper capturing of loop

753
00:33:02,030 --> 00:33:03,280
variables in Dart.

754
00:33:03,280 --> 00:33:05,760

755
00:33:05,760 --> 00:33:07,760
Here's a function called main.

756
00:33:07,760 --> 00:33:10,690
It has a list called closures.

757
00:33:10,690 --> 00:33:16,330
And we have a for loop from zero
to eight, where we add a

758
00:33:16,330 --> 00:33:19,840
closure each time you
execute the loop.

759
00:33:19,840 --> 00:33:25,030
And in this case here, it's just
a function that returns

760
00:33:25,030 --> 00:33:27,270
the [? count of variable ?] i.

761
00:33:27,270 --> 00:33:30,680
In most languages what happens
if you execute this code as

762
00:33:30,680 --> 00:33:31,680
specified &mdash;

763
00:33:31,680 --> 00:33:34,420
by the way, at the end here
we go through the list of

764
00:33:34,420 --> 00:33:36,600
closures, and then evaluate
the closure

765
00:33:36,600 --> 00:33:38,700
and print the result.

766
00:33:38,700 --> 00:33:42,520
If you do that in C# or in
JavaScript, you'll get a

767
00:33:42,520 --> 00:33:45,630
number of eights out, because
all the closures were referred

768
00:33:45,630 --> 00:33:48,680
to the same loop variable.

769
00:33:48,680 --> 00:33:50,320
In Dart it's different.

770
00:33:50,320 --> 00:33:54,030
In Dart, you'll introduce a new
loop variable each time

771
00:33:54,030 --> 00:33:55,680
you enter the loop.

772
00:33:55,680 --> 00:34:02,360
So in Dart, you'll see the
results 1, 2, 3, 4, 5, 6, 7.

773
00:34:02,360 --> 00:34:05,320
And this is a common mistake
when you use closures for

774
00:34:05,320 --> 00:34:06,910
programming.

775
00:34:06,910 --> 00:34:08,719
KASPER LUND: We have a number
of examples from JavaScript,

776
00:34:08,719 --> 00:34:12,300
again, where we see people
using asynchronous API.

777
00:34:12,300 --> 00:34:14,800
And they have to be very careful
to capture the right

778
00:34:14,800 --> 00:34:16,810
variables and the
right values.

779
00:34:16,810 --> 00:34:19,000
So there's a lot of small
mistakes in that, and you see

780
00:34:19,000 --> 00:34:21,130
a lot of weird things
going on with that.

781
00:34:21,130 --> 00:34:23,690
So we decided to try to fix
that, and make it simpler for

782
00:34:23,690 --> 00:34:25,010
programmers to reason
about this.

783
00:34:25,010 --> 00:34:29,239

784
00:34:29,239 --> 00:34:33,820
LARS BAK: So to us Dart is
beautiful, even though we took

785
00:34:33,820 --> 00:34:35,810
most of the components
and curly

786
00:34:35,810 --> 00:34:37,060
braces from other languages.

787
00:34:37,060 --> 00:34:39,449

788
00:34:39,449 --> 00:34:42,040
It's declarative, so we think
it's easy to read.

789
00:34:42,040 --> 00:34:44,260
And it's certainly toolable.

790
00:34:44,260 --> 00:34:47,699
We don't do any implicit
conversion, so the semantics

791
00:34:47,699 --> 00:34:49,830
is fairly straightforward.

792
00:34:49,830 --> 00:34:53,239
And the libraries are actually
read-only, so we can have

793
00:34:53,239 --> 00:34:58,470
composable component and it
works, and you can rely on it.

794
00:34:58,470 --> 00:35:05,280
And again, if you're used to
Java, C# or JavaScript, other

795
00:35:05,280 --> 00:35:07,620
languages with curly braces,
this should be easy.

796
00:35:07,620 --> 00:35:11,360

797
00:35:11,360 --> 00:35:15,210
KASPER LUND: So the Dart
language is, of course, a big

798
00:35:15,210 --> 00:35:16,540
part of this project.

799
00:35:16,540 --> 00:35:17,760
But there is more to it.

800
00:35:17,760 --> 00:35:20,790
So let me give you a brief
tour of what we're doing.

801
00:35:20,790 --> 00:35:23,690
Language is only part
of the story.

802
00:35:23,690 --> 00:35:27,200
If you want to have a great web
development platform, that

803
00:35:27,200 --> 00:35:30,250
entire platform has to be
well-tuned for helping you

804
00:35:30,250 --> 00:35:32,200
guys to deliver fantastic
apps.

805
00:35:32,200 --> 00:35:35,600
So developers need a great new
language, and we've tried to

806
00:35:35,600 --> 00:35:37,560
argue why Dart is that
new language.

807
00:35:37,560 --> 00:35:41,720
But you also need really fast
execution, and really fast

808
00:35:41,720 --> 00:35:42,670
startup applications.

809
00:35:42,670 --> 00:35:45,800
And you need very good tools for
developing your apps and

810
00:35:45,800 --> 00:35:48,420
for analyzing your apps.

811
00:35:48,420 --> 00:35:50,830
It's also very important that
you get very good integration

812
00:35:50,830 --> 00:35:53,450
with the DOM.

813
00:35:53,450 --> 00:35:55,830
As developers you need
all of this.

814
00:35:55,830 --> 00:35:59,170
So the Dart project is not just
about the language, it's

815
00:35:59,170 --> 00:36:04,820
also about innovating on the
tool side, and it's also about

816
00:36:04,820 --> 00:36:07,460
giving you access to much
better and much more

817
00:36:07,460 --> 00:36:08,710
predictable performance.

818
00:36:08,710 --> 00:36:12,830

819
00:36:12,830 --> 00:36:16,260
LARS BAK: Because we have
decided to make Dart run on

820
00:36:16,260 --> 00:36:18,860
existing platforms, we have
a little bit complicated

821
00:36:18,860 --> 00:36:20,260
deployment story for Dart.

822
00:36:20,260 --> 00:36:22,210
And I'll try to go
through it here.

823
00:36:22,210 --> 00:36:24,290
So the green stuff at
the top is your

824
00:36:24,290 --> 00:36:27,370
application, plus libraries.

825
00:36:27,370 --> 00:36:28,700
And you have a few
choices here.

826
00:36:28,700 --> 00:36:31,690
You can run it directly on that
Dartium build, which you

827
00:36:31,690 --> 00:36:35,590
saw Kasper demo before, and
it will run right away.

828
00:36:35,590 --> 00:36:37,680
But you can also process
the application

829
00:36:37,680 --> 00:36:39,380
library through tools.

830
00:36:39,380 --> 00:36:42,930
One tool is the Dart to JS
compiler, which will translate

831
00:36:42,930 --> 00:36:46,560
Dart into one single
JavaScript file.

832
00:36:46,560 --> 00:36:49,720
And then you can run it
in any modern browser.

833
00:36:49,720 --> 00:36:51,970
This is the part where you
should be happy we're not

834
00:36:51,970 --> 00:36:55,530
trying to break the web.

835
00:36:55,530 --> 00:36:59,260
Another tool we have is we can
convert an application, plus

836
00:36:59,260 --> 00:37:02,060
libraries, into a snapshot.

837
00:37:02,060 --> 00:37:05,560
And a snapshot is a serialized
form of the data structure

838
00:37:05,560 --> 00:37:08,590
that makes applications
start up much faster.

839
00:37:08,590 --> 00:37:10,740
I'll get back to that
in two slides.

840
00:37:10,740 --> 00:37:13,869

841
00:37:13,869 --> 00:37:16,280
KASPER LUND: This is actually
a really important point, I

842
00:37:16,280 --> 00:37:17,200
think I want to make it again.

843
00:37:17,200 --> 00:37:18,810
Lars already said it.

844
00:37:18,810 --> 00:37:21,300
Dart is compatible with
all modern browsers.

845
00:37:21,300 --> 00:37:26,300
So this is just a small cut-out
of the Buildbot we

846
00:37:26,300 --> 00:37:29,590
have running on
buildbot.dartlang.org.

847
00:37:29,590 --> 00:37:33,500
And it shows us testing Dart
across Firefox, Chrome,

848
00:37:33,500 --> 00:37:36,970
Safari, IE and Opera.

849
00:37:36,970 --> 00:37:38,900
This is actually just an
indication that we take this

850
00:37:38,900 --> 00:37:41,050
compatibility issue
very seriously.

851
00:37:41,050 --> 00:37:44,270
It's very dear to our hearts
to have Dart running really

852
00:37:44,270 --> 00:37:46,490
well across all modern
browsers.

853
00:37:46,490 --> 00:37:50,270
All the browsers here do not
have Dart VMs built in, so

854
00:37:50,270 --> 00:37:53,140
here we're using the Dart to
JavaScript translation.

855
00:37:53,140 --> 00:37:55,330
And we make that work across
all these browsers.

856
00:37:55,330 --> 00:37:58,943
And we continue to do that and
keep that part running.

857
00:37:58,943 --> 00:38:02,190

858
00:38:02,190 --> 00:38:04,460
Let me just spend a few moments
on telling you about

859
00:38:04,460 --> 00:38:06,090
the translation process.

860
00:38:06,090 --> 00:38:08,460
We do have a compiler that
translates Dart to JavaScript.

861
00:38:08,460 --> 00:38:11,430
It's written in Dart itself.

862
00:38:11,430 --> 00:38:15,930
That gives us a nice excuse
for using Dart

863
00:38:15,930 --> 00:38:17,330
as a language ourselves.

864
00:38:17,330 --> 00:38:19,680
And it also means that
we can compile Dart &mdash;

865
00:38:19,680 --> 00:38:21,290
through Dart to JS compiler &mdash;

866
00:38:21,290 --> 00:38:24,380
with itself, and get a compiler
out that actually can

867
00:38:24,380 --> 00:38:26,910
compile Dart to JavaScript,
that runs

868
00:38:26,910 --> 00:38:28,280
in any modern browser.

869
00:38:28,280 --> 00:38:31,470
That's maybe kind of freaky,
but it works really well.

870
00:38:31,470 --> 00:38:34,030
You can have a JavaScript
implementation of a Dart to

871
00:38:34,030 --> 00:38:37,430
JavaScript compiler by just
compiling it with itself.

872
00:38:37,430 --> 00:38:38,090
I like that stuff.

873
00:38:38,090 --> 00:38:40,520
LARS BAK: Maybe it'll go
to [? reflector ?] now.

874
00:38:40,520 --> 00:38:42,520
KASPER LUND: So let's get
back to something more

875
00:38:42,520 --> 00:38:43,030
down-to-earth.

876
00:38:43,030 --> 00:38:45,690
Here's a, I think
at this point,

877
00:38:45,690 --> 00:38:47,120
very well-known example.

878
00:38:47,120 --> 00:38:50,240
The point, with two fields,
x and y, and a

879
00:38:50,240 --> 00:38:51,550
constructor and a to string.

880
00:38:51,550 --> 00:38:53,910
And it translates to something
like this on the JavaScript.

881
00:38:53,910 --> 00:38:56,100
That's the right hand side.

882
00:38:56,100 --> 00:39:00,810
We create a structure, give it
an endpoint, and we fill in an

883
00:39:00,810 --> 00:39:03,360
explicit superclass, object in
this case, and put in a couple

884
00:39:03,360 --> 00:39:04,940
fields, x and y.

885
00:39:04,940 --> 00:39:07,740
And then we have a small piece
of code that actually

886
00:39:07,740 --> 00:39:11,000
translates this to JavaScript
instructor at runtime, and

887
00:39:11,000 --> 00:39:13,330
puts in the getters and setters
for these fields, and

888
00:39:13,330 --> 00:39:14,760
it makes it nice to work with.

889
00:39:14,760 --> 00:39:16,740
But the rest of the definition
of point is

890
00:39:16,740 --> 00:39:18,190
actually just the methods.

891
00:39:18,190 --> 00:39:21,570
So here you see the to string
method is being translated to

892
00:39:21,570 --> 00:39:24,670
a JavaScript to string method,
with a dollar zero at the end.

893
00:39:24,670 --> 00:39:25,940
That just means that
that function

894
00:39:25,940 --> 00:39:27,590
expects zero arguments.

895
00:39:27,590 --> 00:39:30,380
It's important for us to make
sure that these functions that

896
00:39:30,380 --> 00:39:32,710
you call get the expected number
of arguments, so you

897
00:39:32,710 --> 00:39:35,820
don't have this classical issue
in JavaScript where you

898
00:39:35,820 --> 00:39:38,110
forget to provide a parameter,
and it just kind of

899
00:39:38,110 --> 00:39:39,380
works in a weird way.

900
00:39:39,380 --> 00:39:41,670
The to string method on the
right is a bit more verbose

901
00:39:41,670 --> 00:39:43,040
than the one on the left.

902
00:39:43,040 --> 00:39:45,500
And that's because of the string
interpolation feature,

903
00:39:45,500 --> 00:39:50,670
where we will make it very, very
easy to convert strings,

904
00:39:50,670 --> 00:39:55,370
and bits and pieces of
expressions and code, to join

905
00:39:55,370 --> 00:39:56,200
them as strings.

906
00:39:56,200 --> 00:39:59,300
And you see here it's translated
into a couple of

907
00:39:59,300 --> 00:40:01,100
string concatenation
operations.

908
00:40:01,100 --> 00:40:04,170
So we'll do this for you, and
this code runs across all

909
00:40:04,170 --> 00:40:06,838
modern browsers.

910
00:40:06,838 --> 00:40:10,540
LARS BAK: We have to speed
up a little bit, I think.

911
00:40:10,540 --> 00:40:11,570
Anyways.

912
00:40:11,570 --> 00:40:14,730
One cool thing about Dart is
that because it is declarative

913
00:40:14,730 --> 00:40:17,140
we can do something called
tree shaking.

914
00:40:17,140 --> 00:40:19,810
And tree shaking is this
pre-deployment step that

915
00:40:19,810 --> 00:40:23,200
allows you to reduce the
size of the executable.

916
00:40:23,200 --> 00:40:25,290
And what it basically means
is that you take the main

917
00:40:25,290 --> 00:40:28,820
function and you start
shaking it.

918
00:40:28,820 --> 00:40:32,110
Everything that you're not using
will fall off the tree,

919
00:40:32,110 --> 00:40:34,490
and when you're done you can
wrap it up, and that's your

920
00:40:34,490 --> 00:40:36,080
application.

921
00:40:36,080 --> 00:40:41,010
So unused classes and unused
methods will be eliminated.

922
00:40:41,010 --> 00:40:45,920
And the application is just
penalized for what it's using,

923
00:40:45,920 --> 00:40:49,480
compared to what's being
included in libraries.

924
00:40:49,480 --> 00:40:53,145
And this is great because it
helps the download time of the

925
00:40:53,145 --> 00:40:56,280
application, and also helps
the startup time.

926
00:40:56,280 --> 00:40:57,710
KASPER LUND: It also means that
you can depend on a big

927
00:40:57,710 --> 00:41:00,670
library, and you only pay for
the small pieces of it you

928
00:41:00,670 --> 00:41:01,810
actually use.

929
00:41:01,810 --> 00:41:03,140
LARS BAK: You cannot do
that in JavaScript.

930
00:41:03,140 --> 00:41:03,880
Why?

931
00:41:03,880 --> 00:41:05,510
Well, because there's a val.

932
00:41:05,510 --> 00:41:07,400
Val is a thing that
takes a string and

933
00:41:07,400 --> 00:41:09,310
converts it into code.

934
00:41:09,310 --> 00:41:12,150
So you cannot analyze
it statically.

935
00:41:12,150 --> 00:41:15,670
The second one is, it also has
the with statement that

936
00:41:15,670 --> 00:41:16,800
introduces [? voodoo, ?]

937
00:41:16,800 --> 00:41:17,585
scoping.

938
00:41:17,585 --> 00:41:19,570
You basically have no chance of
figuring out what's being

939
00:41:19,570 --> 00:41:22,470
accessed in the outer scope.

940
00:41:22,470 --> 00:41:26,100
So that's much easier in Dart,
and that is what clear

941
00:41:26,100 --> 00:41:29,010
semantics will give you.

942
00:41:29,010 --> 00:41:32,800
Tree shaking is already used by
dart2js today, and clearly

943
00:41:32,800 --> 00:41:37,930
reduces the size of the app,
and also improves startup.

944
00:41:37,930 --> 00:41:40,440
We are in the process of also
working on a tool that takes

945
00:41:40,440 --> 00:41:44,230
Dart code, tree shakes it,
and emits Dart code.

946
00:41:44,230 --> 00:41:47,790
So the Dart code itself will
be easier to start up.

947
00:41:47,790 --> 00:41:49,970
And that will be based on the
same infrastructure as the

948
00:41:49,970 --> 00:41:51,520
Dart to JS compiler.

949
00:41:51,520 --> 00:41:54,170
KASPER LUND: Shaken,
not stirred.

950
00:41:54,170 --> 00:41:54,890
That's the motto.

951
00:41:54,890 --> 00:41:56,140
LARS BAK: Yes, James.

952
00:41:56,140 --> 00:41:58,350

953
00:41:58,350 --> 00:42:02,380
Another thing that should be
really cool and is already

954
00:42:02,380 --> 00:42:05,990
implemented in the Dart VM
is the Dart snapshots.

955
00:42:05,990 --> 00:42:11,120
And it's a binary form of the
entire Dart application.

956
00:42:11,120 --> 00:42:14,610
And our measurements so far
means that you get a 10x

957
00:42:14,610 --> 00:42:17,840
speedup compared to sourcing
in the application before

958
00:42:17,840 --> 00:42:19,400
starting up.

959
00:42:19,400 --> 00:42:21,670
And that's fantastic, because
that means that instead of

960
00:42:21,670 --> 00:42:25,520
having a one second startup,
you get down below 100

961
00:42:25,520 --> 00:42:28,810
milliseconds to start
up the application.

962
00:42:28,810 --> 00:42:30,070
And it's very simple.

963
00:42:30,070 --> 00:42:33,810
If you do the VM the right way,
you can just load the

964
00:42:33,810 --> 00:42:38,270
application into the heap, and
then you serialize the heap

965
00:42:38,270 --> 00:42:40,410
into a binary format.

966
00:42:40,410 --> 00:42:41,430
Very simple.

967
00:42:41,430 --> 00:42:43,330
And it's really, really
efficient when

968
00:42:43,330 --> 00:42:44,670
you start up again.

969
00:42:44,670 --> 00:42:47,320
What benefits you is you don't
have to do scanning and

970
00:42:47,320 --> 00:42:50,440
parsing of the source code.

971
00:42:50,440 --> 00:42:53,160
And also, on mobile devices,
you don't have to spend as

972
00:42:53,160 --> 00:42:58,070
much CPU resources in loading
in the application, because

973
00:42:58,070 --> 00:43:03,220
it's just a matter of
deserializing the heap.

974
00:43:03,220 --> 00:43:03,580
All right.

975
00:43:03,580 --> 00:43:05,920
KASPER LUND: It's important to
notice that this binary form

976
00:43:05,920 --> 00:43:07,370
is completely
platform-independent.

977
00:43:07,370 --> 00:43:09,573
It's the same thing you would
ship to a mobile device, that

978
00:43:09,573 --> 00:43:11,100
you would ship to the desktop.

979
00:43:11,100 --> 00:43:14,120
Even if it's like a 64-bit and
a 32-bit machine involved,

980
00:43:14,120 --> 00:43:15,020
it's the same format.

981
00:43:15,020 --> 00:43:17,620
So it's not about doing
a per-target

982
00:43:17,620 --> 00:43:18,680
compilation of any sort.

983
00:43:18,680 --> 00:43:21,560
This is just a binary form of
the source code, essentially.

984
00:43:21,560 --> 00:43:24,030
LARS BAK: It doesn't contain
any generic code.

985
00:43:24,030 --> 00:43:30,150
And it can handle going from a
32-bit machine to a 64-bit

986
00:43:30,150 --> 00:43:33,690
machine, if you want
to do that.

987
00:43:33,690 --> 00:43:34,660
All right.

988
00:43:34,660 --> 00:43:36,450
Now.

989
00:43:36,450 --> 00:43:37,700
Let's talk about the future.

990
00:43:37,700 --> 00:43:44,270

991
00:43:44,270 --> 00:43:46,460
One important part of this
project is to design a new

992
00:43:46,460 --> 00:43:47,570
programming language.

993
00:43:47,570 --> 00:43:51,900
And we are pretty much done
with that design process.

994
00:43:51,900 --> 00:43:55,620
We have a form of specification
made.

995
00:43:55,620 --> 00:43:58,910
You can download it and read it
if you want to, with a few

996
00:43:58,910 --> 00:44:00,000
exceptions.

997
00:44:00,000 --> 00:44:02,990
We have a few things
we will put in.

998
00:44:02,990 --> 00:44:07,170
One is we will probably
eliminate interfaces, because

999
00:44:07,170 --> 00:44:09,180
we also have abstract classes,
and they work

1000
00:44:09,180 --> 00:44:10,810
exactly the same way.

1001
00:44:10,810 --> 00:44:14,260
So these have just simplified
the language.

1002
00:44:14,260 --> 00:44:17,610
We'll also introduce mixins,
which allow you to do

1003
00:44:17,610 --> 00:44:22,150
co-sharing across inheritance
hierarchies.

1004
00:44:22,150 --> 00:44:26,120
That'll come in after
version one of Dart.

1005
00:44:26,120 --> 00:44:29,070
And then of course we'll have
some support for annotations,

1006
00:44:29,070 --> 00:44:33,430
because most IDEs say they
want annotations.

1007
00:44:33,430 --> 00:44:36,850
Java programmers want
annotations.

1008
00:44:36,850 --> 00:44:38,120
So that's how it is.

1009
00:44:38,120 --> 00:44:38,760
But anyway.

1010
00:44:38,760 --> 00:44:40,050
You should look at the
specification.

1011
00:44:40,050 --> 00:44:42,070
It's pretty much done, and
I hope you like it.

1012
00:44:42,070 --> 00:44:45,140
Otherwise send us comments.

1013
00:44:45,140 --> 00:44:48,520
So this is our timeline
we have on the

1014
00:44:48,520 --> 00:44:50,880
whiteboard in Denmark.

1015
00:44:50,880 --> 00:44:53,510
KASPER LUND: As you can tell,
up to 2009 we were busy

1016
00:44:53,510 --> 00:44:55,920
hacking on JavaScript,
making that faster.

1017
00:44:55,920 --> 00:44:59,330
And at some point Lars and I
decided to try to do something

1018
00:44:59,330 --> 00:45:00,440
a bit simpler than that.

1019
00:45:00,440 --> 00:45:02,780
We called that Spot, and
that was in 2010.

1020
00:45:02,780 --> 00:45:07,160
And we spent three months on
hacking up this new virtual

1021
00:45:07,160 --> 00:45:08,630
machine, a new programming
language, and

1022
00:45:08,630 --> 00:45:09,870
a new set of libraries.

1023
00:45:09,870 --> 00:45:11,640
And that was a lot of fun.

1024
00:45:11,640 --> 00:45:14,460
At some point it was so
promising that we decided to

1025
00:45:14,460 --> 00:45:19,150
turn it into a real project, and
it got re-branded to Dart.

1026
00:45:19,150 --> 00:45:21,160
And that's where we're at now.

1027
00:45:21,160 --> 00:45:26,480
So in 2011 we introduced Dart
as a technology preview, and

1028
00:45:26,480 --> 00:45:28,150
we've been getting a
lot of very good

1029
00:45:28,150 --> 00:45:30,500
feedback from that process.

1030
00:45:30,500 --> 00:45:34,940
So this here is all about making
Dart robust and really,

1031
00:45:34,940 --> 00:45:36,180
really fast.

1032
00:45:36,180 --> 00:45:39,090
And next year?

1033
00:45:39,090 --> 00:45:41,250
LARS BAK: Success.

1034
00:45:41,250 --> 00:45:42,500
KASPER LUND: That will do.

1035
00:45:42,500 --> 00:45:45,970

1036
00:45:45,970 --> 00:45:50,000
LARS BAK: So what we're working
on hard today is to

1037
00:45:50,000 --> 00:45:52,970
make sure that you have a
developer release in your

1038
00:45:52,970 --> 00:45:56,410
hands later this year, so you
can start relying on the

1039
00:45:56,410 --> 00:45:59,290
libraries, the performance
of Dart, and building

1040
00:45:59,290 --> 00:46:02,280
applications on top of it.

1041
00:46:02,280 --> 00:46:04,910
The release will include
the language &mdash;

1042
00:46:04,910 --> 00:46:08,020
fixed, hopefully, for
the first version &mdash;

1043
00:46:08,020 --> 00:46:10,790
libraries for the web and server
development, so you can

1044
00:46:10,790 --> 00:46:14,500
also write Dart applications
on the server side.

1045
00:46:14,500 --> 00:46:16,320
We have a programming
environment.

1046
00:46:16,320 --> 00:46:20,680
So some of it is based
on Eclipse.

1047
00:46:20,680 --> 00:46:24,100
And we also have a standalone
virtual machine, that's also

1048
00:46:24,100 --> 00:46:26,690
been integrated into
the Chromium build.

1049
00:46:26,690 --> 00:46:30,180
And that was the Dartium browser
you saw in the demo.

1050
00:46:30,180 --> 00:46:33,250
And then we have this translator
to JavaScript that

1051
00:46:33,250 --> 00:46:37,950
allows us to be compatible
with most browsers.

1052
00:46:37,950 --> 00:46:39,200
So this is exciting.

1053
00:46:39,200 --> 00:46:41,740

1054
00:46:41,740 --> 00:46:45,590
KASPER LUND: So in addition to
all that, Dart is already now,

1055
00:46:45,590 --> 00:46:48,130
and will remain, a fully open
source product here.

1056
00:46:48,130 --> 00:46:52,150
Dart is available under a very
permissive BSD license.

1057
00:46:52,150 --> 00:46:53,940
So if you want to take it,
run with it, use it for

1058
00:46:53,940 --> 00:46:56,160
something, have fun.

1059
00:46:56,160 --> 00:46:58,630
The entire idea is to try to
foster innovation in this

1060
00:46:58,630 --> 00:47:01,210
space, so it makes a lot of
sense for us to just put all

1061
00:47:01,210 --> 00:47:04,830
the bits and pieces out there,
and have a community based

1062
00:47:04,830 --> 00:47:05,890
around that.

1063
00:47:05,890 --> 00:47:07,430
It's developed in the open.

1064
00:47:07,430 --> 00:47:09,900
All our code reviews are on
public mailing lists, and all

1065
00:47:09,900 --> 00:47:12,120
the build bots are for
everybody to see.

1066
00:47:12,120 --> 00:47:16,310
It makes it much easier for us
to interact with members of

1067
00:47:16,310 --> 00:47:19,790
the community that have good
ideas or good feedback.

1068
00:47:19,790 --> 00:47:23,120
Already now we have a fairly
active community, and we're

1069
00:47:23,120 --> 00:47:26,600
getting a lot of very helpful
and very good feedback on new

1070
00:47:26,600 --> 00:47:28,880
ideas that we circulate
on the mailing list.

1071
00:47:28,880 --> 00:47:32,360
So if you're interested in
joining in, or at least trying

1072
00:47:32,360 --> 00:47:34,910
it out, you should go to some
of the online resources we

1073
00:47:34,910 --> 00:47:35,910
have available.

1074
00:47:35,910 --> 00:47:38,410
The primary site is
dartlang.org.

1075
00:47:38,410 --> 00:47:41,630
And there you'll find a lot of
information about how to

1076
00:47:41,630 --> 00:47:44,680
download the SDK and the
editor, and try it out.

1077
00:47:44,680 --> 00:47:49,440
So please try it out, continue
to give us good feedback.

1078
00:47:49,440 --> 00:47:51,880
LARS BAK: And one interesting
note is that since we released

1079
00:47:51,880 --> 00:47:57,930
it as a preview last fall,
we have had a few

1080
00:47:57,930 --> 00:47:59,710
changes to that platform.

1081
00:47:59,710 --> 00:48:02,760
There's now 9,000 revisions
since last fall.

1082
00:48:02,760 --> 00:48:04,870
So you can imagine that there's
a lot of change lists

1083
00:48:04,870 --> 00:48:06,260
coming out every day.

1084
00:48:06,260 --> 00:48:09,460
And we're really serious about
making this fast and

1085
00:48:09,460 --> 00:48:10,810
consistent.

1086
00:48:10,810 --> 00:48:12,895
KASPER LUND: It's fun to work
on a project like that, that

1087
00:48:12,895 --> 00:48:13,900
moves really quickly.

1088
00:48:13,900 --> 00:48:16,830
And it's fun to see people
that use it being excited

1089
00:48:16,830 --> 00:48:20,000
about the new changes, and
adapting their existing code

1090
00:48:20,000 --> 00:48:22,430
bases to new, interesting
things that

1091
00:48:22,430 --> 00:48:23,190
pop up in the language.

1092
00:48:23,190 --> 00:48:24,440
So it's been a fun process.

1093
00:48:24,440 --> 00:48:27,600

1094
00:48:27,600 --> 00:48:30,380
So there's even more about
Dart at this Google IO.

1095
00:48:30,380 --> 00:48:35,100
So this was a very sort of high
level presentation about

1096
00:48:35,100 --> 00:48:36,980
Dart, and the motivation
behind it.

1097
00:48:36,980 --> 00:48:40,390
If you're interested in more
details, I suggest you go to

1098
00:48:40,390 --> 00:48:44,710
the next talk, at 2:45 in Room
3, which is about building web

1099
00:48:44,710 --> 00:48:45,590
apps in Dart.

1100
00:48:45,590 --> 00:48:48,480
And you'll get more hands-on
experience with what it is to

1101
00:48:48,480 --> 00:48:50,980
build something new and
exciting in Dart.

1102
00:48:50,980 --> 00:48:53,070
There's also a talk about
migrating code that's written

1103
00:48:53,070 --> 00:48:56,970
in GWT to Dart in the
same room, Room 3.

1104
00:48:56,970 --> 00:48:59,200
And during the entire afternoon
here, from now,

1105
00:48:59,200 --> 00:49:02,780
essentially, to fairly late, we
have Dart office hours on

1106
00:49:02,780 --> 00:49:03,650
the Chrome demo floor.

1107
00:49:03,650 --> 00:49:06,660
So if you want to come chat with
us there, feel free to

1108
00:49:06,660 --> 00:49:08,840
drop by, and if you have
questions we'll be very happy

1109
00:49:08,840 --> 00:49:10,910
to try to answer them.

1110
00:49:10,910 --> 00:49:15,360
Tomorrow, if you're really
Darty, you should go to our

1111
00:49:15,360 --> 00:49:18,190
Bullseye, Your First Dart App
code lab, where you'll get a

1112
00:49:18,190 --> 00:49:21,680
chance to do some hands-on work
with the environment and

1113
00:49:21,680 --> 00:49:22,930
the product.

1114
00:49:22,930 --> 00:49:25,770

1115
00:49:25,770 --> 00:49:27,310
LARS BAK: And we are pretty
much at the end now.

1116
00:49:27,310 --> 00:49:29,280
So this is a summary slide.

1117
00:49:29,280 --> 00:49:32,580
I hope we managed to convince
you that Dart is a simple and

1118
00:49:32,580 --> 00:49:34,500
unsurprising object-oriented
language that

1119
00:49:34,500 --> 00:49:37,040
should be easy to use.

1120
00:49:37,040 --> 00:49:43,060
And it allows you to write
structured code, and also

1121
00:49:43,060 --> 00:49:46,830
develop tools that can analyze
these programs.

1122
00:49:46,830 --> 00:49:48,760
And it works on modern
browsers.

1123
00:49:48,760 --> 00:49:51,810
So we've had a lot of experience
in implementing

1124
00:49:51,810 --> 00:49:54,560
virtual machines for various
object-oriented languages.

1125
00:49:54,560 --> 00:49:59,810
This is the first time we are
doing a new language, and it's

1126
00:49:59,810 --> 00:50:00,490
a challenge.

1127
00:50:00,490 --> 00:50:01,610
But it's fun.

1128
00:50:01,610 --> 00:50:03,110
So thank you for listening.

1129
00:50:03,110 --> 00:50:06,400
And if you have any questions,
please line up in front of the

1130
00:50:06,400 --> 00:50:10,102
mics so we can capture
what you're asking.

1131
00:50:10,102 --> 00:50:13,320
KASPER LUND: Yeah, the final
thing here is to just make a

1132
00:50:13,320 --> 00:50:16,670
mental note of the fact that
it's fairly easy to build a

1133
00:50:16,670 --> 00:50:19,630
really high-performance, fast
virtual machine, at least

1134
00:50:19,630 --> 00:50:20,840
compared to building
a new language.

1135
00:50:20,840 --> 00:50:23,401
So we're having a lot of fun.

1136
00:50:23,401 --> 00:50:46,560
[APPLAUSE]

1137
00:50:46,560 --> 00:50:47,930
KASPER LUND: Go ahead.

1138
00:50:47,930 --> 00:50:48,630
AUDIENCE: Hello?

1139
00:50:48,630 --> 00:50:49,970
KASPER LUND: Yes, it's on.

1140
00:50:49,970 --> 00:50:51,660
AUDIENCE: Is it the
same JavaScript &mdash;

1141
00:50:51,660 --> 00:50:54,840
it's cross-browser, or do you
have different versions for

1142
00:50:54,840 --> 00:50:55,920
different browsers?

1143
00:50:55,920 --> 00:50:57,880
KASPER LUND: So we generate
one version of

1144
00:50:57,880 --> 00:50:59,536
the JavaScript code.

1145
00:50:59,536 --> 00:51:01,460
And there are some parts
in there that are

1146
00:51:01,460 --> 00:51:04,010
browser-specific, but right
now we just compile one

1147
00:51:04,010 --> 00:51:07,780
version that deals with all the
differences in one file.

1148
00:51:07,780 --> 00:51:10,910
So one output, one JavaScript
file that works across all the

1149
00:51:10,910 --> 00:51:12,550
modern browsers.

1150
00:51:12,550 --> 00:51:13,800
AUDIENCE: One other question.

1151
00:51:13,800 --> 00:51:17,280

1152
00:51:17,280 --> 00:51:21,310
You've shown us the language,
but the APIs that you use to

1153
00:51:21,310 --> 00:51:25,910
access the DOM and the other
elements of the browser, are

1154
00:51:25,910 --> 00:51:29,220
those familiar?

1155
00:51:29,220 --> 00:51:31,880
LARS BAK: They are the same.

1156
00:51:31,880 --> 00:51:34,550
We're using the same DOM
interface as JavaScript,

1157
00:51:34,550 --> 00:51:38,190
except a few changes to make
it more consistent.

1158
00:51:38,190 --> 00:51:40,840
And we call it the Dart
HTML library.

1159
00:51:40,840 --> 00:51:43,770
So it's also available when
you download Dart.

1160
00:51:43,770 --> 00:51:46,290
If you go to the next talk about
Dart, you'll see how

1161
00:51:46,290 --> 00:51:49,250
that's being used for building
web applications.

1162
00:51:49,250 --> 00:51:52,170
But this talk was mostly about
the language, and not how to

1163
00:51:52,170 --> 00:51:54,270
hook it up to the web.

1164
00:51:54,270 --> 00:51:57,786
LARS BAK: If you drop by the
Chrome demo floor, I'm sure

1165
00:51:57,786 --> 00:51:59,340
someone can show you what
it is and how it

1166
00:51:59,340 --> 00:52:03,880
looks at the API level.

1167
00:52:03,880 --> 00:52:05,590
AUDIENCE: I had a question, I
guess more about the Dart

1168
00:52:05,590 --> 00:52:07,070
editor, but.

1169
00:52:07,070 --> 00:52:09,430
I've played with it a little
bit, and I was wondering if

1170
00:52:09,430 --> 00:52:12,610
there's plans to make an
official Eclipse plugin, so

1171
00:52:12,610 --> 00:52:14,560
that we can get all the version
control, and other

1172
00:52:14,560 --> 00:52:17,460
features of the Eclipse
platform.

1173
00:52:17,460 --> 00:52:20,970
LARS BAK: There's been a lot of
requests to get a plugin.

1174
00:52:20,970 --> 00:52:23,850
And behind the scenes it's
sort of the same.

1175
00:52:23,850 --> 00:52:26,030
So we will wrap it
up at some point.

1176
00:52:26,030 --> 00:52:28,910
I cannot give you a date when it
is there, but it will come.

1177
00:52:28,910 --> 00:52:32,920

1178
00:52:32,920 --> 00:52:34,390
KASPER LUND: Take one more here,
and then we'll switch to

1179
00:52:34,390 --> 00:52:36,070
that side for a while.

1180
00:52:36,070 --> 00:52:36,345
AUDIENCE: Yeah.

1181
00:52:36,345 --> 00:52:36,620
Sorry.

1182
00:52:36,620 --> 00:52:39,970
So what sort of integration,
or is there any integration

1183
00:52:39,970 --> 00:52:44,110
with Google Closure compiler
for JavaScript?

1184
00:52:44,110 --> 00:52:46,780
Like, do you guys pump out
minified, optimized

1185
00:52:46,780 --> 00:52:47,330
JavaScript?

1186
00:52:47,330 --> 00:52:49,740
Or is it just unminified and
then you pump it through

1187
00:52:49,740 --> 00:52:50,990
Closure afterwards?

1188
00:52:50,990 --> 00:52:53,340
KASPER LUND: So right now what
we're doing is we're

1189
00:52:53,340 --> 00:52:57,370
generating unminified but
optimized output.

1190
00:52:57,370 --> 00:52:59,680
And we're pushing hard on making
those optimizations

1191
00:52:59,680 --> 00:53:00,180
even better.

1192
00:53:00,180 --> 00:53:02,670
And we are working on
minification as well.

1193
00:53:02,670 --> 00:53:05,020
So we don't have any immediate
plans of using the Closure

1194
00:53:05,020 --> 00:53:07,320
compiler for doing this, because
sometimes we actually

1195
00:53:07,320 --> 00:53:11,240
use a lot of information, when
you go from our input to

1196
00:53:11,240 --> 00:53:14,270
JavaScript with type annotations
in common.

1197
00:53:14,270 --> 00:53:16,910
So we want to try to avoid
losing that kind of

1198
00:53:16,910 --> 00:53:19,100
information, and essentially
do the minification and

1199
00:53:19,100 --> 00:53:21,750
optimizations ourselves, based
on the fact that we understand

1200
00:53:21,750 --> 00:53:25,090
the Dart semantics even better
than the Closure compiler can.

1201
00:53:25,090 --> 00:53:27,660
LARS BAK: Minification is
actually very simple when you

1202
00:53:27,660 --> 00:53:31,280
have all the information
from the compiler.

1203
00:53:31,280 --> 00:53:36,220
So it's much easier to do it
ourselves than go through the

1204
00:53:36,220 --> 00:53:38,090
Closure compiler for
minification.

1205
00:53:38,090 --> 00:53:40,980
KASPER LUND: We also have a need
for minifying Dart code,

1206
00:53:40,980 --> 00:53:42,780
to make the download of
Dart code smaller.

1207
00:53:42,780 --> 00:53:45,110
So we will produce something
like a Dart-to-Dart

1208
00:53:45,110 --> 00:53:47,380
translator, that minifies
and optimizes.

1209
00:53:47,380 --> 00:53:47,840
AUDIENCE: Cool.

1210
00:53:47,840 --> 00:53:49,700
And just one other quick
question, is there any ability

1211
00:53:49,700 --> 00:53:54,640
to at runtime to load in
additional code, if you're

1212
00:53:54,640 --> 00:53:55,410
using binaries?

1213
00:53:55,410 --> 00:53:58,120
Or is it all done at
compile time only?

1214
00:53:58,120 --> 00:54:00,480
KASPER LUND: Actually we use
this concept that we actually

1215
00:54:00,480 --> 00:54:02,210
didn't introduce much here.

1216
00:54:02,210 --> 00:54:03,120
It's isolates.

1217
00:54:03,120 --> 00:54:06,790
And that's one way of creating
a completely new world that

1218
00:54:06,790 --> 00:54:09,800
you can populate with new,
dynamically loaded code.

1219
00:54:09,800 --> 00:54:11,820
And it's still a work in
progress, it's something that

1220
00:54:11,820 --> 00:54:13,430
we will be pushing more on.

1221
00:54:13,430 --> 00:54:15,430
LARS BAK: There's also
another way of

1222
00:54:15,430 --> 00:54:16,880
dynamically loading code.

1223
00:54:16,880 --> 00:54:21,220
We have a way of lazy loading
an entire library.

1224
00:54:21,220 --> 00:54:23,686
So when you say import to a
library, we'll say it should

1225
00:54:23,686 --> 00:54:25,600
be lazy loaded.

1226
00:54:25,600 --> 00:54:28,310
And you just have to activate
the loading.

1227
00:54:28,310 --> 00:54:29,680
And you cannot use the
[? interpoints ?]

1228
00:54:29,680 --> 00:54:31,440
that the library before it has
been completely loaded.

1229
00:54:31,440 --> 00:54:33,786
If you try to use it, it
throws an exception.

1230
00:54:33,786 --> 00:54:36,736

1231
00:54:36,736 --> 00:54:37,680
AUDIENCE: I just have
a question.

1232
00:54:37,680 --> 00:54:40,620
What is the recipe for
server [INAUDIBLE]?

1233
00:54:40,620 --> 00:54:45,321
So Dart is on the client side
sort of language, but how do

1234
00:54:45,321 --> 00:54:49,570
you envision the communication
between server and client

1235
00:54:49,570 --> 00:54:50,970
serialization?

1236
00:54:50,970 --> 00:54:53,210
[INAUDIBLE]

1237
00:54:53,210 --> 00:54:55,080
LARS BAK: So certainly
we support JSON.

1238
00:54:55,080 --> 00:54:59,060
So you can use the JSON format
to move stuff back and forth.

1239
00:54:59,060 --> 00:55:02,270
The language is not a client
language, it's

1240
00:55:02,270 --> 00:55:03,640
also a server language.

1241
00:55:03,640 --> 00:55:05,520
And we have a standard
loan VM you can run

1242
00:55:05,520 --> 00:55:06,880
on the server side.

1243
00:55:06,880 --> 00:55:10,590
And it has an I/O library
that supports &mdash;

1244
00:55:10,590 --> 00:55:11,420
[INAUDIBLE]

1245
00:55:11,420 --> 00:55:16,180
asynchronous way of doing I/O.
So you can write server code

1246
00:55:16,180 --> 00:55:19,700
in Dart, if you want to.

1247
00:55:19,700 --> 00:55:22,580
KASPER LUND: There's some work
going on with using something

1248
00:55:22,580 --> 00:55:23,650
like [? protobufs ?]

1249
00:55:23,650 --> 00:55:26,720
to communicate between
client and server.

1250
00:55:26,720 --> 00:55:28,940
There's a lot of community
interest in this area, too.

1251
00:55:28,940 --> 00:55:31,990
So it is very important to
stress that Dart runs just

1252
00:55:31,990 --> 00:55:33,080
fine on the server.

1253
00:55:33,080 --> 00:55:35,630
So you can write your code, the
client code and the server

1254
00:55:35,630 --> 00:55:38,820
code, in the same language, and
have that interoperate in

1255
00:55:38,820 --> 00:55:40,070
a nice way.

1256
00:55:40,070 --> 00:55:44,460

1257
00:55:44,460 --> 00:55:47,260
AUDIENCE: Does Dart support
compile time [INAUDIBLE], so

1258
00:55:47,260 --> 00:55:51,780
that I will be able to calculate
optimal parameters

1259
00:55:51,780 --> 00:55:55,250
before generating the code?

1260
00:55:55,250 --> 00:55:59,790
A good example of the use of
that is being articulated in

1261
00:55:59,790 --> 00:56:01,940
[INAUDIBLE]

1262
00:56:01,940 --> 00:56:05,930
and all the [INAUDIBLE]
programming language.

1263
00:56:05,930 --> 00:56:07,550
KASPER LUND: We have some
support for that.

1264
00:56:07,550 --> 00:56:10,480
It's not completely general, but
it's very simple, and it

1265
00:56:10,480 --> 00:56:11,170
works well.

1266
00:56:11,170 --> 00:56:15,650
That's in the form of what we
call compile time expressions.

1267
00:56:15,650 --> 00:56:17,330
There's a subset of the
language, essentially, that

1268
00:56:17,330 --> 00:56:21,530
you can use for building compile
time expressions.

1269
00:56:21,530 --> 00:56:25,090
And that includes user-defined
data structures, we call them

1270
00:56:25,090 --> 00:56:28,760
const objects, that are actually
built at compile time

1271
00:56:28,760 --> 00:56:29,770
rather than at runtime.

1272
00:56:29,770 --> 00:56:31,620
So there's some support
in the language there.

1273
00:56:31,620 --> 00:56:34,020
You should drop by the
demo floor, and I can

1274
00:56:34,020 --> 00:56:35,640
show you how it works.

1275
00:56:35,640 --> 00:56:38,360
LARS BAK: So for instance, in
the point example, if you make

1276
00:56:38,360 --> 00:56:41,240
the fields final, you
can make a const

1277
00:56:41,240 --> 00:56:43,220
constructor for the point.

1278
00:56:43,220 --> 00:56:46,260
So you make instances of point
as compile time expressions,

1279
00:56:46,260 --> 00:56:49,700
that are compiled
at compile time.

1280
00:56:49,700 --> 00:56:50,950
AUDIENCE: [INAUDIBLE]

1281
00:56:50,950 --> 00:56:55,120

1282
00:56:55,120 --> 00:57:02,320
AUDIENCE: What did you mean
by success for 2013?

1283
00:57:02,320 --> 00:57:06,350
LARS BAK: That we still have
a job working on Dart.

1284
00:57:06,350 --> 00:57:07,600
No.

1285
00:57:07,600 --> 00:57:10,540

1286
00:57:10,540 --> 00:57:13,080
That was a joke.

1287
00:57:13,080 --> 00:57:19,790
Success means that in 2013 we
have a stable system that's

1288
00:57:19,790 --> 00:57:25,550
out in Chrome, and we have many
real projects outside

1289
00:57:25,550 --> 00:57:29,930
Google, also working on
Dart and using Dart

1290
00:57:29,930 --> 00:57:31,010
for deploying code.

1291
00:57:31,010 --> 00:57:33,160
This is the ultimate goal.

1292
00:57:33,160 --> 00:57:37,040
The premise here is to make sure
programmers will get a

1293
00:57:37,040 --> 00:57:40,700
much better platform for
writing applications.

1294
00:57:40,700 --> 00:57:43,030
And if you cannot demonstrate
that,

1295
00:57:43,030 --> 00:57:44,770
that's certainly a failure.

1296
00:57:44,770 --> 00:57:47,650
AUDIENCE: So do you expect
any [INAUDIBLE]

1297
00:57:47,650 --> 00:57:56,250
is going to [INAUDIBLE], since
it's already compatible over

1298
00:57:56,250 --> 00:57:58,990
most of of the JavaScript
stuff, that's OK?

1299
00:57:58,990 --> 00:58:02,450
LARS BAK: So your question is,
will the other browser vendors

1300
00:58:02,450 --> 00:58:06,040
take the Dart VM and integrate
it into their browsers?

1301
00:58:06,040 --> 00:58:08,430
Well, I cannot answer that,
since I'm not controlling what

1302
00:58:08,430 --> 00:58:09,390
they're doing.

1303
00:58:09,390 --> 00:58:12,320
But what I can do is, I can
make sure that Dart is an

1304
00:58:12,320 --> 00:58:13,310
appealing offer.

1305
00:58:13,310 --> 00:58:16,850
So it's out there,
it's open source.

1306
00:58:16,850 --> 00:58:20,120
And if we can demonstrate Dart
applications when running with

1307
00:58:20,120 --> 00:58:22,880
a native VM has instant
startup, and better

1308
00:58:22,880 --> 00:58:28,390
performance than a similar
JavaScript program, it seems

1309
00:58:28,390 --> 00:58:32,410
very appealing to me, if I was
sitting in the other camp and

1310
00:58:32,410 --> 00:58:34,480
then integrated.

1311
00:58:34,480 --> 00:58:38,270
And we hope that will
happen of course.

1312
00:58:38,270 --> 00:58:40,230
AUDIENCE: I'm curious if all of
the Dart language features

1313
00:58:40,230 --> 00:58:41,320
compile to JavaScript?

1314
00:58:41,320 --> 00:58:44,590
And I'm specifically curious
about covariant generics.

1315
00:58:44,590 --> 00:58:46,270
KASPER LUND: So, yeah.

1316
00:58:46,270 --> 00:58:48,770
So covariant generics are
reasonably easy to compile to

1317
00:58:48,770 --> 00:58:49,180
JavaScript.

1318
00:58:49,180 --> 00:58:51,230
There's nothing in JavaScript
that hinders that.

1319
00:58:51,230 --> 00:58:55,710
There's one area where it's
problematic to have the full

1320
00:58:55,710 --> 00:58:58,790
Dart language implemented when
translated to JavaScript, and

1321
00:58:58,790 --> 00:59:00,070
that's numerics.

1322
00:59:00,070 --> 00:59:02,790
JavaScript does not have any
efficient way of having

1323
00:59:02,790 --> 00:59:05,010
arbitrary sized integers,
for instance.

1324
00:59:05,010 --> 00:59:07,450
Everything is, when it comes
to numbers, a double in

1325
00:59:07,450 --> 00:59:08,250
JavaScript.

1326
00:59:08,250 --> 00:59:11,790
So there are some restrictions
on how numbers work in Dart

1327
00:59:11,790 --> 00:59:14,030
when compiled to JavaScript,
compared to what you get on

1328
00:59:14,030 --> 00:59:15,260
the native VM.

1329
00:59:15,260 --> 00:59:16,520
It's a hard problem to solve.

1330
00:59:16,520 --> 00:59:18,990
We're looking at ways
of doing that.

1331
00:59:18,990 --> 00:59:21,460
But for now that's the one
area where there's a real

1332
00:59:21,460 --> 00:59:23,150
difference between
the two setups.

1333
00:59:23,150 --> 00:59:26,300
LARS BAK: We have discussed
caving in, and just having

1334
00:59:26,300 --> 00:59:28,720
numbers like in JavaScript.

1335
00:59:28,720 --> 00:59:30,610
But boy, we really like
integers, and the

1336
00:59:30,610 --> 00:59:32,140
semantics of integers.

1337
00:59:32,140 --> 00:59:34,700
And mixing them all up,
I think, is a mistake.

1338
00:59:34,700 --> 00:59:37,810
So that's the reason why,
precisely in this area, that's

1339
00:59:37,810 --> 00:59:39,610
a little bit of discrepancy
between the native

1340
00:59:39,610 --> 00:59:47,130
implementation and the
JavaScript-generated code.

1341
00:59:47,130 --> 00:59:48,535
Yes?

1342
00:59:48,535 --> 00:59:51,270
AUDIENCE: Is Google going
to promote Dart over

1343
00:59:51,270 --> 00:59:52,520
GWT down the road?

1344
00:59:52,520 --> 00:59:55,660

1345
00:59:55,660 --> 00:59:59,640
LARS BAK: GWT already has a
lot of customers, and it's

1346
00:59:59,640 --> 01:00:01,550
still supported.

1347
01:00:01,550 --> 01:00:04,720
We think, since we have done the
Dart part and have nothing

1348
01:00:04,720 --> 01:00:08,310
to do with the GWT part, that
this is a better fit for the

1349
01:00:08,310 --> 01:00:09,600
web platform.

1350
01:00:09,600 --> 01:00:14,390
And during the presentation
we were talking about this

1351
01:00:14,390 --> 01:00:17,790
importance of immediacy when
doing programming.

1352
01:00:17,790 --> 01:00:19,740
The fact that you can change the
file and get it up running

1353
01:00:19,740 --> 01:00:23,770
right away, where there's no
tool chain in between you and

1354
01:00:23,770 --> 01:00:25,520
debugging the program &mdash;

1355
01:00:25,520 --> 01:00:29,460
this is something that's hard to
do in GWT, where it's much,

1356
01:00:29,460 --> 01:00:32,690
much easier to do in Dart.

1357
01:00:32,690 --> 01:00:35,260
At the same time, in Dart
you can avoid the types.

1358
01:00:35,260 --> 01:00:38,480
So if you prototype, you can do
crazy stuff and don't think

1359
01:00:38,480 --> 01:00:40,640
about the types, it'll
still work.

1360
01:00:40,640 --> 01:00:45,190
And I think that really will
help you accelerate your

1361
01:00:45,190 --> 01:00:47,890
prototyping of your
application.

1362
01:00:47,890 --> 01:00:51,340
AUDIENCE: Also I was just
curious about, for a project

1363
01:00:51,340 --> 01:00:57,630
of similar size, how does Dart
stack up against GWT in terms

1364
01:00:57,630 --> 01:01:00,010
of code generation,
[INAUDIBLE]

1365
01:01:00,010 --> 01:01:01,540
JavaScript code?

1366
01:01:01,540 --> 01:01:05,300
Is it smaller in size,
or larger in size?

1367
01:01:05,300 --> 01:01:09,120

1368
01:01:09,120 --> 01:01:11,690
LARS BAK: I don't have
comparable numbers right now.

1369
01:01:11,690 --> 01:01:15,870
What I can tell you is that the
generated JavaScript code

1370
01:01:15,870 --> 01:01:17,310
from Dart is fairly
minimal now.

1371
01:01:17,310 --> 01:01:20,320
You should try it out.

1372
01:01:20,320 --> 01:01:23,150
And we expected to be
much smaller than

1373
01:01:23,150 --> 01:01:24,280
what GWT can generate.

1374
01:01:24,280 --> 01:01:28,430
I think the GWT system is also
doing a lot of tree shaking

1375
01:01:28,430 --> 01:01:32,130
before they generate
JavaScript code.

1376
01:01:32,130 --> 01:01:36,310
But they have a lot of legacy
stuff related to the Java

1377
01:01:36,310 --> 01:01:37,390
libraries they're using.

1378
01:01:37,390 --> 01:01:39,550
But I don't have numbers
right now.

1379
01:01:39,550 --> 01:01:42,820
So go home and measure it.

1380
01:01:42,820 --> 01:01:43,340
Yes.

1381
01:01:43,340 --> 01:01:45,660
KASPER LUND: This will be the
last question, by the way.

1382
01:01:45,660 --> 01:01:47,120
AUDIENCE: Two questions.

1383
01:01:47,120 --> 01:01:50,550
So first, the syntax
for importing a

1384
01:01:50,550 --> 01:01:53,160
module is pound import.

1385
01:01:53,160 --> 01:01:56,730
Do you have some sort of
preprocessor that you can use,

1386
01:01:56,730 --> 01:01:59,075
with if defs and stuff?

1387
01:01:59,075 --> 01:01:59,950
KASPER LUND: No.

1388
01:01:59,950 --> 01:02:02,400
But it is true that right now,
the way to write an import is

1389
01:02:02,400 --> 01:02:04,010
using a pound import.

1390
01:02:04,010 --> 01:02:06,700
It is to try to make it stick
out, and it certainly does.

1391
01:02:06,700 --> 01:02:09,650
And we are thinking about making
it look more like an

1392
01:02:09,650 --> 01:02:11,070
integrated part of the
language, rather than

1393
01:02:11,070 --> 01:02:12,410
preprocessing.

1394
01:02:12,410 --> 01:02:16,220
But it was designed to make
it stick out, and it does.

1395
01:02:16,220 --> 01:02:20,930
AUDIENCE: Secondly, for
isolates, are they implemented

1396
01:02:20,930 --> 01:02:22,340
as threads?

1397
01:02:22,340 --> 01:02:25,230
Or is it somehow a thin &mdash;

1398
01:02:25,230 --> 01:02:27,450
KASPER LUND: Thread.

1399
01:02:27,450 --> 01:02:29,600
LARS BAK: Since we translate
to JavaScript and it has to

1400
01:02:29,600 --> 01:02:32,630
run on top of a single
JavaScript engine, we have to

1401
01:02:32,630 --> 01:02:33,760
multiplex between them.

1402
01:02:33,760 --> 01:02:35,916
But you can run isolates.

1403
01:02:35,916 --> 01:02:38,100
AUDIENCE: But in the
Dart VM itself?

1404
01:02:38,100 --> 01:02:40,010
LARS BAK: Yes, they're running
completely independent, so

1405
01:02:40,010 --> 01:02:42,890
that you can have isolates
running in parallel.

1406
01:02:42,890 --> 01:02:44,490
AUDIENCE: So they are
actual threads?

1407
01:02:44,490 --> 01:02:46,110
KASPER LUND: They don't have
to be [? native ?]

1408
01:02:46,110 --> 01:02:46,350
threads.

1409
01:02:46,350 --> 01:02:47,890
There is a thread pull
implementation that we're

1410
01:02:47,890 --> 01:02:51,620
working on, where essentially
you'll get as many threads

1411
01:02:51,620 --> 01:02:52,880
running as you need to &mdash;

1412
01:02:52,880 --> 01:02:55,600
as the amount of parallels
you have in your program.

1413
01:02:55,600 --> 01:02:58,350
So it's not tied to one thread,
and it's more like a

1414
01:02:58,350 --> 01:03:00,800
thin threading model.

1415
01:03:00,800 --> 01:03:03,340
LARS BAK: So for instance, if
the isolate is not active it

1416
01:03:03,340 --> 01:03:06,370
doesn't have to have a native
thread bound to it.

1417
01:03:06,370 --> 01:03:10,560
AUDIENCE: Does it have a
pre-allocated execution stack?

1418
01:03:10,560 --> 01:03:12,950
Fixed size stack?

1419
01:03:12,950 --> 01:03:14,800
KASPER LUND: No, so, everything
is asynchronous.

1420
01:03:14,800 --> 01:03:15,660
There's no blocking.

1421
01:03:15,660 --> 01:03:17,490
So you actually don't
need to do that.

1422
01:03:17,490 --> 01:03:20,880
You just have to return from
your isolate at that point.

1423
01:03:20,880 --> 01:03:23,470
It is an asynchronous model,
so there are no execution

1424
01:03:23,470 --> 01:03:25,100
stacks stuck on native
threads or anything.

1425
01:03:25,100 --> 01:03:26,600
So it's very simple that way.

1426
01:03:26,600 --> 01:03:29,700
LARS BAK: So we are using the
native execution stack when

1427
01:03:29,700 --> 01:03:31,430
executing an isolate.

1428
01:03:31,430 --> 01:03:32,480
KASPER LUND: Thanks
for staying for

1429
01:03:32,480 --> 01:03:34,200
the Q&A. We're done.

1430
01:03:34,200 --> 01:03:35,450
LARS BAK: Thank you.

1431
01:03:35,450 --> 01:03:38,982

